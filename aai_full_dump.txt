### FILE: 0_Settings.rb ###
#===============================================================================
# Advanced AI System - Settings & Configuration
# Version: 2.0
#===============================================================================

module AdvancedAI
  # ============================================================================
  # CORE SETTINGS
  # ============================================================================
  
  # Enable/Disable the entire system
  ENABLED = true
  
  # Auto-activate with Challenge Modes plugin (if installed)
  ACTIVATE_WITH_CHALLENGE_MODES = true
  
  # Minimum skill level for auto-activation
  MIN_SKILL_FOR_AUTO_ACTIVATION = 70
  
  # Debug mode - detailed logging in console
  DEBUG_MODE = false
  
  # Debug switch intelligence specifically (verbose logging)
  DEBUG_SWITCH_INTELLIGENCE = false
  
  # Show move explanations in battle text (e.g., "Thunder Wave (Paralyze fast threat)")
  SHOW_MOVE_EXPLANATIONS = true
  
  # Logging options
  LOG_TO_CONSOLE = false  # Print logs to console window
  LOG_TO_FILE = false     # Write logs to file (Logs/ai_log.txt)
  
  # ============================================================================
  # WILD POKEMON AI SETTINGS
  # ============================================================================
  
  # Enable smart AI for wild Pokemon (uses move scoring instead of random selection)
  ENABLE_WILD_POKEMON_AI = true
  
  # Skill level for wild Pokemon when AI is enabled (0-100)
  # 0     = Random moves (vanilla behavior)
  # 50-69 = Core AI features
  # 70-84 = Advanced features  
  # 85-99 = Expert AI (items, patterns, personalities)
  # 100   = Master AI (includes Terastallization)
  WILD_POKEMON_SKILL_LEVEL = 100
  
  # ============================================================================
  # SKILL LEVEL THRESHOLDS
  # ============================================================================
  
  # Defines which AI features are enabled at each skill level
  SKILL_THRESHOLDS = {
    :core              => 50,   # Core AI (Move Scoring, Memory, Threats)
    :switch_intelligence => 50, # Switch Intelligence (Type matchup analysis)
    :setup             => 55,   # Setup Recognition
    :endgame           => 60,   # Endgame Scenarios (1v1, 2v2)
    :personalities     => 65,   # Battle Personalities
    :items             => 85,   # Item Intelligence
    :prediction        => 85,   # Prediction System
    :mega_evolution    => 90,   # Mega Evolution Intelligence
    :z_moves           => 90,   # Z-Move Intelligence (DBK_004)
    :dynamax           => 95,   # Dynamax Intelligence (DBK_005)
    :terastallization  => 100   # Terastallization (DBK_006)
  }
  
  # Switch decision thresholds by AI mode (simplified to 3 tiers)
  # Higher threshold = Less likely to switch (Must be in more danger)
  SWITCH_THRESHOLDS = {
    :beginner => 65,  # Skill 0-60: Stays in until very dangerous
    :mid      => 55,  # Skill 61-85: Balanced switching
    :pro      => 45,  # Skill 86+: Aggressive but stable switching
    :extreme  => 35   # Skill 100 + manual override: Near-perfect play
  }
  
  # === ENHANCED DIFFICULTY FEATURES BY TIER ===
  # Defines behavioral differences across difficulty levels
  TIER_FEATURES = {
    :beginner => {
      :switch_prediction   => false,   # No switch prediction
      :setup_detection     => false,   # Doesn't detect setup threats
      :hazard_awareness    => false,   # Ignores entry hazards
      :pivot_preference    => false,   # No pivot move priority
      :recovery_timing     => false,   # Basic recovery (when low HP)
      :status_value        => 0.5,     # 50% status move value
      :prediction_depth    => 0,       # No prediction
      :learn_patterns      => false    # No learning
    },
    :mid => {
      :switch_prediction   => true,    # Basic switch prediction
      :setup_detection     => true,    # Detects obvious setup (2+ boosts)
      :hazard_awareness    => true,    # Considers hazards
      :pivot_preference    => true,    # Prefers pivots when available
      :recovery_timing     => true,    # Smart recovery timing
      :status_value        => 1.0,     # Full status move value
      :prediction_depth    => 1,       # 1-turn prediction
      :learn_patterns      => false    # No learning yet
    },
    :pro => {
      :switch_prediction   => true,    # Advanced switch prediction
      :setup_detection     => true,    # Detects all setup threats
      :hazard_awareness    => true,    # Full hazard calculation
      :pivot_preference    => true,    # Optimal pivot usage
      :recovery_timing     => true,    # Perfect recovery timing
      :status_value        => 1.2,     # 120% status move value
      :prediction_depth    => 2,       # 2-turn prediction
      :learn_patterns      => true     # Basic pattern learning
    },
    :extreme => {
      :switch_prediction   => true,    # Perfect switch prediction
      :setup_detection     => true,    # Instant setup threat response
      :hazard_awareness    => true,    # Complete hazard mastery
      :pivot_preference    => true,    # Frame-perfect pivots
      :recovery_timing     => true,    # Optimal recovery (accounts for all factors)
      :status_value        => 1.5,     # 150% status move value
      :prediction_depth    => 3,       # 3-turn prediction
      :learn_patterns      => true     # Advanced pattern recognition
    }
  }
  
  # ============================================================================
  # ADVANCED FLAGS (Bit Flags for Fine-Tuning)
  # ============================================================================
  
  # Use bit flags for granular control
  # Example: 0b00000001 = Enable switch-ins prediction
  #          0b00000010 = Enable setup chain detection
  #          0b00000100 = Enable hazard calculations
  
  ADVANCED_FLAGS = {
    :switch_prediction    => 0b00000001,  # Predict opponent switches
    :setup_chains         => 0b00000010,  # Detect setup chains (Baton Pass)
    :hazard_calc          => 0b00000100,  # Calculate hazard damage
    :weather_abuse        => 0b00001000,  # Abuse weather conditions
    :terrain_abuse        => 0b00010000,  # Abuse terrain conditions
    :ko_prediction        => 0b00100000,  # Predict KO scenarios
    :revenge_kill         => 0b01000000,  # Prevent revenge kills
    :momentum_control     => 0b10000000   # Control battle momentum
  }
  
  # Default flags (all enabled for skill 100+)
  DEFAULT_FLAGS = 0b11111111
  
  # ============================================================================
  # PERSONALITY SETTINGS
  # ============================================================================
  
  # Auto-detect personality from team composition
  AUTO_DETECT_PERSONALITY = true
  
  # Personality modifiers (applied to move scores)
  PERSONALITY_MODIFIERS = {
    :aggressive => {
      :setup_moves       => 40,
      :powerful_moves    => 30,
      :risky_moves       => 25,
      :recoil_moves      => 15,
      :defensive_moves   => -30
    },
    :defensive => {
      :hazards           => 50,
      :screens           => 45,
      :recovery          => 40,
      :protect           => 35,
      :status_moves      => 30,
      :toxic_stall       => 20
    },
    :balanced => {
      :safe_setup        => 20,
      :recovery_low_hp   => 15,
      :finish_weak       => 10,
      :risky_moves       => -5
    },
    :hyper_offensive => {
      :damage_moves      => 60,
      :priority_moves    => 40,
      :multi_target      => 35,
      :super_effective   => 30,
      :status_moves      => -50,
      :switching         => -60
    }
  }
  
  # ============================================================================
  # AI BEHAVIOR SETTINGS
  # ============================================================================
  
  # If true, the AI will respect the "ReserveLastPokemon" flag on trainers
  # preventing their ace (last Pokemon) from being switched in early
  RESPECT_RESERVE_LAST_POKEMON = true
  
  # ============================================================================
  # COMPATIBILITY SETTINGS
  # ============================================================================
  
  # DBK Plugin Integration
  DBK_PLUGINS = {
    :mega_evolution   => true,  # Core Essentials (Enhanced)
    :dynamax          => true,  # DBK_005 - Dynamax
    :terastallization => true,  # DBK_006 - Terastallization
    :z_moves          => true,  # DBK_004 - Z-Power
    :raid_battles     => true,  # DBK_003 - Raid Battles
    :sos_battles      => true   # DBK_002 - SOS Battles
  }
  
  # Generation 9 Pack compatibility
  GEN9_PACK_COMPAT = true
  
  # ============================================================================
  # HELPER METHODS
  # ============================================================================
  
  # Logging utility
  def self.log(message, source = "AAI")
    return unless DEBUG_MODE || LOG_TO_CONSOLE || LOG_TO_FILE
    
    # Escape % characters to prevent printf formatting issues
    safe_message = message.to_s.gsub('%', '%%')
    formatted = "[#{source}] #{safe_message}"
    
    # Console output
    if DEBUG_MODE || LOG_TO_CONSOLE
      echoln formatted
    end
    
    # File output
    if LOG_TO_FILE
      begin
        Dir.mkdir("Logs") unless Dir.exist?("Logs")
        File.open("Logs/ai_log.txt", "a") do |f|
          f.puts "[#{Time.now.strftime("%H:%M:%S")}] #{formatted}"
        end
      rescue
        # Silent fail if file writing fails
      end
    end
  end
  
  # Check if Advanced AI is active
  def self.active?
    return false unless ENABLED
    return true if DEBUG_MODE  # Auto-activate in debug mode
    return true if defined?(Settings::CHALLENGE_MODE) && Settings::CHALLENGE_MODE && ACTIVATE_WITH_CHALLENGE_MODES
    return @manually_activated || false
  end
  
  # Manually activate/deactivate
  def self.activate!
    @manually_activated = true
  end
  
  def self.deactivate!
    @manually_activated = false
  end
  
  # Check if skill level qualifies for Advanced AI
  # NOTE: This checks if ANY Advanced AI features are available (core threshold: 50)
  # MIN_SKILL_FOR_AUTO_ACTIVATION (70) is only for automatic activation
  def self.qualifies_for_advanced_ai?(skill_level)
    return false unless ENABLED  # System must be enabled
    return skill_level >= SKILL_THRESHOLDS[:core]  # Need at least core features (50+)
  end
  
  # Game Variable ID that controls the AI Mode globally
  # 0 = Disabled (Use Skill Level logic)
  # 1 = Force Beginner Mode
  # 2 = Force Mid Mode
  # 3 = Force Pro Mode
  AI_MODE_VARIABLE = 100
  
  # Get AI mode based on skill level (simplified to 3 tiers)
  def self.get_ai_tier(skill_level)
    # Check global variable override
    if defined?($game_variables)
      override = $game_variables[AI_MODE_VARIABLE]
      return :beginner if override == 1
      return :mid      if override == 2
      return :pro      if override == 3
      return :extreme  if override == 4  # New: Extreme difficulty
    end
    
    # Fallback to skill-based logic
    return :beginner if skill_level <= 60
    return :mid if skill_level <= 85
    return :pro if skill_level <= 99
    return :extreme  # Skill 100 = Extreme mode
  end
  
  # Get tier feature value
  def self.tier_feature(skill_level, feature)
    tier = get_ai_tier(skill_level)
    return TIER_FEATURES.dig(tier, feature)
  end
  
  # Check if feature is enabled for skill level
  # NOTE: This checks if a specific feature is enabled based on skill threshold
  # Does NOT require active? (that's only for global system activation)
  def self.feature_enabled?(feature, skill_level)
    return false unless ENABLED  # System must be globally enabled
    return false unless SKILL_THRESHOLDS[feature]  # Feature must exist
    return skill_level >= SKILL_THRESHOLDS[feature]  # Check skill threshold
  end
  
  # Get setting value (with fallback)
  def self.get_setting(key, default = 0)
    return ADVANCED_FLAGS[key] || default
  end
  
  # Check if DBK plugin is enabled
  def self.dbk_enabled?(plugin)
    return false unless DBK_PLUGINS[plugin]
    
    # 1. Try PluginManager check (most reliable)
    if defined?(PluginManager) && PluginManager.respond_to?(:installed?)
      plugin_id = case plugin
        when :dynamax           then "[DBK] Dynamax"
        when :terastallization  then "[DBK] Terastalization"
        when :z_moves           then "[DBK] Z-Power"
        when :raid_battles      then "[DBK] Raid Battles"
        when :sos_battles       then "[DBK] SOS Battles"
        else nil
      end
      return true if plugin_id && PluginManager.installed?(plugin_id)
    end
    
    # 2. Fallback to method/constant checks
    case plugin
    when :mega_evolution
      return true # Built-in to Essentials, always available if item held
    when :dynamax
      # Check if Dynamax methods exist (more reliable than constants)
      return defined?(Battle) && Battle.instance_methods.include?(:pbCanDynamax?)
    when :terastallization
      # Check if Terastallization methods exist
      return defined?(Battle) && Battle.instance_methods.include?(:pbCanTerastallize?)
    when :z_moves
      return defined?(Battle) && Battle.instance_methods.include?(:pbCanZMove?)
    when :raid_battles
      return defined?(Battle) && Battle.instance_methods.include?(:pbRaidBattle?)
    when :sos_battles
      return defined?(Battle) && Battle.instance_methods.include?(:pbSOSBattle?)
    else
      return false
    end
  end
end

#===============================================================================
# Battle Integration
#===============================================================================

class Battle
  attr_accessor :advanced_ai_active
  attr_accessor :trainer_personalities
  
  alias aai_initialize initialize
  def initialize(*args)
    aai_initialize(*args)
    @advanced_ai_active = false
    @trainer_personalities = {}
  end
  
  # Check if trainer uses Advanced AI
  def uses_advanced_ai?(trainer_index)
    return false unless AdvancedAI.active?
    return false unless trainer_index
    trainer = pbGetOwnerFromBattlerIndex(trainer_index)
    return false unless trainer
    skill = trainer.skill_level || 50
    return AdvancedAI.qualifies_for_advanced_ai?(skill)
  end
  
  # Get/Set trainer personality
  def get_trainer_personality(trainer_index)
    @trainer_personalities[trainer_index] ||= detect_personality(trainer_index)
  end
  
  def set_trainer_personality(trainer_index, personality)
    @trainer_personalities[trainer_index] = personality
    AdvancedAI.log("Trainer #{trainer_index} personality set to #{personality}", "Personality")
  end
  
  private
  
  def detect_personality(trainer_index)
    return :balanced unless AdvancedAI::AUTO_DETECT_PERSONALITY
    # Will be implemented in Battle_Personalities.rb
    return :balanced
  end
end

#===============================================================================
# Skill Level Enhancement
#===============================================================================

class Battle::Battler
  # Enhanced skill level with AI tier
  def ai_skill_level
    return 0 unless @battle.opposes?(@index)
    trainer = @battle.pbGetOwnerFromBattlerIndex(@index)
    return 50 unless trainer
    return trainer.skill_level || 50
  end
  
  def ai_tier
    return AdvancedAI.get_ai_tier(ai_skill_level)
  end
end

#===============================================================================
# Challenge Mode Integration (Optional)
#===============================================================================

if defined?(Settings::CHALLENGE_MODE)
  EventHandlers.add(:on_start_battle, :advanced_ai_challenge_mode,
    proc { |battle|
      if Settings::CHALLENGE_MODE && AdvancedAI::ACTIVATE_WITH_CHALLENGE_MODES
        battle.advanced_ai_active = true
        AdvancedAI.log("Advanced AI activated via Challenge Mode", "Core")
      end
    }
  )
end

### FILE: Combat_Utilities.rb ###
#===============================================================================
# Advanced AI System - Combat Utilities (Shared Functions)
# Centralized damage calculation and common combat utilities
#===============================================================================

module AdvancedAI
  module CombatUtilities
    
    #===========================================================================
    # HP Percentage Calculations (DRY - Don't Repeat Yourself)
    #===========================================================================
    
    def self.hp_percent(battler)
      return 0 unless battler && battler.totalhp > 0
      battler.hp.to_f / battler.totalhp
    end
    
    def self.hp_threshold_score(hp_percent, thresholds)
      # Generic HP-based scoring
      # thresholds: Hash like { 0.33 => 80, 0.50 => 50, 0.70 => 30 }
      thresholds.each do |threshold, score|
        return score if hp_percent < threshold
      end
      return 0
    end
    
    #===========================================================================
    # Simplified Damage Calculation (For Quick Estimates)
    #===========================================================================
    
    def self.estimate_damage(attacker, move, defender, options = {})
      return 0 unless attacker && move && defender
      return 0 unless move.damagingMove?
      
      # Get base power
      power = move.power || 0
      return 0 if power == 0
      
      # Get stats based on move category
      if move.physicalMove?
        atk = attacker.attack
        defense = defender.defense
      elsif move.specialMove?
        atk = attacker.spatk
        defense = defender.spdef
      else
        return 0
      end
      
      # Pokemon damage formula (simplified)
      level = attacker.level
      base_damage = ((2.0 * level / 5 + 2) * power * atk / defense / 50 + 2)
      
      # STAB
      stab = attacker.pbHasType?(move.type) ? 1.5 : 1.0
      
      # Type effectiveness
      effectiveness = Effectiveness.calculate(move.type, *defender.pbTypes(true))
      return 0 if Effectiveness.ineffective?(effectiveness)
      
      effectiveness_mult = effectiveness.to_f / Effectiveness::NORMAL_EFFECTIVE_MULTIPLIER
      
      # Apply modifiers
      estimated_damage = (base_damage * stab * effectiveness_mult * 0.925).to_i
      
      # Optional: Return as percentage
      if options[:as_percent]
        return estimated_damage.to_f / [defender.totalhp, 1].max
      end
      
      return estimated_damage
    end
    
    #===========================================================================
    # Speed Comparison Utilities
    #===========================================================================
    
    def self.speed_tier_difference(user, target)
      return 0 unless user && target
      
      user_speed = user.pbSpeed
      target_speed = target.pbSpeed
      
      return 0 if user_speed == target_speed
      
      # Return ratio (how much faster/slower)
      if target_speed > user_speed
        target_speed.to_f / [user_speed, 1].max  # Positive = opponent faster
      else
        -(user_speed.to_f / [target_speed, 1].max)  # Negative = we're faster
      end
    end
    
    def self.is_faster?(user, target)
      return false unless user && target
      user.pbSpeed > target.pbSpeed
    end
    
    def self.is_much_slower?(user, target, threshold = 1.5)
      speed_diff = speed_tier_difference(user, target)
      speed_diff >= threshold
    end
    
    #===========================================================================
    # Team Size Utilities (For Trade Calculations)
    #===========================================================================
    
    def self.count_alive_pokemon(battle, battler_index)
      return 0 unless battle
      
      party = battle.pbParty(battler_index)
      return 0 unless party
      
      party.count { |p| p && !p.fainted? }
    end
    
    def self.team_advantage(battle, user_index, opponent_index)
      user_count = count_alive_pokemon(battle, user_index)
      opponent_count = count_alive_pokemon(battle, opponent_index)
      
      return 0 if user_count == 0 || opponent_count == 0
      
      # Return: 1 = ahead, 0 = even, -1 = behind
      if user_count > opponent_count
        return 1
      elsif user_count == opponent_count
        return 0
      else
        return -1
      end
    end
    
    #===========================================================================
    # Doubles Battle Utilities
    #===========================================================================
    
    def self.is_doubles?(battle)
      return false unless battle
      battle.pbSideSize(0) > 1
    end
    
    def self.get_partner(battler)
      return nil unless battler
      
      partners = battler.allAllies
      return nil if partners.empty?
      
      partners.first
    end
    
    def self.partner_alive?(battler)
      partner = get_partner(battler)
      partner && !partner.fainted?
    end
    
    #===========================================================================
    # Setup Detection
    #===========================================================================
    
    def self.is_boosted?(battler, threshold = 1)
      return false unless battler
      
      # Check offensive stat boosts
      atk_boost = battler.stages[:ATTACK] || 0
      spatk_boost = battler.stages[:SPECIAL_ATTACK] || 0
      
      (atk_boost + spatk_boost) >= threshold
    end
    
    def self.total_stat_boosts(battler)
      return 0 unless battler
      battler.stages.values.sum
    end
    
    #===========================================================================
    # Common Scoring Patterns
    #===========================================================================
    
    # Generic low HP bonus (desperation / cleanup)
    LOW_HP_THRESHOLDS = {
      0.25 => 60,
      0.33 => 50,
      0.50 => 30,
      0.70 => 15
    }
    
    # Generic partner HP concern
    PARTNER_HP_CONCERN = {
      0.33 => 80,
      0.50 => 50,
      0.70 => 30
    }
    
  end
end

### FILE: Core.rb ###
#===============================================================================
# Advanced AI System - Core Battle AI Integration
# Hooks into Pokemon Essentials v21.1 AI system
#===============================================================================

# RGSS Safety: Define Kernel#pp so it doesn't try to require the 'pp' library
# which doesn't exist in RGSS/mkxp. This prevents crashes when method
# resolution falls through to Kernel#pp on objects missing a 'pp' method.
module Kernel
  def pp(*args)
    return nil if args.empty?
    args.each { |a| p a }
    return args.length == 1 ? args[0] : args
  end
  module_function :pp
end

#===============================================================================
# AIMove Delegate Patches - Add missing method delegates from Battle::Move
# so that Advanced AI scorers can call move.pp, move.power, etc. on AIMove
#===============================================================================
class Battle::AI::AIMove
  def pp;            return @move.respond_to?(:pp) ? @move.pp : 0;                   end
  def total_pp;      return @move.respond_to?(:total_pp) ? @move.total_pp : 0;       end
  def power;         return @move.respond_to?(:power) ? @move.power : 0;             end
  def priority;      return @move.respond_to?(:priority) ? @move.priority : 0;       end
  def addlEffect;    return @move.respond_to?(:addlEffect) ? @move.addlEffect : 0;   end
  def accuracy;      return @move.respond_to?(:accuracy) ? @move.accuracy : 100;     end
  def category;      return @move.respond_to?(:category) ? @move.category : 0;       end
  def flags;         return @move.respond_to?(:flags) ? @move.flags : [];             end
  def contactMove?;  return @move.respond_to?(:contactMove?) ? @move.contactMove? : false;    end
  def soundMove?;    return @move.respond_to?(:soundMove?) ? @move.soundMove? : false;        end
  def flinchingMove?; return @move.respond_to?(:flinchingMove?) ? @move.flinchingMove? : false; end
  def multiHitMove?; return @move.respond_to?(:multiHitMove?) ? @move.multiHitMove? : false;  end
  def recoilMove?;   return @move.respond_to?(:recoilMove?) ? @move.recoilMove? : false;      end
  def pbNumHits(*args); return @move.respond_to?(:pbNumHits) ? @move.pbNumHits(*args) : 1;    end
end

class Battle::AI
  attr_accessor :move_memory
  attr_accessor :threat_cache
  attr_accessor :switch_analyzer
  
  alias aai_initialize initialize
  def initialize(battle)
    aai_initialize(battle)
    @move_memory = {}      # Track opponent move usage
    @threat_cache = {}     # Cache threat assessments
    @switch_analyzer = {}  # Analyze switch opportunities
    @type_effectiveness_cache = {}  # Cache type effectiveness calculations for performance
  end
  
  # Clear caches when battle ends (memory management)
  def clear_caches
    @type_effectiveness_cache&.clear
    @threat_cache&.clear
  end
  
  # Enhanced move scoring with Advanced AI integration
  # Note: This hooks into the DBK AI scoring system which calls pbGetMoveScore
  # with different signatures depending on context
  alias aai_pbGetMoveScore pbGetMoveScore
  def pbGetMoveScore(*args)
    # Extract parameters based on what was passed
    # DBK calls this with 0 args (no target) or 1 arg ([target])
    target_array = args[0] if args.length > 0
    target = target_array&.first if target_array.is_a?(Array)
    
    # CRITICAL FIX: Side/field-targeting moves (Stealth Rock, Reflect, Spikes,
    # Light Screen, etc.) have num_targets == 0, so vanilla calls pbGetMoveScore()
    # with NO target argument. We must pick a fallback opponent for scoring context,
    # otherwise score_move_advanced returns 0 and these moves are never chosen.
    if target.nil? && @user
      target = @battle.allOtherSideBattlers(@user.index).find { |b| b && !b.fainted? }
    end
    
    # Get skill from trainer OR wild Pokemon setting
    if @trainer
      skill = @trainer.skill
    else
      # Wild Pokemon - check if AI is enabled
      return aai_pbGetMoveScore(*args) unless AdvancedAI::ENABLE_WILD_POKEMON_AI
      skill = AdvancedAI::WILD_POKEMON_SKILL_LEVEL
      # If skill is 0, use vanilla random behavior
      return aai_pbGetMoveScore(*args) if skill == 0
    end
    
    # Check qualification First
    unless AdvancedAI.qualifies_for_advanced_ai?(skill)
      return aai_pbGetMoveScore(*args)
    end

    # Need move context for advanced scoring
    return aai_pbGetMoveScore(*args) unless @move
    
    # Use Advanced AI Scoring if qualified
    # This replaces the vanilla base score with our intelligent scoring
    score = score_move_advanced(@move, @user, target, skill)
    
    # Apply Advanced AI enhancements (Layers on top of base advanced score)
    score = apply_advanced_modifiers(score, @move, @user, target, skill)
    
    # === DEBUG: Per-factor move score breakdown ===
    if $DEBUG && @_score_factors && !@_score_factors.empty?
      move_name = @move.name rescue @move.id.to_s
      target_name = target.name rescue "???"
      user_name = @user.name rescue "???"
      echoln "  ┌─ MOVE SCORE: #{move_name} (#{user_name} vs #{target_name}) ─┐"
      echoln "    Base Score:                  100"
      @_score_factors.each do |name, value|
        next if value == 0
        sign = value >= 0 ? "+" : "-"
        padded_name = "#{sign} #{name}:".ljust(33)
        formatted_val = value >= 0 ? "+#{value}" : "#{value}"
        echoln "    #{padded_name}#{formatted_val}"
      end
      echoln "    ─────────────────────────────────"
      echoln "    = Final Score:               #{score}"
      echoln "  └───────────────────────────────────┘"
    end
    @_score_factors = nil
    
    return score
  end
  
  private
  
  def apply_advanced_modifiers(score, move, user, target, skill)
    factors = @_score_factors  # May be nil if not debugging
    
    # Core Systems (50+)
    if AdvancedAI.feature_enabled?(:core, skill)
      if target
        pre = score; score = apply_move_memory(score, move, user, target)
        factors["Move Memory"] = score - pre if factors && score != pre
        
        pre = score; score = apply_threat_assessment(score, move, user, target)
        factors["Threat Assessment"] = score - pre if factors && score != pre
        
        pre = score; score = apply_field_effects(score, move, user, target)
        factors["Field Effects"] = score - pre if factors && score != pre
      end
      if @battle.pbSideSize(0) > 1 && target
        pre = score; score = apply_doubles_coordination(score, move, user, target, skill)
        factors["Doubles Coordination"] = score - pre if factors && score != pre
      end
    end
    
    # Setup Recognition (55+)
    if AdvancedAI.feature_enabled?(:setup, skill)
      pre = score; score = apply_setup_evaluation(score, move, user, target)
      factors["Setup Recognition"] = score - pre if factors && score != pre
    end
    
    # Endgame Scenarios (60+)
    if AdvancedAI.feature_enabled?(:endgame, skill)
      pre = score; score = apply_endgame_logic(score, move, user, target)
      factors["Endgame Logic"] = score - pre if factors && score != pre
    end
    
    # Battle Personalities (65+)
    if AdvancedAI.feature_enabled?(:personalities, skill)
      pre = score; score = apply_personality_modifiers(score, move, user, target)
      factors["Personality"] = score - pre if factors && score != pre
    end
    
    # Strategic Awareness (70+) — archetype counters, win condition shifts,
    # coverage gaps, sacking, collective health, threat persistence, cores
    if skill >= 70
      pre = score; score = apply_strategic_awareness(score, move, user, target, skill)
      factors["Strategic Awareness"] = score - pre if factors && score != pre
    end
    
    # Tactical Enhancements (50+) — ability/item/move awareness, multi-turn planning
    if skill >= 50
      pre = score; score = apply_tactical_enhancements(score, move, user, target, skill)
      factors["Tactical Enhancements"] = score - pre if factors && score != pre
    end
    
    # Item Intelligence (85+)
    if AdvancedAI.feature_enabled?(:items, skill)
      pre = score; score = apply_item_intelligence(score, move, user, target)
      factors["Item Intelligence"] = score - pre if factors && score != pre
    end
    
    # Prediction System (85+)
    if AdvancedAI.feature_enabled?(:prediction, skill)
      if target
        pre = score; score = apply_prediction_logic(score, move, user, target)
        factors["Prediction"] = score - pre if factors && score != pre
      end
    end
    
    return score
  end
  
  # Placeholder methods — overridden by their respective module files
  # These stubs ensure the pipeline works even if a module isn't loaded
  def apply_move_memory(score, move, user, target)
    return score  # Overridden in Move_Memory.rb
  end
  
  def apply_threat_assessment(score, move, user, target)
    return score  # Overridden in Threat_Assessment.rb
  end
  
  def apply_field_effects(score, move, user, target)
    return score  # Overridden in Field_Effects.rb
  end
  
  def apply_doubles_coordination(score, move, user, target, skill = 100)
    return score  # Overridden in Doubles_Coordination.rb
  end
  
  def apply_setup_evaluation(score, move, user, target)
    return score  # Overridden in Setup_Recognition.rb
  end
  
  def apply_endgame_logic(score, move, user, target)
    return score  # Overridden in Endgame_Scenarios.rb
  end
  
  def apply_personality_modifiers(score, move, user, target)
    return score  # Overridden in Battle_Personalities.rb
  end
  
  def apply_strategic_awareness(score, move, user, target, skill = 100)
    return score  # Overridden in Strategic_Awareness.rb
  end
  
  def apply_tactical_enhancements(score, move, user, target, skill = 100)
    return score  # Overridden in Tactical_Enhancements.rb
  end
  
  def apply_item_intelligence(score, move, user, target)
    return score  # Overridden in Item_Intelligence.rb
  end
  
  def apply_prediction_logic(score, move, user, target)
    return score  # Overridden in Prediction_System.rb
  end
end

#===============================================================================
# Enhanced Switch Intelligence Integration
#===============================================================================
# Registers Advanced AI switch handler with Essentials AI system
# This gets checked FIRST before vanilla switch handlers
#===============================================================================

Battle::AI::Handlers::ShouldSwitch.add(:advanced_ai_switch_intelligence,
  proc { |battler, reserves, ai, battle|
    skill = ai.trainer&.skill || 100
    
    echoln "========================================"
    echoln "=== ADVANCED AI SWITCH ANALYSIS ==="
    echoln "  Pokemon: #{battler.name}"
    echoln "  Trainer Skill: #{skill}"
    echoln "  Reserves Available: #{reserves.length}"
    
    # DEBUG: Show which Pokemon are in reserves and which are filtered
    party = battle.pbParty(battler.index)
    echoln "  --- PARTY COMPOSITION DEBUG ---"
    party.each_with_index do |pkmn, i|
      next if !pkmn
      is_active = battle.pbFindBattler(i, battler.index)
      in_reserves = reserves.any? { |reserve_pkmn| reserve_pkmn == pkmn }
      can_switch = battle.pbCanSwitchIn?(battler.index, i)
      
      status = []
      status << "ACTIVE" if is_active
      status << "IN_RESERVES" if in_reserves
      status << "CANNOT_SWITCH (pbCanSwitchIn? = false)" if !can_switch
      status << "FAINTED" if pkmn.fainted?
      status << "EGG" if pkmn.egg?
      
      echoln "    [#{i}] #{pkmn.name}: #{status.join(', ')}"
    end
    
    # Check if Challenge Modes is filtering
    if defined?(ChallengeModes) && ChallengeModes.respond_to?(:on?)
      echoln "  --- CHALLENGE MODES STATUS ---"
      echoln "    Monotype Mode: #{ChallengeModes.on?(:MONOTYPE_MODE)}"
      echoln "    Randomizer Mode: #{ChallengeModes.on?(:RANDOMIZER_MODE)}"
    end
    echoln "  --- END DEBUG ---"
    
    qualifies = AdvancedAI.qualifies_for_advanced_ai?(skill)
    echoln "  Qualifies for Advanced AI? #{qualifies}"
    
    if !qualifies
      echoln "  >>> NOT qualified (need skill 50+)"
      echoln "=============================="
      next false
    end
    
    feature_enabled = AdvancedAI.feature_enabled?(:switch_intelligence, skill)
    echoln "  Switch Intelligence enabled? #{feature_enabled}"
    
    if !feature_enabled
      echoln "  >>> Feature not enabled for this skill level"
      echoln "=============================="
      next false
    end
    
    echoln "  >>> Checking switch logic..."
    echoln ""
    
    result = false
    begin
      # Call our Advanced AI switch logic from [012] Switch_Intelligence.rb
      # NOTE: battler is Battle::AI::AIBattler, need battler.battler for the real Battler
      if ai.respond_to?(:should_switch_advanced?)
        # Pass the real Battler object, not the AI wrapper
        real_battler = battler.respond_to?(:battler) ? battler.battler : battler
        result = ai.should_switch_advanced?(real_battler, skill)
        
        if result
          echoln ""
          echoln "  ✅ RESULT: SHOULD SWITCH!"
          echoln "=============================="
        else
          echoln ""
          echoln "  ❌ RESULT: Stay in battle"
          echoln "=============================="
        end
      else
        echoln "  ⚠️ ERROR: should_switch_advanced? not found"
        echoln "=============================="
      end
    rescue => e
      echoln "[AAI Core ERROR] #{e.class}: #{e.message}"
      echoln e.backtrace.first(3).join("\n")
      echoln "=============================="
      result = false
    end
    
    next result
  }
)

#===============================================================================
# Override replacement Pokemon selection to use Advanced AI logic
#===============================================================================
class Battle::AI
  alias aai_choose_best_replacement_pokemon choose_best_replacement_pokemon
  def choose_best_replacement_pokemon(idxBattler, terrible_moves = false)
    begin
      skill = @trainer&.skill || 100
      
      echoln "========================================"
      echoln "=== CHOOSING REPLACEMENT POKEMON ==="
      echoln "  Current: #{@user.name}"
      echoln "  Trainer Skill: #{skill}"
      echoln "  Forced Switch: #{terrible_moves}"
      
      # Anti-ping-pong: If this Pokemon just switched in, don't switch out
      # due to "terrible moves". Stall teams have low-scoring moves that are
      # still strategically correct (Toxic, Protect, Recover, etc.).
      # This prevents Blissey <-> Toxapex infinite switching loops.
      if terrible_moves && @user.turnCount < 2 && !@user.fainted?
        echoln "  >>> Anti-ping-pong: #{@user.name} just switched in (turn #{@user.turnCount})"
        echoln "  >>> Staying to use available moves instead of switching"
        echoln "========================================"
        return -1
      end
      
      # Stall archetype protection: Stall mons should NOT switch out due to
      # "terrible moves" when their stall gameplan is active (Toxic/Burn ticking,
      # Leech Seed draining). Their moves ARE the strategy.
      if terrible_moves && !@user.fainted? && AdvancedAI.has_stall_moveset?(@user)
        # Check if stall gameplan is working (opponent has passive damage)
        stall_working = false
        @battle.allOtherSideBattlers(@user.index).each do |target|
          next unless target && !target.fainted?
          leech_seed_val = (target.effects[PBEffects::LeechSeed] rescue -1)
          if target.poisoned? || target.burned? ||
             (leech_seed_val.is_a?(Numeric) && leech_seed_val >= 0)
            stall_working = true
            break
          end
        end
        
        if stall_working
          echoln "  >>> Stall Archetype: #{@user.name} has active stall gameplan"
          echoln "  >>> Staying to continue stalling (passive damage ticking)"
          echoln "========================================"
          return -1
        end
        
        # Even without active status, stall mons with recovery should stay
        has_recovery = @user.battler.moves.any? do |m|
          m && AdvancedAI.healing_move?(m.id)
        end
        has_useful_status = @user.battler.moves.any? do |m|
          next false unless m
          [:TOXIC, :WILLOWISP, :THUNDERWAVE, :LEECHSEED, :SCALD].include?(m.id)
        end
        if has_recovery && has_useful_status
          echoln "  >>> Stall Archetype: #{@user.name} has recovery + status moves"
          echoln "  >>> Staying to execute stall strategy"
          echoln "========================================"
          return -1
        end
      end
      
      # Debug: Check all conditions
      qualifies = AdvancedAI.qualifies_for_advanced_ai?(skill)
      feature_enabled = AdvancedAI.feature_enabled?(:switch_intelligence, skill)
      
      echoln "  Qualifies for Advanced AI? #{qualifies}"
      echoln "  Switch Intelligence enabled? #{feature_enabled}"
      echoln "  >>> Using send() to bypass visibility"
      
      # Use Advanced AI switch logic if qualified
      if qualifies && feature_enabled
        
        echoln "  >>> Using Advanced AI selection..."
        echoln ""
        
        # Call our advanced switch finder from [012] Switch_Intelligence.rb
        # Use send to bypass visibility restrictions
        # Returns party index directly (pass terrible_moves as forced_switch)
        best_idx = send(:find_best_switch_advanced, @user, skill, terrible_moves)
        if best_idx && @battle.pbCanSwitchIn?(idxBattler, best_idx)
          party = @battle.pbParty(idxBattler)
          best_pkmn = party[best_idx]
          echoln ""
          echoln "  ✅ SELECTED: #{best_pkmn.name} (Party Index: #{best_idx})"
          echoln "=============================="
          return best_idx
        end
        echoln "  >>> No suitable switch found"
        echoln "  >>> Falling back to vanilla..."
      else
        echoln "  >>> Using vanilla selection..."
        if !qualifies
          echoln "      Reason: Skill too low (need 50+)"
        elsif !feature_enabled
          echoln "      Reason: Feature not enabled"
        end
      end
      echoln "=============================="
    rescue => e
      begin
        msg = "[AAI ERROR] #{e.class}: #{e.message}".gsub('%', '%%')
        bt  = e.backtrace.first(3).join("\n").gsub('%', '%%')
        echoln msg
        echoln bt
      rescue
        echoln "[AAI ERROR] (could not format error message)"
      end
      echoln "=============================="
    end
    
    # Fall back to vanilla logic
    return aai_choose_best_replacement_pokemon(idxBattler, terrible_moves)
  end
end

# Initialization log moved to EventHandler to ensure AdvancedAI module is fully loaded
EventHandlers.add(:on_game_map_setup, :aai_core_loaded,
  proc {
    if defined?(AdvancedAI) && AdvancedAI.respond_to?(:log)
      AdvancedAI.log("Core AI integration loaded with switch intelligence handler", "Core")
    end
  }
)

echoln "[AAI Core] ✅ Switch Intelligence Handler registered!"
echoln "[AAI Core] ✅ Replacement selector override active!"
echoln "[AAI Core] Ready for battles with skill-based switch logic"


### FILE: Debug_Menu.rb ###
#===============================================================================
# Advanced AI System - Debug Menu & Move Explanations
# Press F9 during battle to access debug controls
#===============================================================================

module AdvancedAI
  # ============================================================================
  # IN-GAME DEBUG MENU
  # ============================================================================
  
  class DebugMenu
    def self.open(battle)
      return unless $DEBUG || Input.press?(Input::F9)
      
      loop do
        commands = [
          _INTL("Change AI Skill Level (Current: {1})", get_current_skill(battle)),
          _INTL("Toggle Wild Pokemon AI ({1})", AdvancedAI::ENABLE_WILD_POKEMON_AI ? "ON" : "OFF"),
          _INTL("Toggle Move Explanations ({1})", AdvancedAI::SHOW_MOVE_EXPLANATIONS ? "ON" : "OFF"),
          _INTL("Toggle Logging ({1})", AdvancedAI::DEBUG_MODE ? "ON" : "OFF"),
          _INTL("Reset Learning System"),
          _INTL("Show AI Stats"),
          _INTL("Force AI Personality"),
          _INTL("Close Menu")
        ]
        
        choice = pbShowCommands(nil, commands, -1)
        
        case choice
        when 0 # Change Skill Level
          change_skill_level(battle)
        when 1 # Toggle Wild AI
          toggle_wild_ai
        when 2 # Toggle Move Explanations
          toggle_move_explanations
        when 3 # Toggle Logging
          toggle_logging
        when 4 # Reset Learning
          reset_learning_system
        when 5 # Show Stats
          show_ai_stats(battle)
        when 6 # Force Personality
          force_personality(battle)
        else
          break
        end
      end
    end
    
    def self.get_current_skill(battle)
      # Get skill of first opponent
      battle.battlers.each do |b|
        next unless b && !b.opposes?
        return battle.pbGetOwnerFromBattlerIndex(b.index).skill_level rescue 50
      end
      return 50
    end
    
    def self.change_skill_level(battle)
      params = ChooseNumberParams.new
      params.setRange(0, 100)
      params.setDefaultValue(get_current_skill(battle))
      new_skill = pbMessageChooseNumber(_INTL("Set AI skill level (0-100):"), params)
      
      # Apply to all opponent battlers
      battle.battlers.each do |b|
        next unless b && !b.opposes?
        owner = battle.pbGetOwnerFromBattlerIndex(b.index) rescue nil
        owner.skill_level = new_skill if owner
      end
      
      pbMessage(_INTL("AI skill set to {1}!", new_skill))
      AdvancedAI.log("Skill level changed to #{new_skill} via debug menu", "Debug")
    end
    
    def self.toggle_wild_ai
      current = AdvancedAI::ENABLE_WILD_POKEMON_AI
      AdvancedAI.const_set(:ENABLE_WILD_POKEMON_AI, !current)
      pbMessage(_INTL("Wild Pokemon AI: {1}", !current ? "ON" : "OFF"))
    end
    
    def self.toggle_move_explanations
      current = AdvancedAI::SHOW_MOVE_EXPLANATIONS
      AdvancedAI.const_set(:SHOW_MOVE_EXPLANATIONS, !current)
      pbMessage(_INTL("Move Explanations: {1}", !current ? "ON" : "OFF"))
    end
    
    def self.toggle_logging
      current = AdvancedAI::DEBUG_MODE
      AdvancedAI.const_set(:DEBUG_MODE, !current)
      pbMessage(_INTL("Debug Logging: {1}", !current ? "ON" : "OFF"))
    end
    
    def self.reset_learning_system
      if defined?(Battle::AI::LearningSystem)
        Battle::AI::LearningSystem.reset_all_patterns
        pbMessage(_INTL("Learning system reset! All patterns cleared."))
        AdvancedAI.log("Learning system reset via debug menu", "Debug")
      else
        pbMessage(_INTL("Learning system not loaded."))
      end
    end
    
    def self.show_ai_stats(battle)
      stats = []
      stats << "=== AI PERFORMANCE STATS ==="
      
      # Get learning system stats if available
      if defined?(Battle::AI::LearningSystem) && battle.ai
        learning = Battle::AI::LearningSystem
        stats << "Battles Analyzed: #{learning.total_battles || 0}"
        stats << "Patterns Learned: #{learning.pattern_count || 0}"
        stats << "Prediction Accuracy: #{learning.prediction_accuracy || 0}%"
      end
      
      # Get switch intelligence stats
      if battle.respond_to?(:ai_switch_count)
        stats << "Switches Made: #{battle.ai_switch_count || 0}"
        stats << "Successful Switches: #{battle.ai_switch_success || 0}"
      end
      
      # Memory stats
      if battle.respond_to?(:move_history)
        stats << "Moves Tracked: #{battle.move_history.length}"
      end
      
      stats << "Current Skill: #{get_current_skill(battle)}"
      stats << "=========================="
      
      pbMessage(stats.join("\n"))
    end
    
    def self.force_personality(battle)
      personalities = ["Aggressive", "Defensive", "Balanced", "Tactical", "Random"]
      choice = pbMessage(_INTL("Choose AI personality:"), personalities, -1)
      return if choice < 0
      
      personality = personalities[choice].downcase.to_sym
      
      battle.battlers.each do |b|
        next unless b && !b.opposes?
        b.battle_personality = personality if b.respond_to?(:battle_personality=)
      end
      
      pbMessage(_INTL("{1} personality activated!", personalities[choice]))
    end
  end
  
  # ============================================================================
  # MOVE EXPLANATION SYSTEM
  # ============================================================================
  
  class MoveExplanation
    # Store explanations for moves chosen this turn
    @current_explanations = {}
    
    def self.set_explanation(battler, move, reason)
      return unless AdvancedAI::SHOW_MOVE_EXPLANATIONS
      @current_explanations ||= {}
      @current_explanations[battler.index] = {
        move: move.name,
        reason: reason
      }
    end
    
    def self.get_explanation(battler)
      @current_explanations ||= {}
      return @current_explanations[battler.index]
    end
    
    def self.clear_explanation(battler)
      @current_explanations ||= {}
      @current_explanations.delete(battler.index)
    end
    
    def self.clear_all
      @current_explanations = {}
    end
    
    # Generate human-readable reason from score components
    def self.generate_reason(move, user, target, score, battle)
      reasons = []
      
      # Type effectiveness
      if move.damagingMove?
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        if Effectiveness.super_effective?(type_mod)
          reasons << "Super effective"
        elsif Effectiveness.not_very_effective?(type_mod)
          reasons << "Coverage"
        end
      end
      
      # Status moves
      if move.statusMove?
        case move.function_code
        when "RaiseUserAtk1", "RaiseUserSpAtk1"
          reasons << "Setup sweep"
        when "ParalyzeTarget"
          reasons << "Paralyze fast threat"
        when "BurnTarget"
          reasons << "Burn physical attacker"
        when "PoisonTarget", "BadPoisonTarget"
          reasons << "Toxic stall"
        when "SleepTarget"
          reasons << "Remove threat"
        end
      end
      
      # Healing
      if move.healingMove?
        hp_percent = user.hp.to_f / user.totalhp
        if hp_percent < 0.3
          reasons << "Emergency recovery"
        else
          reasons << "Sustain bulk"
        end
      end
      
      # Priority
      if move.priority > 0
        if target.hp < target.totalhp * 0.3
          reasons << "Revenge kill"
        else
          reasons << "Priority strike"
        end
      end
      
      # Switch moves
      if ["BatonPass", "VoltSwitch", "UTurn", "FlipTurn"].include?(move.function_code)
        reasons << "Gain momentum"
      end
      
      # High damage
      if score >= 120
        reasons << "KO threat"
      elsif score >= 100
        reasons << "High damage"
      end
      
      # Default
      reasons << "Best option" if reasons.empty?
      
      return reasons.join(" + ")
    end
  end
end

# ============================================================================
# HOOK INTO BATTLE SYSTEM
# ============================================================================

class Battle
  # Add debug menu shortcut
  alias aai_debug_pbCommandPhase pbCommandPhase
  def pbCommandPhase
    # Check for F9 press before processing commands
    if Input.trigger?(Input::F9) && ($DEBUG || AdvancedAI::DEBUG_MODE)
      AdvancedAI::DebugMenu.open(self)
    end
    aai_debug_pbCommandPhase
  end
end

# Hook into Battler class for move explanations
class Battle::Battler
  # Hook move usage to show explanation
  alias aai_explain_pbUseMove pbUseMove
  def pbUseMove(choice, specialUsage = false)
    # Show explanation for AI-controlled battlers
    if !pbOwnedByPlayer? && AdvancedAI::SHOW_MOVE_EXPLANATIONS
      explanation = AdvancedAI::MoveExplanation.get_explanation(self)
      if explanation
        @battle.pbDisplayPaused(_INTL("{1} ({2})", explanation[:move], explanation[:reason]))
        AdvancedAI::MoveExplanation.clear_explanation(self)
      end
    end
    
    aai_explain_pbUseMove(choice, specialUsage)
  end
end

# Initialization complete
echoln "[AAI Debug] Debug Menu & Move Explanations loaded ✅"
echoln "[AAI Debug] Note: AI explanation integration will be loaded after Move_Scorer"


### FILE: Utilities.rb ###
#===============================================================================
# Advanced AI System - Centralized Utilities
# Common helper methods used across all AI modules to avoid duplication
#===============================================================================

module AdvancedAI
  module Utilities
    #===========================================================================
    # Type Effectiveness (Centralized)
    #===========================================================================
    
    # Get type effectiveness for a move or type against a target
    # Handles both Battler objects (.types) and Pokemon objects (.type1/.type2)
    def self.type_mod(attack_type, defender)
      return Effectiveness::NORMAL_EFFECTIVE unless defender
      
      type = attack_type.is_a?(Symbol) ? attack_type : attack_type.type
      
      # Handle both Battler (pbTypes method) and Pokemon (type1/type2)
      if defender.respond_to?(:pbTypes)
        types = defender.pbTypes(true)
        t1, t2 = types[0], types[1]
      elsif defender.respond_to?(:types)
        # Fallback for older API (deprecated)
        t1, t2 = defender.types[0], defender.types[1]
      else
        t1, t2 = defender.type1, defender.type2
      end
      
      Effectiveness.calculate(type, t1, t2)
    end
    
    def self.super_effective?(attack_type, defender)
      Effectiveness.super_effective?(type_mod(attack_type, defender))
    end
    
    def self.not_very_effective?(attack_type, defender)
      Effectiveness.not_very_effective?(type_mod(attack_type, defender))
    end
    
    def self.ineffective?(attack_type, defender)
      Effectiveness.ineffective?(type_mod(attack_type, defender))
    end
    
    #===========================================================================
    # Mold Breaker / Ability Ignoring (CRITICAL)
    #===========================================================================
    
    ABILITY_IGNORING = [:MOLDBREAKER, :TURBOBLAZE, :TERAVOLT, :MYCELIUMMIGHT]
    
    # Check if user ignores target's ability
    def self.ignores_ability?(user)
      return false unless user
      
      # Check method if available (Essentials built-in)
      return true if user.respond_to?(:hasMoldBreaker?) && user.hasMoldBreaker?
      
      # Manual check
      ABILITY_IGNORING.include?(user.ability_id)
    end
    
    # Check ability only if not ignored
    def self.target_has_ability?(user, target, *abilities)
      return false unless target
      return false if ignores_ability?(user)
      
      abilities.flatten.include?(target.ability_id)
    end
    
    #===========================================================================
    # Type-Absorbing Ability Immunities (CRITICAL FOR MOVE SCORING)
    #===========================================================================
    
    # Abilities that make a Pokemon IMMUNE to a type (and often boost a stat)
    TYPE_ABSORBING_ABILITIES = {
      # Type => [[abilities that absorb it], effect]
      WATER: [
        [:WATERABSORB, :heal],      # Heals 25% HP
        [:DRYSKIN, :heal],          # Heals 25% HP (also takes 25% extra Fire damage)
        [:STORMDRAIN, :boost_spa],  # +1 SpA
      ],
      ELECTRIC: [
        [:VOLTABSORB, :heal],       # Heals 25% HP
        [:LIGHTNINGROD, :boost_spa], # +1 SpA
        [:MOTORDRIVE, :boost_speed], # +1 Speed
      ],
      FIRE: [
        [:FLASHFIRE, :boost_fire],  # Boosts Fire moves 1.5x
        [:WELLBAKEDBODY, :boost_def], # +2 Defense (Gen 9)
      ],
      GRASS: [
        [:SAPSIPPER, :boost_atk],   # +1 Attack
      ],
      GROUND: [
        [:EARTHEATER, :heal],       # Heals 25% HP (Gen 9)
        [:LEVITATE, :immune],       # Complete immunity
      ],
    }
    
    # Check if target is immune to a move's type due to ability
    # Returns: nil if not immune, or a hash with { ability: X, effect: Y }
    def self.type_absorbing_immunity?(user, target, move_type)
      return nil unless target
      return nil if ignores_ability?(user)
      
      type_sym = move_type.to_sym rescue move_type
      absorbers = TYPE_ABSORBING_ABILITIES[type_sym]
      return nil unless absorbers
      
      absorbers.each do |ability, effect|
        ability = [ability] unless ability.is_a?(Array)
        ability.each do |ab|
          if target.ability_id == ab
            return { ability: ab, effect: effect }
          end
        end
      end
      
      nil
    end
    
    # Score penalty for attacking into a type-absorbing ability
    # Returns a NEGATIVE score (penalty) if bad, 0 if fine
    def self.score_type_absorption_penalty(user, target, move)
      return 0 unless move && move.damagingMove?
      
      move_type = move.type
      immunity = type_absorbing_immunity?(user, target, move_type)
      return 0 unless immunity
      
      # This move will be ABSORBED - heavy penalty!
      case immunity[:effect]
      when :heal
        return -150  # They heal, we waste turn
      when :boost_atk, :boost_spa, :boost_speed, :boost_def
        return -180  # They get STRONGER, terrible
      when :boost_fire
        return -160  # Flash Fire boost
      when :immune
        return -200  # Complete immunity (Levitate)
      else
        return -150  # Default heavy penalty
      end
    end
    
    # Additional single-ability type immunities (not stat-boosting)
    ADDITIONAL_TYPE_IMMUNITIES = {
      FIRE: [:FLASHFIRE, :WELLBAKEDBODY, :HEATPROOF],  # Heatproof is 50% not immunity but notable
      ELECTRIC: [:VOLTABSORB, :LIGHTNINGROD, :MOTORDRIVE],
      WATER: [:WATERABSORB, :DRYSKIN, :STORMDRAIN],
      GRASS: [:SAPSIPPER],
      GROUND: [:LEVITATE, :EARTHEATER],
      PSYCHIC: [],  # No full immunities
      DARK: [],
      GHOST: [],
      DRAGON: [],
      POISON: [:IMMUNITY],  # Immunity prevents poison status, not Poison moves
      FIGHTING: [],
      ROCK: [],
      STEEL: [],
      BUG: [],
      FLYING: [],
      ICE: [],
      FAIRY: [],
      NORMAL: [],
    }
    
    # Bulletproof immunity (ball/bomb moves)
    BALL_BOMB_MOVES = [
      :ACIDSPRAY, :AURASPHERE, :BARRAGE, :BEAKBLAST, :BULLETSEED,
      :EGGBOMB, :ELECTROBALL, :ENERGYBALL, :FOCUSBLAST, :GYROBALL,
      :ICEBALL, :MAGNETBOMB, :MISTBALL, :MUDBOMB, :OCTAZOOKA,
      :POLLENPUFF, :PYROBALL, :ROCKWRECKER, :SEEDBOMB, :SHADOWBALL,
      :SLUDGEBOMB, :WEATHERBALL, :ZAPCANNON
    ]
    
    def self.bulletproof_immune?(user, target, move)
      return false unless target
      return false if ignores_ability?(user)
      return false unless target.ability_id == :BULLETPROOF
      
      BALL_BOMB_MOVES.include?(move.id)
    end
    
    # Soundproof immunity
    SOUND_MOVES = [
      :BOOMBURST, :BUGBUZZ, :CHATTER, :CLANGOROUSSOUL, :CLANGINGSCALES,
      :CONFIDE, :DISARMINGVOICE, :ECHOEDVOICE, :EERIESPELL, :GRASSWHISTLE,
      :GROWL, :HEALBELL, :HYPERVOICE, :METALSOUND, :NOBLEROAR, :OVERDRIVE,
      :PARTINGSHOT, :PERISHSONG, :RELICSONG, :ROAR, :ROUND, :SCREAM,
      :SCREECH, :SHADOWPANIC, :SING, :SNARL, :SNORE, :SPARKLINGARIA,
      :SUPERSONIC, :TORCHSONG, :UPROAR
    ]
    
    def self.soundproof_immune?(user, target, move)
      return false unless target
      return false if ignores_ability?(user)
      return false unless target.ability_id == :SOUNDPROOF
      
      move.soundMove? rescue SOUND_MOVES.include?(move.id)
    end

    #===========================================================================
    # Grounded Check (Centralized)
    #===========================================================================
    
    # Full grounded check with all conditions
    # Handles both Battler and Pokemon objects
    def self.grounded?(battler, battle = nil)
      return true unless battler
      
      # Flying type - handle both Battler (pbHasType?) and Pokemon (hasType?)
      has_flying = battler.respond_to?(:pbHasType?) ? battler.pbHasType?(:FLYING) : battler.hasType?(:FLYING)
      return false if has_flying
      
      # Levitate (can be ignored by Mold Breaker in battle context)
      ability = battler.respond_to?(:ability_id) ? battler.ability_id : battler.ability_id
      return false if ability == :LEVITATE
      
      # Air Balloon
      item = battler.respond_to?(:item_id) ? battler.item_id : battler.item_id
      return false if item == :AIRBALLOON
      
      # Effects (need battler in battle)
      if battler.respond_to?(:effects)
        # Magnet Rise
        if battler.effects[PBEffects::MagnetRise] && battler.effects[PBEffects::MagnetRise] > 0
          return false
        end
        
        # Telekinesis
        if battler.effects[PBEffects::Telekinesis] && battler.effects[PBEffects::Telekinesis] > 0
          return false
        end
      end
      
      # Gravity grounds everything
      if battle && battle.field.effects[PBEffects::Gravity] && battle.field.effects[PBEffects::Gravity] > 0
        return true
      end
      
      # Iron Ball grounds
      return true if battler.item_id == :IRONBALL
      
      # Ingrain grounds
      if battler.respond_to?(:effects) && battler.effects[PBEffects::Ingrain]
        return true
      end
      
      true
    end
    
    #===========================================================================
    # Contact Move Punishment
    #===========================================================================
    
    CONTACT_PUNISH_ABILITIES = {
      ROUGHSKIN: { damage: 8, type: :fixed },      # 1/8 max HP
      IRONBARBS: { damage: 8, type: :fixed },
      FLAMEBODY: { damage: 0, type: :status, status: :BURN, chance: 30 },
      STATIC: { damage: 0, type: :status, status: :PARALYSIS, chance: 30 },
      POISONPOINT: { damage: 0, type: :status, status: :POISON, chance: 30 },
      EFFECTSPORE: { damage: 0, type: :status, chance: 30 },
      CUTECHARM: { damage: 0, type: :status, chance: 30 },
      GOOEY: { damage: 0, type: :stat, stat: :SPEED, stages: -1 },
      TANGLINGHAIR: { damage: 0, type: :stat, stat: :SPEED, stages: -1 },
      PERISHBODY: { damage: 0, type: :special },
      WANDERINGSPIRIT: { damage: 0, type: :special },
      MUMMY: { damage: 0, type: :special },
      LINGERINGAROMA: { damage: 0, type: :special }
    }
    
    # Calculate contact move punishment
    def self.contact_punishment(attacker, defender, move)
      return 0 unless move && move.contactMove?
      return 0 unless defender
      
      score_penalty = 0
      
      # Ability punishment (check Mold Breaker)
      unless ignores_ability?(attacker)
        ability_data = CONTACT_PUNISH_ABILITIES[defender.ability_id]
        if ability_data
          case ability_data[:type]
          when :fixed
            damage = attacker.totalhp / ability_data[:damage]
            score_penalty += (damage * 100 / [attacker.hp, 1].max) / 3
          when :status
            if attacker.status == :NONE
              score_penalty += 15 * (ability_data[:chance] / 100.0)
            end
          when :stat
            score_penalty += 10
          when :special
            score_penalty += 20
          end
        end
      end
      
      # Rocky Helmet
      if defender.item_id == :ROCKYHELMET
        damage = attacker.totalhp / 6
        score_penalty += (damage * 100 / [attacker.hp, 1].max) / 3
      end
      
      # Long Reach ability ignores contact
      if attacker.ability_id == :LONGREACH
        return 0
      end
      
      # Protective Pads ignores contact effects
      if attacker.item_id == :PROTECTIVEPADS
        return 0
      end
      
      score_penalty.to_i
    end
    
    #===========================================================================
    # Protect Stale Check
    #===========================================================================
    
    # Check if Protect is likely to fail
    def self.protect_likely_to_fail?(battler)
      return false unless battler
      return false unless battler.respond_to?(:effects)
      
      protect_rate = battler.effects[PBEffects::ProtectRate] || 1
      
      # At rate 4+, only 1/4096 chance of success
      protect_rate >= 4
    end
    
    # Get Protect success rate
    def self.protect_success_chance(battler)
      return 100 unless battler && battler.respond_to?(:effects)
      
      rate = battler.effects[PBEffects::ProtectRate] || 1
      (100.0 / rate).round
    end
    
    #===========================================================================
    # Multi-Hit Move Handling
    #===========================================================================
    
    # Calculate expected hits for multi-hit move
    def self.expected_multi_hits(attacker, move)
      return 1 unless move
      return 1 unless move.multiHitMove?
      
      # Fixed hit moves
      fixed_hits = {
        TRIPLEKICK: 3, TRIPLAXEL: 3, SURGINGSTRIKES: 3,
        DOUBLEHIT: 2, BONEMERANG: 2, DOUBLEIRONBASH: 2,
        DRAGONDARTSFIX: 2, TWINBEAM: 2
      }
      
      return fixed_hits[move.id] if fixed_hits[move.id]
      
      # Population Bomb
      if move.id == :POPULATIONBOMB
        return attacker.item_id == :LOADEDDICE ? 7 : 5
      end
      
      # Skill Link = always 5
      if attacker.ability_id == :SKILLLINK
        return 5
      end
      
      # Loaded Dice = 4-5 (average 4.5)
      if attacker.item_id == :LOADEDDICE
        return 4.5
      end
      
      # Default: 2-5 hits, average ~3.17
      3.17
    end
    
    # Check if multi-hit breaks Focus Sash / Sturdy
    def self.multi_hit_breaks_endure?(attacker, move, target)
      return false unless move && move.multiHitMove?
      return false unless target
      
      # Focus Sash
      return true if target.item_id == :FOCUSSASH && target.hp == target.totalhp
      
      # Sturdy
      return true if target.ability_id == :STURDY && target.hp == target.totalhp && !ignores_ability?(attacker)
      
      # Disguise / Ice Face (form abilities)
      return true if [:DISGUISE, :ICEFACE].include?(target.ability_id) && !ignores_ability?(attacker)
      
      false
    end
    
    #===========================================================================
    # Status Immunities (Comprehensive)
    #===========================================================================
    
    # Check if target is immune to a status condition
    # Handles both Battler and Pokemon objects
    def self.status_immune?(attacker, target, status, battle = nil)
      return true unless target
      return true if target.status != :NONE && status != :NONE  # Already has status
      
      # Helper for type checking
      has_type = lambda { |t| target.respond_to?(:pbHasType?) ? target.pbHasType?(t) : target.hasType?(t) }
      
      case status
      when :SLEEP
        # Type immunity
        return true if has_type.call(:GRASS) && [:SPORE, :SLEEPPOWDER, :STUNSPORE].include?(attacker&.lastMoveUsed)
        
        # Ability immunity (check Mold Breaker)
        unless ignores_ability?(attacker)
          return true if [:VITALSPIRIT, :INSOMNIA, :COMATOSE].include?(target.ability_id)
          
          # Sweet Veil (ally immunity) - would need battle context
          if battle
            allies = battle.allSameSideBattlers(target.index)
            return true if allies.any? { |a| a && a.ability_id == :SWEETVEIL }
          end
          
          # Leaf Guard in sun
          if target.ability_id == :LEAFGUARD && battle && [:Sun, :HarshSun].include?(battle.field.weather)
            return true
          end
        end
        
        # Terrain immunity
        if battle
          return true if battle.field.terrain == :Electric && grounded?(target, battle)
          return true if battle.field.terrain == :Misty && grounded?(target, battle)
        end
        
        # Item immunity
        return true if target.item_id == :SAFETYGOGGLES  # Powder moves
        
      when :POISON, :TOXIC
        return true if has_type.call(:POISON)
        return true if has_type.call(:STEEL)
        
        unless ignores_ability?(attacker)
          return true if target.ability_id == :IMMUNITY
          return true if target.ability_id == :PASTELVEIL
          return true if target.ability_id == :PURIFYINGSALT
        end
        
      when :BURN
        return true if has_type.call(:FIRE)
        
        unless ignores_ability?(attacker)
          return true if target.ability_id == :WATERVEIL
          return true if target.ability_id == :WATERBUBBLE
          return true if target.ability_id == :THERMALEXCHANGE
          return true if target.ability_id == :PURIFYINGSALT
        end
        
      when :PARALYSIS
        return true if has_type.call(:ELECTRIC)
        
        unless ignores_ability?(attacker)
          return true if target.ability_id == :LIMBER
          return true if target.ability_id == :PURIFYINGSALT
        end
        
      when :FREEZE
        return true if has_type.call(:ICE)
        
        unless ignores_ability?(attacker)
          return true if target.ability_id == :MAGMAARMOR
          return true if target.ability_id == :PURIFYINGSALT
        end
        
        # Sun prevents freeze
        if battle && [:Sun, :HarshSun].include?(battle.field.weather)
          return true
        end
      end
      
      # Good as Gold (immune to status moves)
      unless ignores_ability?(attacker)
        return true if target.ability_id == :GOODASGOLD
      end
      
      false
    end
    
    #===========================================================================
    # Weather Nullification
    #===========================================================================
    
    WEATHER_NULLIFIERS = [:AIRLOCK, :CLOUDNINE]
    
    def self.weather_active?(battle)
      return false unless battle
      return false if battle.field.weather == :None
      
      # Check for Air Lock / Cloud Nine
      battle.allBattlers.each do |b|
        next unless b && !b.fainted?
        return false if WEATHER_NULLIFIERS.include?(b.ability_id)
      end
      
      true
    end
    
    def self.current_weather(battle)
      return :None unless weather_active?(battle)
      battle.field.weather
    end
    
    #===========================================================================
    # Primordial Weather (Harsh Sun, Heavy Rain, Strong Winds)
    #===========================================================================
    
    def self.move_blocked_by_weather?(battle, move)
      return false unless battle && move && move.damagingMove?
      
      weather = current_weather(battle)
      
      case weather
      when :HarshSun
        return true if move.type == :WATER  # Water moves fail
      when :HeavyRain
        return true if move.type == :FIRE   # Fire moves fail
      end
      
      false
    end
    
    #===========================================================================
    # Gen 9 Ability Checks
    #===========================================================================
    
    GEN9_OFFENSIVE_ABILITIES = {
      SUPREMEOVERLORD: { boost: true, condition: :fainted_allies },
      ORICHALCUMPULSE: { boost: true, sets: :Sun },
      HADRONENGINE: { boost: true, sets: :Electric },  # Terrain
      TOXICCHAIN: { poison_chance: 30 },
      SHARPNESS: { boost: 1.5, condition: :slicing_move },
      ROCKYPAYLOAD: { boost: 1.5, type: :ROCK },
      WINDPOWER: { sets_charge: true, condition: :wind_move_hit }
    }
    
    GEN9_DEFENSIVE_ABILITIES = {
      PURIFYINGSALT: { status_immune: true, ghost_resist: true },
      GOODASGOLD: { status_move_immune: true },
      ARMORTAIL: { priority_block: true },
      WINDRIDER: { wind_immune: true, attack_boost: true },
      GUARDDOG: { intimidate_immune: true, attack_boost: true },
      WELLBAKEDBODY: { fire_immune: true, defense_boost: true },
      EARTHEATER: { ground_immune: true, heal: true },
      HOSPITALITY: { heal_ally_on_entry: true }
    }
    
    def self.has_gen9_offensive_ability?(battler)
      GEN9_OFFENSIVE_ABILITIES.key?(battler.ability_id)
    end
    
    def self.has_gen9_defensive_ability?(battler)
      GEN9_DEFENSIVE_ABILITIES.key?(battler.ability_id)
    end
    
    #===========================================================================
    # Priority Ability Awareness
    #===========================================================================
    
    # Check if Prankster move fails against Dark type
    def self.prankster_blocked?(user, target, move)
      return false unless user && target && move
      return false unless user.ability_id == :PRANKSTER
      return false unless move.statusMove?
      
      # Prankster status moves fail against Dark types
      has_dark = target.respond_to?(:pbHasType?) ? target.pbHasType?(:DARK) : target.hasType?(:DARK)
      has_dark
    end
    
    # Check Gale Wings priority (Flying moves at full HP)
    def self.gale_wings_active?(user)
      return false unless user
      return false unless user.ability_id == :GALEWINGS
      user.hp == user.totalhp
    end
    
    # Check Triage priority (healing moves)
    HEALING_MOVES = [
      :RECOVER, :SOFTBOILED, :ROOST, :SLACKOFF, :MOONLIGHT, :MORNINGSUN,
      :SYNTHESIS, :WISH, :SHOREUP, :LIFEDEW, :JUNGLEHEALING, :LUNARBLESSING,
      :LEECHLIFE, :DRAININGKISS, :DRAINPUNCH, :GIGADRAIN, :HORNLEECH,
      :LEECHSEED, :PARABOLICCHARGE, :OBLIVIONWING, :STRENGTHSAP,
      :ABSORB, :MEGADRAIN, :POLLENPUFF
    ]
    
    def self.triage_active?(user, move)
      return false unless user && move
      return false unless user.ability_id == :TRIAGE
      HEALING_MOVES.include?(move.id)
    end
    
    # Get effective priority including ability modifiers
    def self.effective_priority(user, move, battle = nil)
      return 0 unless move
      
      base_priority = move.priority rescue 0
      
      # Prankster
      if user.ability_id == :PRANKSTER && move.statusMove?
        base_priority += 1
      end
      
      # Gale Wings (full HP, Flying move)
      if gale_wings_active?(user) && move.type == :FLYING
        base_priority += 1
      end
      
      # Triage (+3 for healing moves)
      if triage_active?(user, move)
        base_priority += 3
      end
      
      # Grassy Glide in Grassy Terrain
      if move.id == :GRASSYGLIDE && battle && battle.field.terrain == :Grassy
        base_priority = 1
      end
      
      base_priority
    end
    
    #===========================================================================
    # Gen 9 Special Move Handling
    #===========================================================================
    
    # Rage Fist - power increases with hits taken
    def self.rage_fist_power(user)
      base_power = 50
      hits_taken = user.effects[PBEffects::RageFist] rescue 0
      # +50 power per hit, max 350
      [base_power + (hits_taken * 50), 350].min
    end
    
    # Last Respects - power increases per fainted ally
    def self.last_respects_power(battle, user)
      base_power = 50
      return base_power unless battle
      
      fainted_count = 0
      party = battle.pbParty(user.index)
      party.each do |p|
        next unless p
        fainted_count += 1 if p.fainted?
      end
      
      # +50 power per fainted ally
      base_power + (fainted_count * 50)
    end
    
    # Glaive Rush - makes user take double damage next turn
    def self.used_glaive_rush?(user)
      return false unless user
      user.lastMoveUsed == :GLAIVERUSH
    end
    
    # Collision Course / Electro Drift - boosted SE damage
    COLLISION_MOVES = [:COLLISIONCOURSE, :ELECTRODRIFT]
    
    def self.collision_move_boost?(move)
      COLLISION_MOVES.include?(move.id)
    end
    
    #===========================================================================
    # Gen 9 Item Tracking
    #===========================================================================
    
    # Eject Pack - forces switch when stats are lowered
    def self.eject_pack_active?(battler)
      return false unless battler
      battler.item_id == :EJECTPACK && battler.statsLoweredThisRound
    end
    
    # Throat Spray - +1 SpA after using sound move
    def self.throat_spray_active?(user, move)
      return false unless user && move
      user.item_id == :THROATSPRAY && (move.soundMove? rescue false)
    end
    
    # Blunder Policy - +2 Speed if move misses
    def self.blunder_policy_bonus(user)
      return 0 unless user
      return 0 unless user.item_id == :BLUNDERPOLICY
      return 0 unless user.lastMoveFailed
      2  # +2 Speed stages
    end
    
    #===========================================================================
    # Contrary / Simple Handling for Setup Scoring
    #===========================================================================
    
    # Get effective stat stages considering Contrary/Simple
    def self.effective_stat_change(user, stages)
      return stages unless user
      
      if user.ability_id == :CONTRARY
        return -stages  # Reversed
      elsif user.ability_id == :SIMPLE
        return stages * 2  # Doubled
      end
      
      stages
    end
    
    # Check if setup move is beneficial considering ability
    def self.setup_beneficial?(user, move_id)
      return true unless user
      
      # Moves that lower stats (Overheat, Draco Meteor, etc.)
      stat_lowering_moves = [:OVERHEAT, :DRACOMETEOR, :LEAFSTORM, :FLEURCANNON,
                             :PSYCHOBOOST, :CLOSECOMBAT, :SUPERPOWER, :HAMMERARM,
                             :VCREATE, :HEADCHARGE, :SHELSMASH]  # Shell Smash has both
      
      if user.ability_id == :CONTRARY
        # Contrary makes stat-lowering moves into boosts!
        return true if stat_lowering_moves.include?(move_id)
        # But regular setup moves become debuffs
        return false if ALL_SETUP_MOVES.include?(move_id)
      end
      
      true
    end
    
    #===========================================================================
    # Centralized Setup Move List
    #===========================================================================
    
    SETUP_MOVES = {
      physical: [:SWORDSDANCE, :DRAGONDANCE, :BELLYDRUM, :BULKUP, :HOWL, :COIL,
                 :VICTORYDANCE, :FILLETAWAY, :HONECLAWS, :CURSE],
      special: [:NASTYPLOT, :CALMMIND, :QUIVERDANCE, :TAILGLOW, :GEOMANCY,
                :TAKEHEART, :TORCHSONG],
      speed: [:AGILITY, :ROCKPOLISH, :AUTOTOMIZE, :SHIFTGEAR, :TAILWIND,
              :DRAGONDANCE],  # DD is both
      mixed: [:SHELLSMASH, :GROWTH, :WORKUP, :ANCIENTPOWER, :OMINOUSWIND,
              :SILVERWIND, :CLANGOROUSSOUL, :NORETREAT],
      defensive: [:IRONDEFENSE, :ACIDARMOR, :BARRIER, :COTTONGUARD,
                  :AMNESIA, :COSMICPOWER, :STOCKPILE, :SHELTER],
      special_types: [:FOCUSENERGY, :CHARGE, :MAGNETRISE, :AQUARING]
    }
    
    ALL_SETUP_MOVES = SETUP_MOVES.values.flatten.uniq
    
    def self.is_setup_move?(move)
      return false unless move
      ALL_SETUP_MOVES.include?(move.id)
    end
    
    def self.get_setup_type(move)
      return nil unless move
      
      SETUP_MOVES.each do |type, moves|
        return type if moves.include?(move.id)
      end
      
      nil
    end
  end
end

# Shorthand access
module AdvancedAI
  def self.type_mod(attack_type, defender)
    Utilities.type_mod(attack_type, defender)
  end
  
  def self.ignores_ability?(user)
    Utilities.ignores_ability?(user)
  end
  
  def self.target_has_ability?(user, target, *abilities)
    Utilities.target_has_ability?(user, target, *abilities)
  end
  
  def self.grounded?(battler, battle = nil)
    Utilities.grounded?(battler, battle)
  end
  
  def self.contact_punishment(attacker, defender, move)
    Utilities.contact_punishment(attacker, defender, move)
  end
  
  def self.protect_likely_to_fail?(battler)
    Utilities.protect_likely_to_fail?(battler)
  end
  
  def self.expected_multi_hits(attacker, move)
    Utilities.expected_multi_hits(attacker, move)
  end
  
  def self.multi_hit_breaks_endure?(attacker, move, target)
    Utilities.multi_hit_breaks_endure?(attacker, move, target)
  end
  
  def self.status_immune?(attacker, target, status, battle = nil)
    Utilities.status_immune?(attacker, target, status, battle)
  end
  
  def self.weather_active?(battle)
    Utilities.weather_active?(battle)
  end
  
  def self.move_blocked_by_weather?(battle, move)
    Utilities.move_blocked_by_weather?(battle, move)
  end
  
  def self.is_setup_move?(move)
    Utilities.is_setup_move?(move)
  end
  
  def self.type_absorbing_immunity?(user, target, move_type)
    Utilities.type_absorbing_immunity?(user, target, move_type)
  end
  
  def self.score_type_absorption_penalty(user, target, move)
    Utilities.score_type_absorption_penalty(user, target, move)
  end
  
  def self.bulletproof_immune?(user, target, move)
    Utilities.bulletproof_immune?(user, target, move)
  end
  
  def self.soundproof_immune?(user, target, move)
    Utilities.soundproof_immune?(user, target, move)
  end
  
  #===========================================================================
  # VGC Item Awareness
  #===========================================================================
  module Utilities
    # Type-resist berries that reduce SE damage
    TYPE_RESIST_BERRIES = {
      :OCCABERRY => :FIRE,      :PASSHOBERRY => :WATER,   :WACANBERRY => :ELECTRIC,
      :RINDOBERRY => :GRASS,    :YABORBERRY => :ICE,      :CHOPLEBERRY => :FIGHTING,
      :KEBIABERRY => :POISON,   :SHUCABERRY => :GROUND,   :COBABERRY => :FLYING,
      :PAYAPABERRY => :PSYCHIC, :TANGABERRY => :BUG,      :CHARTIBERRY => :ROCK,
      :KASIBBERRY => :GHOST,    :HABANBERRY => :DRAGON,   :COLBURBERRY => :DARK,
      :BABIRIBERRY => :STEEL,   :ROSELIBERRY => :FAIRY,   :CHILANBERRY => :NORMAL
    }
    
    # Check if target has a resist berry for move type
    def self.has_resist_berry?(target, move_type)
      return false unless target && target.item_id
      TYPE_RESIST_BERRIES[target.item_id] == move_type
    end
    
    # Get damage reduction from resist berry (0.5x when SE)
    def self.resist_berry_mod(target, move_type, type_effectiveness)
      return 1.0 unless Effectiveness.super_effective?(type_effectiveness)
      return 1.0 unless has_resist_berry?(target, move_type)
      0.5  # Halves SE damage
    end
    
    # Clear Amulet - immune to stat drops
    def self.has_clear_amulet?(battler)
      battler && battler.item_id == :CLEARAMULET
    end
    
    # Covert Cloak - immune to secondary effects
    def self.has_covert_cloak?(battler)
      battler && battler.item_id == :COVERTCLOAK
    end
    
    # Utility Umbrella - ignore weather effects
    def self.has_utility_umbrella?(battler)
      battler && battler.item_id == :UTILITYUMBRELLA
    end
    
    # Power Herb - skip charge turn
    def self.has_power_herb?(battler)
      battler && battler.item_id == :POWERHERB
    end
    
    # White Herb - restore lowered stats
    def self.has_white_herb?(battler)
      battler && battler.item_id == :WHITEHERB
    end
    
    #=========================================================================
    # Form Change Awareness
    #=========================================================================
    
    # Aegislash - Shield form (defensive) vs Blade form (offensive)
    def self.aegislash_in_shield_form?(battler)
      return false unless battler
      battler.isSpecies?(:AEGISLASH) && battler.form == 0
    end
    
    def self.aegislash_in_blade_form?(battler)
      return false unless battler
      battler.isSpecies?(:AEGISLASH) && battler.form == 1
    end
    
    # Darmanitan Zen Mode - below 50% HP changes form
    def self.darmanitan_can_zen?(battler)
      return false unless battler
      return false unless battler.isSpecies?(:DARMANITAN)
      battler.ability_id == :ZENMODE && battler.hp <= battler.totalhp / 2
    end
    
    # Palafin - Hero form after switching
    def self.palafin_hero_form?(battler)
      return false unless battler
      battler.isSpecies?(:PALAFIN) && battler.form == 1
    end
    
    # Wishiwashi - Schooling at 25%+ HP and level 20+
    def self.wishiwashi_schooling?(battler)
      return false unless battler
      return false unless battler.isSpecies?(:WISHIWASHI)
      battler.hp > battler.totalhp / 4 && battler.level >= 20
    end
    
    # Minior - Shields Down below 50% HP
    def self.minior_shields_down?(battler)
      return false unless battler
      return false unless battler.isSpecies?(:MINIOR)
      battler.hp <= battler.totalhp / 2
    end
    
    # Zygarde - Power Construct transforms at low HP
    def self.zygarde_can_transform?(battler)
      return false unless battler
      return false unless battler.isSpecies?(:ZYGARDE)
      battler.ability_id == :POWERCONSTRUCT && battler.hp <= battler.totalhp / 2
    end
  end
end

AdvancedAI.log("Centralized Utilities Module loaded", "Utils")
AdvancedAI.log("  - Type effectiveness helpers", "Utils")
AdvancedAI.log("  - Mold Breaker / ability ignoring", "Utils")
AdvancedAI.log("  - Grounded check (comprehensive)", "Utils")
AdvancedAI.log("  - Contact punishment calculation", "Utils")
AdvancedAI.log("  - Protect stale detection", "Utils")
AdvancedAI.log("  - Multi-hit move handling", "Utils")
AdvancedAI.log("  - Status immunity checks", "Utils")
AdvancedAI.log("  - Weather nullification (Air Lock/Cloud Nine)", "Utils")
AdvancedAI.log("  - Primordial weather move blocking", "Utils")
AdvancedAI.log("  - Gen 9 ability awareness", "Utils")
AdvancedAI.log("  - Centralized setup move list", "Utils")
AdvancedAI.log("  - Type-absorbing ability immunities", "Utils")
AdvancedAI.log("  - Bulletproof / Soundproof immunities", "Utils")

### FILE: 0_Move_Scorer.rb ###
#===============================================================================
# Advanced AI System - Move Scorer
# Intelligent Move Scoring with 20+ Factors
#===============================================================================

#===============================================================================
# Priority Move Result - Explicit Auto-Select Flag
#===============================================================================
class PriorityMoveResult
  attr_reader :auto_select, :priority_boost
  
  def initialize(auto_select: false, priority_boost: 0)
    @auto_select = auto_select
    @priority_boost = priority_boost
  end
  
  # Check if this move should auto-select
  def auto_select?
    @auto_select
  end
  
  # Get the priority boost value (0 if auto-selecting)
  def boost_value
    @auto_select ? 0 : @priority_boost
  end
end

class Battle::AI
  #-----------------------------------------------------------------------------
  # Base method for AI move registration - provides hook point for all AI extensions
  # This is the foundation method that other AI files will alias to add their logic
  #-----------------------------------------------------------------------------
  def pbRegisterMove(user, move)
    return 0 unless move && user
    # Base scoring - delegates to the comprehensive move scorer
    # Choose first valid opponent as target (will be refined by score_move_advanced)
    target = @battle.allOtherSideBattlers(user.index).find { |b| b && !b.fainted? }
    return 0 unless target
    score_move_advanced(move, user, target, @battle.pbGetOwnerFromBattlerIndex(user.index))
  end

  # Enhanced Move Scoring Logic
  def score_move_advanced(move, user, target, skill)
    return 0 unless move && user
    
    # Side/field-targeting moves (Stealth Rock, Spikes, Reflect, Light Screen, etc.)
    # are called without a target. Pick a fallback opponent for scoring context.
    if target.nil?
      target = @battle.allOtherSideBattlers(user.index).find { |b| b && !b.fainted? }
      return 0 unless target
    end
    
    # === CRITICAL: PP CHECK ===
    # Don't try to use a move with 0 PP (unless it's Struggle, which is handled elsewhere)
    if move.pp == 0 && move.total_pp > 0
      return -1000
    end
    
    # === PRIORITY TIER SYSTEM ===
    # Check if this move should be auto-selected based on tactical role
    priority_result = check_priority_tier_moves(move, user, target, skill)
    
    # Auto-select if the priority system flags it
    if priority_result.is_a?(PriorityMoveResult) && priority_result.auto_select?
      # Return a very high score to ensure selection (but keep it reasonable for logging)
      final_score = 500 + priority_result.priority_boost
      AdvancedAI.log("#{move.name} AUTO-SELECTED (Tactical Priority): Score #{final_score}", "Priority")
      return final_score
    end
    
    # Extract priority boost for later addition to base score
    priority_boost = priority_result.is_a?(PriorityMoveResult) ? priority_result.boost_value : 0
    
    # === CRITICAL SELF-AWARENESS CHECKS ===
    # These return -1000 for moves that WILL FAIL due to our own status
    
    # Choice Lock: If we're locked, only the locked move can be used
    if user.effects[PBEffects::ChoiceBand] && user.effects[PBEffects::ChoiceBand] != move.id
      return -1000  # Can't use any other move when Choice-locked
    end
    
    # Encore: Must use the encored move
    if user.effects[PBEffects::Encore] > 0 && user.effects[PBEffects::EncoreMove]
      return -1000 if move.id != user.effects[PBEffects::EncoreMove]
    end
    
    # Disable: Can't use the disabled move
    if user.effects[PBEffects::Disable] > 0 && user.effects[PBEffects::DisableMove]
      return -1000 if move.id == user.effects[PBEffects::DisableMove]
    end
    
    # Taunt: Can't use status moves
    if user.effects[PBEffects::Taunt] > 0 && move.statusMove?
      return -1000
    end
    
    # Heal Block: Can't use healing moves
    if user.effects[PBEffects::HealBlock] > 0
      healing_moves = [:RECOVER, :SOFTBOILED, :ROOST, :SLACKOFF, :MOONLIGHT, :MORNINGSUN, 
                       :SYNTHESIS, :WISH, :SHOREUP, :LIFEDEW, :JUNGLEHEALING, :LUNARBLESSING]
      return -1000 if healing_moves.include?(move.id)
    end
    
    # Imprison: Can't use moves the opponent has imprisoned
    @battle.allOtherSideBattlers(user.index).each do |opp|
      next unless opp && !opp.fainted?
      if opp.effects[PBEffects::Imprison]
        opp.moves.each do |opp_move|
          return -1000 if opp_move && opp_move.id == move.id
        end
      end
    end
    
    # === CRITICAL: FALSE SWIPE IN PVP ===
    # FALSE SWIPE should NEVER be used against trainers/PVP
    if move.id == :FALSESWIPE && !@battle.wildBattle?
      return -999  # Terrible in PVP
    end
    
    # Torment: Can't use the same move twice in a row
    if user.effects[PBEffects::Torment] && user.battler.lastMoveUsed == move.id
      return -1000
    end
    
    # Fake Out / First Impression: Only work on first turn out
    if [:FAKEOUT, :FIRSTIMPRESSION].include?(move.id) && user.turnCount > 0
      return -1000  # These moves fail after turn 1
    end
    
    # Throat Chop: Can't use sound moves
    if user.effects[PBEffects::ThroatChop] > 0 && move.soundMove?
      return -1000
    end
    
    # Gravity: Can't use airborne moves
    if @battle.field.effects[PBEffects::Gravity] > 0
      gravity_blocked = [:FLY, :BOUNCE, :SKYDROP, :MAGNETRISE, :TELEKINESIS, :HIGHJUMPKICK, :JUMPKICK, :FLYINGPRESS]
      return -1000 if gravity_blocked.include?(move.id)
    end
    
    # Prankster vs Dark type: Status moves fail
    if AdvancedAI::Utilities.prankster_blocked?(user, target, move)
      return -1000  # Prankster status move blocked by Dark type
    end
    
    # === ABILITY IMMUNITY CHECKS ===
    
    # Magic Bounce: Reflects status/hazard moves back — avoid completely
    if target.hasActiveAbility?(:MAGICBOUNCE)
      # Check if user has Mold Breaker to bypass
      user_ability = user.respond_to?(:ability_id) ? user.ability_id : nil
      unless [:MOLDBREAKER, :TERAVOLT, :TURBOBLAZE].include?(user_ability)
        bounced_moves = [
          :STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB,
          :THUNDERWAVE, :WILLOWISP, :TOXIC, :POISONPOWDER, :STUNSPORE,
          :SLEEPPOWDER, :SPORE, :HYPNOSIS, :DARKVOID, :GLARE, :YAWN,
          :SING, :GRASSWHISTLE, :LOVELYKISS, :POISONGAS,
          :TAUNT, :ENCORE, :TORMENT, :DISABLE,
          :ROAR, :WHIRLWIND, :DEFOG,
          :LEECHSEED, :EMBARGO, :HEALBLOCK
        ]
        if bounced_moves.include?(move.id)
          AdvancedAI.log("#{move.name} bounced by Magic Bounce on #{target.name}", "Ability")
          return -1000  # Move reflects back to us!
        end
      end
    end
    
    # Good as Gold: Immune to ALL status moves
    if target.hasActiveAbility?(:GOODASGOLD) && move.statusMove?
      user_ability = user.respond_to?(:ability_id) ? user.ability_id : nil
      unless [:MOLDBREAKER, :TERAVOLT, :TURBOBLAZE].include?(user_ability)
        AdvancedAI.log("#{move.name} blocked by Good as Gold on #{target.name}", "Ability")
        return -1000  # Status move completely fails
      end
    end
    
    # === MOVE-SPECIFIC FAILURE CHECKS ===
    
    # Status-inflicting moves: Don't use if target already has a status condition
    status_moves = {
      :THUNDERWAVE => :PARALYSIS,
      :STUNSPORE => :PARALYSIS,
      :GLARE => :PARALYSIS,
      :NUZZLE => :PARALYSIS,
      :ZAPCANNON => :PARALYSIS,
      :BODYSLAM => :PARALYSIS,  # 30% chance but still counts
      :TOXIC => :POISON,
      :POISONPOWDER => :POISON,
      :POISONGAS => :POISON,
      :POISONFANG => :POISON,
      :TOXICSPIKES => :POISON,  # On grounded targets
      :WILLOWISP => :BURN,
      :SCALD => :BURN,
      :FLAREBLITZ => :BURN,
      :SACREDFIRE => :BURN,
      :SLEEPPOWDER => :SLEEP,
      :SPORE => :SLEEP,
      :HYPNOSIS => :SLEEP,
      :DARKVOID => :SLEEP,
      :GRASSWHISTLE => :SLEEP,
      :LOVELYKISS => :SLEEP,
      :SING => :SLEEP
    }
    
    if status_moves.key?(move.id)
      # Target already has ANY status condition
      if target.status != :NONE
        AdvancedAI.log("#{move.name} blocked: #{target.name} already has #{target.status}", "StatusSpam")
        return -1000  # Can't inflict status on already-statused Pokemon
      end
      
      # Safeguard protection
      if target.pbOwnSide.effects[PBEffects::Safeguard] > 0
        AdvancedAI.log("#{move.name} blocked: Safeguard active on #{target.name}'s side", "StatusSpam")
        return -1000  # Safeguard blocks status
      end
      
      # Misty Terrain blocks status (for grounded targets)
      if @battle.field.terrain == :Misty
        if !target.airborne? && !target.hasActiveAbility?(:LEVITATE)
          AdvancedAI.log("#{move.name} blocked: #{target.name} protected by Misty Terrain", "StatusSpam")
          return -1000  # Misty Terrain prevents status for grounded
        end
      end
    end
    
    # Leech Seed: Can't use on already seeded targets or Grass types
    if move.id == :LEECHSEED
      if target.effects[PBEffects::LeechSeed] >= 0
        AdvancedAI.log("Leech Seed blocked: #{target.name} already seeded", "RedundantMove")
        return -1000
      end
      return -1000 if target.pbHasType?(:GRASS)  # Grass types are immune
    end
    
    # Substitute: Don't use if we already have a substitute
    if move.id == :SUBSTITUTE
      if user.effects[PBEffects::Substitute] > 0
        AdvancedAI.log("Substitute blocked: #{user.name} already has Substitute", "RedundantMove")
        return -1000
      end
    end
    
    # Yawn: Don't use if target is already drowsy or asleep
    if move.id == :YAWN
      if target.effects[PBEffects::Yawn] > 0
        AdvancedAI.log("Yawn blocked: #{target.name} already drowsy", "RedundantMove")
        return -1000
      end
      if target.status == :SLEEP
        AdvancedAI.log("Yawn blocked: #{target.name} already asleep", "RedundantMove")
        return -1000
      end
    end
    
    # Taunt: Don't use if target is already taunted
    if move.id == :TAUNT
      if target.effects[PBEffects::Taunt] > 0
        AdvancedAI.log("Taunt blocked: #{target.name} already taunted", "RedundantMove")
        return -1000
      end
    end
    
    # Encore: Don't use if target is already encored
    if move.id == :ENCORE
      if target.effects[PBEffects::Encore] > 0
        AdvancedAI.log("Encore blocked: #{target.name} already encored", "RedundantMove")
        return -1000
      end
    end
    
    # Embargo: Don't use if target is already embargoed
    if move.id == :EMBARGO
      if target.effects[PBEffects::Embargo] > 0
        AdvancedAI.log("Embargo blocked: #{target.name} already embargoed", "RedundantMove")
        return -1000
      end
    end
    
    # Torment: Don't use if target is already tormented
    if move.id == :TORMENT
      if target.effects[PBEffects::Torment]
        AdvancedAI.log("Torment blocked: #{target.name} already tormented", "RedundantMove")
        return -1000
      end
    end
    
    # Ingrain: Don't use if we're already ingrained
    if move.id == :INGRAIN
      if user.effects[PBEffects::Ingrain]
        AdvancedAI.log("Ingrain blocked: #{user.name} already ingrained", "RedundantMove")
        return -1000
      end
    end
    
    # Aqua Ring: Don't use if we already have Aqua Ring
    if move.id == :AQUARING
      if user.effects[PBEffects::AquaRing]
        AdvancedAI.log("Aqua Ring blocked: #{user.name} already has Aqua Ring", "RedundantMove")
        return -1000
      end
    end
    
    # Screens: Don't use if already active on our side
    if move.id == :REFLECT
      if user.pbOwnSide.effects[PBEffects::Reflect] > 0
        AdvancedAI.log("Reflect blocked: already active", "ScreenSpam")
        return -1000
      end
    end
    
    if move.id == :LIGHTSCREEN
      if user.pbOwnSide.effects[PBEffects::LightScreen] > 0
        AdvancedAI.log("Light Screen blocked: already active", "ScreenSpam")
        return -1000
      end
    end
    
    if move.id == :AURORAVEIL
      if user.pbOwnSide.effects[PBEffects::AuroraVeil] > 0
        AdvancedAI.log("Aurora Veil blocked: already active", "ScreenSpam")
        return -1000
      end
    end
    
    # Hazards: Don't set if already at maximum layers
    if move.id == :STEALTHROCK
      if target.pbOwnSide.effects[PBEffects::StealthRock]
        AdvancedAI.log("Stealth Rock blocked: already active on opponent's side", "HazardSpam")
        return -1000
      end
    end
    
    if move.id == :SPIKES
      spikes_count = target.pbOwnSide.effects[PBEffects::Spikes]
      if spikes_count >= 3
        AdvancedAI.log("Spikes blocked: max 3 layers already active", "HazardSpam")
        return -1000  # Max 3 layers
      end
    end
    
    if move.id == :TOXICSPIKES
      toxic_spikes_count = target.pbOwnSide.effects[PBEffects::ToxicSpikes]
      if toxic_spikes_count >= 2
        AdvancedAI.log("Toxic Spikes blocked: max 2 layers already active", "HazardSpam")
        return -1000  # Max 2 layers
      end
    end
    
    if move.id == :STICKYWEB
      if target.pbOwnSide.effects[PBEffects::StickyWeb]
        AdvancedAI.log("Sticky Web blocked: already active on opponent's side", "HazardSpam")
        return -1000
      end
    end
    
    # Tailwind: Don't use if already active
    if move.id == :TAILWIND
      if user.pbOwnSide.effects[PBEffects::Tailwind] > 0
        AdvancedAI.log("Tailwind blocked: already active", "FieldSpam")
        return -1000
      end
    end
    
    # Trick Room: Don't use if already active (unless intentionally turning it off)
    if move.id == :TRICKROOM
      # Only penalty if we WANT Trick Room and it's already up
      # (Advanced users might want to turn it off, so this is skill-dependent)
      if @battle.field.effects[PBEffects::TrickRoom] > 0 && skill < 80
        AdvancedAI.log("Trick Room blocked: already active (low skill AI)", "FieldSpam")
        return -1000  # Low skill AI won't understand toggling
      end
    end
    
    # Wish: Don't use if we already have Wish coming
    if move.id == :WISH
      return -1000 if user.effects[PBEffects::Wish] > 0
    end
    
    base_score = 100  # Neutral Start
    
    # === DEBUG FACTOR TRACKING ===
    # Track individual factor contributions for debug output
    @_score_factors = nil
    factors = $DEBUG ? {} : nil

    # === STATUS VALUE SCALING ===
    # Apply global multiplier for status moves based on AI tier/skill
    # (e.g. Extreme AI values status moves 1.5x more)
    status_multiplier = 1.0
    if move.statusMove?
      status_multiplier = AdvancedAI.tier_feature(skill, :status_value) || 1.0
      # Boost base score for status moves to make them competitive with damage
      base_score = 120 * status_multiplier
    end
    
    # Apply priority boost from tactical role system (Tier 2)
    base_score += priority_boost
    
    # === TYPE-ABSORBING ABILITY CHECK ===
    # Don't attack into Water Absorb, Volt Absorb, Flash Fire, Sap Sipper, etc.
    if move.damagingMove?
      absorption_penalty = AdvancedAI::Utilities.score_type_absorption_penalty(user, target, move)
      if absorption_penalty < -100
        return absorption_penalty  # Heavy penalty - avoid this move
      end
      base_score += absorption_penalty
      
      # Bulletproof immunity
      if AdvancedAI::Utilities.bulletproof_immune?(user, target, move)
        return -200  # Ball/bomb move blocked
      end
      
      # Soundproof immunity
      if AdvancedAI::Utilities.soundproof_immune?(user, target, move)
        return -200  # Sound move blocked
      end
    end
    
    # === DAMAGE ANALYSIS ===
    if move.damagingMove?
      v = score_damage_potential(move, user, target, skill)
      base_score += v; factors["Damage Potential"] = v if factors && v != 0
      
      v = score_type_effectiveness(move, user, target)
      base_score += v; factors["Type Effectiveness"] = v if factors && v != 0
      
      v = score_stab_bonus(move, user)
      base_score += v; factors["STAB"] = v if factors && v != 0
      
      v = score_crit_potential(move, user, target)
      base_score += v; factors["Crit Potential"] = v if factors && v != 0
      
      # Contact Punishment (Rough Skin, Iron Barbs, Rocky Helmet)
      if move.contactMove?
        v = score_contact_punishment(move, user, target)
        base_score -= v; factors["Contact Punishment"] = -v if factors && v != 0
      end
    end
    
    # === STATUS ANALYSIS ===
    if move.statusMove?
      v = score_status_utility(move, user, target, skill, status_multiplier)
      base_score += v; factors["Status Utility"] = v if factors && v != 0
    end
    
    # === SETUP ANALYSIS ===
    if move.function_code.start_with?("RaiseUser") || AdvancedAI.setup_move?(move.id)
      v = score_setup_value(move, user, target, skill, status_multiplier)
      base_score += v; factors["Setup Value"] = v if factors && v != 0
      
      v = score_setup_vs_mirror_herb(move, user, target)
      base_score += v; factors["Mirror Herb Risk"] = v if factors && v != 0
    end
    
    # === SITUATIONAL FACTORS ===
    v = score_priority(move, user, target)
    base_score += v; factors["Priority"] = v if factors && v != 0
    
    v = score_accuracy(move, skill)
    base_score += v; factors["Accuracy"] = v if factors && v != 0
    
    v = score_recoil_risk(move, user)
    base_score += v; factors["Recoil Risk"] = v if factors && v != 0
    
    v = score_secondary_effects(move, user, target)
    base_score += v; factors["Secondary Effects"] = v if factors && v != 0
    
    v = score_moody_pressure(move, user, target)
    base_score += v; factors["Moody Pressure"] = v if factors && v != 0
    
    v = score_status_vs_berry(move, user, target)
    base_score += v; factors["Status vs Berry"] = v if factors && v != 0
    
    # === REPORTED ISSUES HANDLING ===
    v = score_protect_utility(move, user, target)
    base_score += v; factors["Protect Utility"] = v if factors && v != 0
    
    v = score_prankster_bonus(move, user)
    base_score += v; factors["Prankster Bonus"] = v if factors && v != 0
    
    v = score_pivot_utility(move, user, target, skill)
    base_score += v; factors["Pivot Utility"] = v if factors && v != 0
    
    # === STALL SYNERGY ===
    v = score_stall_synergy(move, user, target)
    base_score += v; factors["Stall Synergy"] = v if factors && v != 0
    
    # === ROLE SYNERGY ===
    v = score_role_synergy(move, user, target, skill)
    base_score += v; factors["Role Synergy"] = v if factors && v != 0
    
    # === MOVE REPETITION PENALTY ===
    v = score_move_repetition_penalty(move, user)
    base_score += v; factors["Repetition Penalty"] = v if factors && v != 0
    
    # === ADVANCED SITUATIONAL AWARENESS ===
    v = score_destiny_bond_awareness(move, user, target)
    base_score += v; factors["Destiny Bond Awareness"] = v if factors && v != 0
    
    v = score_sucker_punch_risk(move, user, target, skill)
    base_score += v; factors["Sucker Punch Risk"] = v if factors && v != 0
    
    v = score_forced_switch_items(move, user, target)
    base_score += v; factors["Forced Switch Items"] = v if factors && v != 0
    
    v = score_item_disruption(move, user, target)
    base_score += v; factors["Item Disruption"] = v if factors && v != 0
    
    # === TACTICAL ENHANCEMENTS ===
    v = score_trapping_moves(move, user, target, skill)
    base_score += v; factors["Trapping"] = v if factors && v != 0
    
    v = score_choice_prelock(move, user, target)
    base_score += v; factors["Choice Pre-lock"] = v if factors && v != 0
    
    v = score_cleric_urgency(move, user)
    base_score += v; factors["Cleric Urgency"] = v if factors && v != 0
    
    v = score_user_destiny_bond(move, user, target)
    base_score += v; factors["Destiny Bond"] = v if factors && v != 0
    
    v = score_ghost_curse(move, user, target)
    base_score += v; factors["Ghost Curse"] = v if factors && v != 0
    
    v = score_counter_mirror_coat(move, user, target)
    base_score += v; factors["Counter/Mirror Coat"] = v if factors && v != 0
    
    v = score_disable_optimization(move, user, target)
    base_score += v; factors["Disable"] = v if factors && v != 0
    
    v = score_healing_wish_target(move, user)
    base_score += v; factors["Healing Wish"] = v if factors && v != 0
    
    v = score_mixed_attacker(move, user, target)
    base_score += v; factors["Mixed Attacker"] = v if factors && v != 0
    
    v = score_transform_ditto(move, user, target)
    base_score += v; factors["Transform"] = v if factors && v != 0
    
    # === GLAIVE RUSH SELF-RISK ===
    # If using Glaive Rush, AI takes 2x damage next turn - factor this risk
    if move.id == :GLAIVERUSH
      # Estimate incoming damage if we survive
      expected_retaliation = estimate_incoming_damage(user, target)
      doubled_damage = expected_retaliation * 2
      
      if doubled_damage >= user.hp
        base_score -= 80  # High chance of dying next turn
      elsif doubled_damage >= user.hp * 0.7
        base_score -= 40  # Significant risk
      elsif doubled_damage >= user.hp * 0.4
        base_score -= 20  # Moderate risk
      else
        base_score -= 5   # Minor risk
      end
      
      # But if this will KO the target, the risk doesn't matter
      rough_damage = calculate_rough_damage(move, user, target)
      if rough_damage >= target.hp
        base_score += 50  # KO negates the drawback
      end
    end
    
    # Store factor breakdown for debug output in pbGetMoveScore
    @_score_factors = factors
    
    return base_score
  end
  
  private
  
  # Damage Potential
  def score_damage_potential(move, user, target, skill)
    score = 0
    
    # Effective Base Power (Factors in Multi-Hits, Skill Link, etc.)
    bp = calculate_effective_power(move, user, target)
    
    # Base Power Bonus
    score += (bp / 10.0) if bp > 0
    
    # KO Potential
    if skill >= 60
      # Use effective BP for damage calc
      rough_damage = calculate_rough_damage(move, user, target, bp)
      if rough_damage >= target.hp
        score += 100  # Guaranteed KO
      elsif rough_damage >= target.hp * 0.7
        score += 50   # Likely KO
      elsif rough_damage >= target.hp * 0.4
        score += 25
      end
    end
    
    # Multi-Target Bonus
    score += 30 if move.pbTarget(user).num_targets > 1 && @battle.pbSideSize(0) > 1
    
    return score
  end
  
  # Type Effectiveness
  def score_type_effectiveness(move, user, target)
    type_mod = Effectiveness.calculate(move.type, target.types[0], target.types[1])
    
    if Effectiveness.super_effective?(type_mod)
      return 40
    elsif Effectiveness.not_very_effective?(type_mod)
      return -30
    elsif Effectiveness.ineffective?(type_mod)
      return -200
    end
    
    return 0
  end
  
  # STAB Bonus
  def score_stab_bonus(move, user)
    return 20 if user.pbHasType?(move.type)
    return 0
  end
  
  # Critical Hit Potential
  def score_crit_potential(move, user, target)
    score = 0
    
    # 1. Critical Immunity Check
    # If target has Battle Armor, Shell Armor, or Lucky Chant, crits are impossible/unlikely
    return 0 if target.hasActiveAbility?(:BATTLEARMOR) || target.hasActiveAbility?(:SHELLARMOR)
    return 0 if target.pbOwnSide.effects[PBEffects::LuckyChant] > 0
    
    # Check for High Crit Rate Move
    is_high_crit = (move.function_code == "HighCriticalHitRate")
    is_always_crit = move.function_code.include?("AlwaysCriticalHit")
    
    # 2. Synergy: Focus Energy + High Crit Move
    # Focus Energy (+2 stages) + High Crit Move (+1 stage) = +3 stages (100% Crit)
    # NOTE: Do NOT give a synergy bonus for AlwaysCriticalHit moves, because Focus Energy
    # adds nothing to them (they already crit).
    if user.effects[PBEffects::FocusEnergy] > 0
      if is_high_crit
        score += 50  # Massive bonus for correctly using the combo
      elsif !is_always_crit
        # Focus Energy alone gives 50% crit rate (Stage 2)
        # Still good for normal moves, but useless for AlwaysCrit moves
        score += 20
      end
    elsif is_high_crit
      # High Crit Move alone is 1/8 chance (Stage 1), decent but not reliable
      score += 15
    end
    
    # 3. Ignore Stat Changes
    # Critical hits ignore the target's positive defense stages...
    ignore_target_def = (target.stages[:DEFENSE] > 0 && move.physicalMove?) || 
                        (target.stages[:SPECIAL_DEFENSE] > 0 && move.specialMove?)
    
    # ...AND they ignore the user's negative attack stages!
    ignore_user_debuff = (user.stages[:ATTACK] < 0 && move.physicalMove?) || 
                         (user.stages[:SPECIAL_ATTACK] < 0 && move.specialMove?)
    
    if ignore_target_def || ignore_user_debuff
      # Only apply this bonus if we have a RELIABLE crit chance
      # (Focus Energy active OR Move always crits)
      if user.effects[PBEffects::FocusEnergy] > 0 || move.function_code.include?("AlwaysCriticalHit")
        score += 30 # Value bypassing the stats
      end
    end
    
    return score
  end
  
  # Status Move Utility
  def score_status_utility(move, user, target, skill, status_multiplier = 1.0)
    score = 0
    
    # Determine opponent side (for hazards)
    opponent_side = @battle.pbOwnedByPlayer?(target.index) ? @battle.sides[1] : @battle.sides[0]
    
    case move.function_code
    # Hazards
    when "AddSpikesToFoeSide"
      score += 60 if opponent_side.effects[PBEffects::Spikes] < 3
    when "AddStealthRocksToFoeSide"
      unless opponent_side.effects[PBEffects::StealthRock]
        score += 100 * status_multiplier
        # High priority early game or if healthy
        score += 60 if @battle.turnCount <= 1  # Verify turn 1
        score += 40 if user.hp > user.totalhp * 0.8
      end
    when "AddToxicSpikesToFoeSide"
      score += 50 if opponent_side.effects[PBEffects::ToxicSpikes] < 2
    when "AddStickyWebToFoeSide"
      # Score high if opponent side has no sticky web and we aren't faster
      score += 60 unless opponent_side.effects[PBEffects::StickyWeb]
    # Screens
    when "StartWeakenPhysicalDamageAgainstUserSide" # Reflect
      if user.pbOwnSide.effects[PBEffects::Reflect] == 0
        score += 80 * status_multiplier
        # Priority on turn 1
        score += 50 if @battle.turnCount <= 1 
        # Bonus if opponent's last move was Physical
        if target.lastRegularMoveUsed
          move_data = GameData::Move.try_get(target.lastRegularMoveUsed)
          score += 40 if move_data&.physical?
        end
      end
    when "StartWeakenSpecialDamageAgainstUserSide" # Light Screen
      if user.pbOwnSide.effects[PBEffects::LightScreen] == 0
        score += 80 * status_multiplier
        # Priority on turn 1
        score += 50 if @battle.turnCount <= 1
        # Bonus if opponent's last move was Special
        if target.lastRegularMoveUsed
          move_data = GameData::Move.try_get(target.lastRegularMoveUsed)
          score += 40 if move_data&.special?
        end
      end
    when "StartWeakenDamageAgainstUserSideIfHail" # Aurora Veil
      if (@battle.pbWeather == :Hail || @battle.pbWeather == :Snow) && user.pbOwnSide.effects[PBEffects::AuroraVeil] == 0
        score += 60
        # Bonus if opponent's last move was Damaging
        if target.lastRegularMoveUsed
          move_data = GameData::Move.try_get(target.lastRegularMoveUsed)
          score += 40 if move_data&.damaging?
        end
      end
      
    # Recovery
    when "HealUserHalfOfTotalHP", "HealUserDependingOnWeather"
      hp_percent = user.hp.to_f / user.totalhp
      if hp_percent < 0.3
        score += 150  # Critical urgency
      elsif hp_percent < 0.5
        score += 100  # Strong urgency
      elsif hp_percent < 0.7
        score += 40   # Maintenance
      end
      
      # Boost if faster
      score += 30 if user.pbSpeed > target.pbSpeed
      
    # Status Infliction
    when "ParalyzeTarget"
      # Thunder Wave - CRITICAL vs faster targets
      if target.pbSpeed > user.pbSpeed && target.status == :NONE
        score += 80  # Massive bonus - cripple faster threats
        # Extra bonus if we can KO after paralyze
        target_speed_after = target.pbSpeed / 2
        if user.pbSpeed > target_speed_after
          score += 30  # Now we outspeed and can KO
        end
      elsif target.status == :NONE
        score += 25  # Still useful vs slower targets
      end
      
    when "BurnTarget"
      # Will-O-Wisp - CRITICAL vs physical attackers
      if target.attack > target.spatk && target.status == :NONE
        score += 100  # Massive bonus - nerf physical attackers
        # Extra bonus if we resist their attacks
        if target.lastRegularMoveUsed
          last_move = GameData::Move.try_get(target.lastRegularMoveUsed)
          if last_move && last_move.physicalMove?
            score += 40  # They're locked into physical damage
          end
        end
      elsif target.status == :NONE
        score += 30  # Still useful for passive damage
      end
      
    when "PoisonTarget"
      # Basic Poison - good chip damage
      if target.status == :NONE && target.hp > target.totalhp * 0.7
        score += 35
        # Bonus vs bulky targets
        if target.defense + target.spdef > 200
          score += 25  # Walls hate poison
        end
      end
      
    when "BadPoisonTarget"
      # Toxic - CRITICAL vs walls and stall
      if target.status == :NONE
        score += 60  # Strong base value
        # HUGE bonus vs bulky/recovery Pokemon
        if target.defense + target.spdef > 200
          score += 70  # Toxic destroys walls
        end
        # Bonus vs regenerator/recovery moves
        if target.hasActiveAbility?(:REGENERATOR)
          score += 50  # Counter regenerator stalling
        end
        # Bonus if we have stall tactics (Protect, recovery)
        stall_moves = [:PROTECT, :DETECT, :RECOVER, :ROOST, :SOFTBOILED, :WISH, :REST]
        user_knows_stall = user.battler.moves.any? { |m| stall_moves.include?(m.id) }
        if user_knows_stall
          score += 40  # Can stall out Toxic damage
        end
      end
      
    when "SleepTarget"
      # Sleep - CRITICAL control move
      if target.status == :NONE
        score += 90  # Sleep is incredibly powerful
        # Bonus if we can setup during sleep
        setup_moves = user.battler.moves.any? { |m| AdvancedAI.setup_move?(m.id) }
        if setup_moves
          score += 60  # Free setup turns!
        end
        # Bonus vs offensive threats
        if target.attack > 120 || target.spatk > 120
          score += 40  # Neutralize sweepers
        end
      end
      
    # Stat Drops
    when "LowerTargetAttack1", "LowerTargetAttack2"
      score += 30 if target.attack > target.spatk
    when "LowerTargetSpeed1", "LowerTargetSpeed2"
      score += 35 if target.pbSpeed > user.pbSpeed
    when "LowerTargetDefense1", "LowerTargetDefense2"
      score += 25 if user.attack > user.spatk
    end
    
    return score
  end
  
  # Setup Value
  def score_setup_value(move, user, target, skill, status_multiplier = 1.0)
    return 0 unless skill >= 55
    score = 0
    
    # Safe to setup?
    safe_to_setup = is_safe_to_setup?(user, target)
    
    if safe_to_setup

      # Boost Strength
      total_boosts = 0
      
      # Try to get data from MoveCategories
      setup_data = AdvancedAI.get_setup_data(move.id)
      if setup_data
        total_boosts = setup_data[:stages] || 1
      elsif move.function_code.start_with?("RaiseUser")
        # Extract boost amount from function code (e.g., "RaiseUserAttack1" -> 1)
        total_boosts = move.function_code.scan(/\d+/).last.to_i
        total_boosts = 1 if total_boosts == 0 # Default to 1 if no number (e.g., "RaiseUserAllStats1")
      else
        total_boosts = 1
      end
      
      score += total_boosts * 40 * status_multiplier # Increased value per boost
      
      # Sweep Potential
      if user.hp > user.totalhp * 0.7
        score += 30
      end
    else
      score -= 40  # Dangerous to setup
    end
    
    return score
  end
  
  # Priority
  def score_priority(move, user, target)
    return 0 if move.priority <= 0
    
    score = move.priority * 15
    
    # 1. Desperation Logic: User Low HP & Slower
    if user.hp <= user.totalhp * 0.33 && target.pbSpeed > user.pbSpeed
      score += 40 
    end

    # 2. Priority Blockers
    if move.priority > 0
      # Psychic Terrain (blocks priority against grounded targets)
      if @battle.field.terrain == :Psychic && target.affectedByTerrain?
        return -100
      end
      
      # Ability Blockers (Dazzling, Queenly Majesty, Armor Tail)
      # These abilities block priority moves targeting the user
      blocking_abilities = [:DAZZLING, :QUEENLYMAJESTY, :ARMORTAIL]
      if blocking_abilities.include?(target.ability_id) && !user.hasMoldBreaker?
        return -100
      end
    end
    
    # Extra Bonus if slower
    score += 30 if target.pbSpeed > user.pbSpeed
    
    # Extra Bonus if KO possible
    if move.damagingMove?
      rough_damage = calculate_rough_damage(move, user, target)
      score += 40 if rough_damage >= target.hp
    end
    
    return score
  end
  
  # Accuracy
  def score_accuracy(move, skill)
    # Use raw accuracy to avoid AIMove#accuracy crash (needs battler which might be nil)
    # If move is AIMove (wrapper), get inner move. If regular Move, use it directly.
    accuracy = move.respond_to?(:move) ? move.move.accuracy : move.accuracy
    return 0 if accuracy == 0  # Never-miss moves
    
    if accuracy < 70
      return -40
    elsif accuracy < 85
      return -20
    elsif accuracy < 95
      return -10
    end
    
    return 0
  end
  
  # Recoil Risk
  def score_recoil_risk(move, user)
    return 0 unless move.recoilMove?
    
    hp_percent = user.hp.to_f / user.totalhp
    
    if hp_percent < 0.3
      return -50  # Dangerous at low HP
    elsif hp_percent < 0.5
      return -25
    else
      return -10  # Acceptable risk
    end
  end
  
  # Secondary Effects
  def score_secondary_effects(move, user, target)
    score = 0
    
    # Covert Cloak blocks secondary effects
    if AdvancedAI::Utilities.has_covert_cloak?(target)
      return 0  # No secondary effect value
    end
    
    # Shield Dust blocks secondary effects
    if target.ability_id == :SHIELDDUST
      return 0
    end
    
    # Flinch
    if move.flinchingMove?
      # Inner Focus / Scrappy / Own Tempo etc. prevent flinch
      unless [:INNERFOCUS, :OWNTEMPO, :OBLIVIOUS].include?(target.ability_id)
        score += 20 if user.pbSpeed > target.pbSpeed
      end
    end
    
    # Stat Drops on Target
    if move.function_code.start_with?("LowerTarget")
      # Clear Amulet / Clear Body / White Smoke prevent stat drops
      if AdvancedAI::Utilities.has_clear_amulet?(target)
        score -= 10  # Wasted effect
      elsif [:CLEARBODY, :WHITESMOKE, :FULLMETALBODY].include?(target.ability_id)
        score -= 10
      else
        score += 20
      end
    end
    
    # Status Chance
    if ["ParalyzeTarget", "BurnTarget", "PoisonTarget", "SleepTarget", "FreezeTarget"].any? {|code| move.function_code.include?(code)}
      score += move.addlEffect / 2
    end
    
    return score
  end
  
  # Contact Move Punishment
  # Accounts for Rough Skin, Iron Barbs, Rocky Helmet, etc.
  def score_contact_punishment(move, user, target)
    return 0 unless move && move.contactMove?
    return 0 unless target
    
    # Long Reach ignores contact entirely
    return 0 if user.hasActiveAbility?(:LONGREACH)
    
    # Protective Pads prevents contact damage
    return 0 if user.hasActiveItem?(:PROTECTIVEPADS)
    
    score_penalty = 0
    mold_breaker = AdvancedAI::Utilities.ignores_ability?(user)
    
    # === Damage Abilities ===
    unless mold_breaker
      # Rough Skin / Iron Barbs (1/8 max HP)
      if target.hasActiveAbility?(:ROUGHSKIN) || target.hasActiveAbility?(:IRONBARBS)
        recoil_damage = user.totalhp / 8
        hp_percent_lost = (recoil_damage * 100.0 / [user.hp, 1].max)
        
        if hp_percent_lost >= 100
          score_penalty += 80  # Would KO self
        elsif hp_percent_lost >= 50
          score_penalty += 40  # Major damage
        elsif hp_percent_lost >= 25
          score_penalty += 20
        else
          score_penalty += 10
        end
      end
      
      # === Status Abilities ===
      if user.status == :NONE
        # Flame Body (30% Burn)
        if target.hasActiveAbility?(:FLAMEBODY)
          # Physical attackers hurt more by burn
          if user.attack > user.spatk
            score_penalty += 25
          else
            score_penalty += 10
          end
        end
        
        # Static (30% Paralysis)
        if target.hasActiveAbility?(:STATIC)
          # Fast Pokemon hurt more by paralysis
          if user.pbSpeed >= 100
            score_penalty += 20
          else
            score_penalty += 8
          end
        end
        
        # Poison Point (30% Poison)
        if target.hasActiveAbility?(:POISONPOINT)
          score_penalty += 10
        end
        
        # Effect Spore (30% sleep/para/poison)
        if target.hasActiveAbility?(:EFFECTSPORE)
          # Safety Goggles protects
          score_penalty += 15 unless user.hasActiveItem?(:SAFETYGOGGLES)
        end
      end
      
      # === Speed Drop Abilities ===
      # Gooey / Tangling Hair (-1 Speed)
      if target.hasActiveAbility?(:GOOEY) || target.hasActiveAbility?(:TANGLINGHAIR)
        # Only matters if we care about speed
        if user.pbSpeed >= target.pbSpeed
          score_penalty += 15  # Could lose speed advantage
        else
          score_penalty += 5   # Already slower
        end
      end
      
      # === Special Abilities ===
      # Perish Body (both get Perish Song)
      if target.hasActiveAbility?(:PERISHBODY)
        score_penalty += 30 unless user.effects[PBEffects::PerishSong] > 0
      end
      
      # Mummy / Lingering Aroma (changes ability)
      if target.hasActiveAbility?(:MUMMY) || target.hasActiveAbility?(:LINGERINGAROMA)
        # Only penalize if user has a good ability
        good_abilities = [:HUGEPOWER, :PUREPOWER, :SPEEDBOOST, :PROTEAN, :LIBERO,
                          :WONDERGUARD, :MAGICGUARD, :MULTISCALE, :SHADOWSHIELD]
        score_penalty += 25 if good_abilities.include?(user.ability_id)
      end
      
      # Wandering Spirit (swaps abilities)
      if target.hasActiveAbility?(:WANDERINGSPIRIT)
        score_penalty += 15  # Usually undesirable
      end
    end
    
    # === Rocky Helmet (not an ability) ===
    if target.hasActiveItem?(:ROCKYHELMET)
      recoil_damage = user.totalhp / 6
      hp_percent_lost = (recoil_damage * 100.0 / [user.hp, 1].max)
      
      if hp_percent_lost >= 100
        score_penalty += 100  # Would KO self
      elsif hp_percent_lost >= 50
        score_penalty += 50
      elsif hp_percent_lost >= 25
        score_penalty += 25
      else
        score_penalty += 12
      end
    end
    
    return score_penalty
  end
  
  # === HELPER METHODS ===
  
  def calculate_rough_damage(move, user, target, override_bp = nil)
    return 0 unless move.damagingMove?
    
    # Very Simplified Damage Calculation
    bp = override_bp || move.power
    return 0 if bp == 0
    
    # === GEN 9 VARIABLE POWER MOVES ===
    # Last Respects - 50 + 50 per fainted ally
    if move.id == :LASTRESPECTS && @battle
      bp = AdvancedAI::Utilities.last_respects_power(@battle, user)
    end
    
    # Rage Fist - 50 + 50 per hit taken
    if move.id == :RAGEFIST
      bp = AdvancedAI::Utilities.rage_fist_power(user)
    end
    
    # Collision Course / Electro Drift - 1.33x if SE
    if AdvancedAI::Utilities.collision_move_boost?(move)
      type_check = Effectiveness.calculate(move.type, target.types[0], target.types[1])
      bp = (bp * 1.33).to_i if Effectiveness.super_effective?(type_check)
    end
    
    # === SPECIAL MOVE BASE POWER SCALING ===
    # Facade doubles when statused
    if move.id == :FACADE && user.status != :NONE
      bp *= 2
    end
    
    # Hex doubles vs statused target
    if move.id == :HEX && target.status != :NONE
      bp *= 2
    end
    
    # Venoshock doubles vs poisoned target
    if move.id == :VENOSHOCK && [:POISON, :TOXIC].include?(target.status)
      bp *= 2
    end
    
    # Brine doubles at <50% HP
    if move.id == :BRINE && target.hp < target.totalhp / 2
      bp *= 2
    end
    
    # Avalanche / Revenge double if hit first
    if [:AVALANCHE, :REVENGE].include?(move.id) && user.lastHPLost > 0
      bp *= 2
    end
    
    # Stored Power / Power Trip - 20 BP per positive stat stage
    if [:STOREDPOWER, :POWERTRIP].include?(move.id)
      stat_boosts = 0
      GameData::Stat.each_battle do |stat|
        stage = user.stages[stat.id] rescue 0
        stat_boosts += stage if stage > 0
      end
      bp = 20 + (20 * stat_boosts)
    end
    
    # Knock Off - 1.5x damage if target has item
    if move.id == :KNOCKOFF && target.item && target.item != :NONE
      bp = (bp * 1.5).to_i
    end
    
    # Acrobatics - 2x damage without item
    if move.id == :ACROBATICS && (!user.item || user.item == :NONE)
      bp *= 2
    end
    
    # Poltergeist - fails if no item
    if move.id == :POLTERGEIST && (!target.item || target.item == :NONE)
      return 0  # Move fails
    end
    
    # === STAT CALCULATION ===
    atk = move.physicalMove? ? user.attack : user.spatk
    defense = move.physicalMove? ? target.defense : target.spdef
    
    # === SPECIAL STAT-USING MOVES ===
    # Foul Play - uses target's Attack stat
    if move.id == :FOULPLAY
      atk = target.attack
    end
    
    # Body Press - uses user's Defense instead of Attack
    if move.id == :BODYPRESS
      atk = user.defense
    end
    
    # Psyshock / Psystrike / Secret Sword - special attack vs physical Defense
    if [:PSYSHOCK, :PSYSTRIKE, :SECRETSWORD].include?(move.id)
      defense = target.defense  # Use Defense instead of SpDef
    end
    
    # Photon Geyser / Light That Burns the Sky - uses higher attacking stat
    if [:PHOTONGEYSER, :LIGHTTHATBURNSTHESKY].include?(move.id)
      atk = [user.attack, user.spatk].max
    end
    
    # === FIXED DAMAGE MOVES (bypass normal calc) ===
    # Seismic Toss / Night Shade - level-based fixed damage
    if [:SEISMICTOSS, :NIGHTSHADE].include?(move.id)
      return user.level
    end
    
    # Super Fang / Nature's Madness - 50% current HP
    if [:SUPERFANG, :NATURESMADNESS].include?(move.id)
      return [target.hp / 2, 1].max
    end
    
    # Final Gambit - user's remaining HP
    if move.id == :FINALGAMBIT
      return user.hp
    end
    
    # Dragon Rage - fixed 40 damage
    if move.id == :DRAGONRAGE
      return 40
    end
    
    # Sonic Boom - fixed 20 damage
    if move.id == :SONICBOOM
      return 20
    end
    
    # Endeavor - reduce to user's HP
    if move.id == :ENDEAVOR
      return [target.hp - user.hp, 0].max
    end
    
    # === UNAWARE HANDLING ===
    # If target has Unaware, ignore user's offensive stat boosts
    if target.ability_id == :UNAWARE && !AdvancedAI::Utilities.ignores_ability?(user)
      # Use base stat instead of boosted stat
      if move.physicalMove?
        atk = user.pokemon.attack rescue user.attack
      else
        atk = user.pokemon.spatk rescue user.spatk
      end
    end
    
    # If user has Unaware, ignore target's defensive stat boosts
    if user.ability_id == :UNAWARE
      if move.physicalMove?
        defense = target.pokemon.defense rescue target.defense
      else
        defense = target.pokemon.spdef rescue target.spdef
      end
    end
    
    # === BURN PHYSICAL DAMAGE REDUCTION ===
    burn_mod = 1.0
    if user.status == :BURN && move.physicalMove?
      # Guts ignores burn penalty AND gets 1.5x boost
      if user.ability_id == :GUTS
        burn_mod = 1.5
      # Flare Boost for special moves (but this is physical so skip)
      else
        burn_mod = 0.5  # Burn halves physical damage
      end
    end
    
    # Guts boost for other statuses too
    if user.ability_id == :GUTS && user.status != :NONE && user.status != :BURN
      burn_mod = 1.5
    end
    
    # === TYPE EFFECTIVENESS ===
    type_mod = Effectiveness.calculate(move.type, target.types[0], target.types[1])
    stab = user.pbHasType?(move.type) ? 1.5 : 1.0
    
    # Adaptability STAB boost
    if user.ability_id == :ADAPTABILITY && user.pbHasType?(move.type)
      stab = 2.0
    end
    
    # === ABILITY DAMAGE MODIFIERS ===
    ability_mod = 1.0
    
    # Huge Power / Pure Power
    if [:HUGEPOWER, :PUREPOWER].include?(user.ability_id) && move.physicalMove?
      ability_mod *= 2.0
    end
    
    # Hustle (physical +50%, accuracy penalty handled elsewhere)
    if user.ability_id == :HUSTLE && move.physicalMove?
      ability_mod *= 1.5
    end
    
    # Gorilla Tactics (physical +50% but locked)
    if user.ability_id == :GORILLATACTICS && move.physicalMove?
      ability_mod *= 1.5
    end
    
    # Transistor (Electric +50%)
    if user.ability_id == :TRANSISTOR && move.type == :ELECTRIC
      ability_mod *= 1.5
    end
    
    # Dragons Maw (Dragon +50%)
    if user.ability_id == :DRAGONSMAW && move.type == :DRAGON
      ability_mod *= 1.5
    end
    
    # === ITEM DAMAGE MODIFIERS ===
    item_mod = 1.0
    
    if user.item_id == :LIFEORB
      item_mod *= 1.3
    elsif user.item_id == :CHOICEBAND && move.physicalMove?
      item_mod *= 1.5
    elsif user.item_id == :CHOICESPECS && move.specialMove?
      item_mod *= 1.5
    elsif user.item_id == :EXPERTBELT && Effectiveness.super_effective?(type_mod)
      item_mod *= 1.2
    end
    
    # Type-boosting items
    type_items = {
      :SILKSCARF => :NORMAL, :BLACKBELT => :FIGHTING, :SHARPBEAK => :FLYING,
      :POISONBARB => :POISON, :SOFTSAND => :GROUND, :HARDSTONE => :ROCK,
      :SILVERPOWDER => :BUG, :SPELLTAG => :GHOST, :METALCOAT => :STEEL,
      :CHARCOAL => :FIRE, :MYSTICWATER => :WATER, :MIRACLESEED => :GRASS,
      :MAGNET => :ELECTRIC, :TWISTEDSPOON => :PSYCHIC, :NEVERMELTICE => :ICE,
      :DRAGONFANG => :DRAGON, :BLACKGLASSES => :DARK, :FAIRYFEATHER => :FAIRY
    }
    if type_items.key?(user.item_id) && move.type == type_items[user.item_id]
      item_mod *= 1.2
    end
    
    # Plates
    plate_types = {
      :FISTPLATE => :FIGHTING, :SKYPLATE => :FLYING, :TOXICPLATE => :POISON,
      :EARTHPLATE => :GROUND, :STONEPLATE => :ROCK, :INSECTPLATE => :BUG,
      :SPOOKYPLATE => :GHOST, :IRONPLATE => :STEEL, :FLAMEPLATE => :FIRE,
      :SPLASHPLATE => :WATER, :MEADOWPLATE => :GRASS, :ZAPPLATE => :ELECTRIC,
      :MINDPLATE => :PSYCHIC, :ICICLEPLATE => :ICE, :DRACOPLATE => :DRAGON,
      :DREADPLATE => :DARK, :PIXIEPLATE => :FAIRY
    }
    if plate_types.key?(user.item_id) && move.type == plate_types[user.item_id]
      item_mod *= 1.2
    end
    
    # === TARGET STATE MODIFIERS ===
    target_mod = 1.0
    
    # Glaive Rush vulnerability (target takes 2x damage)
    if defined?(PBEffects::GlaiveRush) && target.effects[PBEffects::GlaiveRush] > 0
      target_mod *= 2.0
    end
    
    # Type-resist berries (halve SE damage)
    if AdvancedAI::Utilities.has_resist_berry?(target, move.type) && 
       Effectiveness.super_effective?(type_mod)
      target_mod *= 0.5
    end
    
    # Assault Vest (1.5x SpDef vs special moves)
    if target.item_id == :ASSAULTVEST && move.specialMove?
      # Already factored into spdef stat, but note for consideration
    end
    
    # === FINAL CALCULATION ===
    damage = ((2 * user.level / 5.0 + 2) * bp * atk / [defense, 1].max / 50 + 2)
    damage *= type_mod / Effectiveness::NORMAL_EFFECTIVE.to_f
    damage *= stab
    damage *= burn_mod
    damage *= ability_mod
    damage *= item_mod
    damage *= target_mod
    
    return [damage.to_i, 1].max
  end
  
  def is_safe_to_setup?(user, target)
    # HP Check
    return false if user.hp < user.totalhp * 0.5
    
    # Speed Check
    return false if target.pbSpeed > user.pbSpeed * 1.5
    
    # Type Matchup Check
    target.moves.each do |move|
      next unless move && move.damagingMove?
      type_mod = Effectiveness.calculate(move.type, user.types[0], user.types[1])
      return false if Effectiveness.super_effective?(type_mod)
    end
    
    return true
  end
  
  # Calculates effective base power including multi-hit factors
  def calculate_effective_power(move, user, target)
    bp = move.power
    return 0 if bp == 0
    
    # Always Critical Hit Logic (e.g. Flower Trick, Frost Breath)
    if move.function_code.include?("AlwaysCriticalHit")
      # Check immunity
      is_immune = target.hasActiveAbility?(:BATTLEARMOR) || 
                  target.hasActiveAbility?(:SHELLARMOR) ||
                  target.pbOwnSide.effects[PBEffects::LuckyChant] > 0
      
      unless is_immune
        bp = (bp * 1.5).to_i
      end
    end
    
    return bp unless move.multiHitMove? || move.function_code == "HitTwoTimes"
    
    if move.multiHitMove?
      if user.hasActiveAbility?(:SKILLLINK)
        return bp * 5
      elsif user.hasActiveItem?(:LOADEDDICE)
        return bp * 4 # Average 4-5 hits
      else
        # Safely get number of hits - some moves like Beat Up require pbMoveFailed?
        # to be called first to initialize state (e.g., @beatUpList)
        begin
          num_hits = move.pbNumHits(user, [target])
          return bp * 2 if num_hits == 2  # Fixed 2-hit moves
          return bp * num_hits if num_hits > 0
        rescue NoMethodError, StandardError
          # If pbNumHits fails (uninitialized state), estimate based on function code
          case move.function_code
          when "HitOncePerUserTeamMember"  # Beat Up - estimate party size
            party = @battle.pbParty(user.index)
            able_count = party.count { |p| p && p.able? && p.status == :NONE }
            return bp * [able_count, 1].max
          when "HitTenTimes"  # Population Bomb
            return bp * 7  # Average hits
          else
            return bp * 3  # Default average for 2-5 hit moves
          end
        end
        return bp * 3 # Average for 2-5 hit moves
      end
    elsif move.function_code == "HitTwoTimes"
       return bp * 2
    end
    
    return bp
  end
  
  #=============================================================================
  # Advanced Situational Awareness Methods
  #=============================================================================
  
  # Destiny Bond Awareness - don't KO if we die too
  def score_destiny_bond_awareness(move, user, target)
    return 0 unless move.damagingMove?
    return 0 unless target.effects[PBEffects::DestinyBond]
    
    # Would we KO them?
    rough_damage = calculate_rough_damage(move, user, target, move.power)
    return 0 if rough_damage < target.hp  # Won't trigger
    
    # We would trigger Destiny Bond!
    hp_percent = user.hp.to_f / user.totalhp
    
    if hp_percent <= 0.3
      return -100  # We're low HP, absolutely not worth dying
    elsif hp_percent <= 0.5
      return -60   # Risky trade
    else
      return -20   # We're healthy, might be worth the trade
    end
  end
  
  # Sucker Punch Risk - fails if target uses non-damaging move
  def score_sucker_punch_risk(move, user, target, skill)
    return 0 unless move.id == :SUCKERPUNCH
    return 0 unless skill >= 60
    
    score = 0
    
    # Count target's status moves
    status_move_count = target.moves.count { |m| m && m.statusMove? }
    total_moves = target.moves.count { |m| m }
    
    return 0 if total_moves == 0
    
    status_ratio = status_move_count.to_f / total_moves
    
    # High status move ratio = risky
    if status_ratio >= 0.5
      score -= 40  # Very likely to fail
    elsif status_ratio >= 0.25
      score -= 20  # Some risk
    end
    
    # Low HP target is more likely to attack
    if target.hp < target.totalhp * 0.3
      score += 25  # They'll probably try to attack
    end
    
    # Check if target has Protect (might use it)
    has_protect = target.moves.any? { |m| m && AdvancedAI.protect_move?(m.id) }
    if has_protect
      score -= 15  # Risk of Protect
    end
    
    # Target just used an attacking move? More likely to attack again
    if target.battler.lastMoveUsed
      last_move_data = GameData::Move.try_get(target.battler.lastMoveUsed)
      if last_move_data && last_move_data.damaging?
        score += 15  # Pattern suggests attacking
      end
    end
    
    score
  end
  
  # Eject Button / Red Card awareness
  def score_forced_switch_items(move, user, target)
    return 0 unless move.damagingMove?
    score = 0
    
    # Eject Button on target - hitting them forces THEIR switch
    if target.item_id == :EJECTBUTTON
      # This is often good - forces them to switch out
      # But check if we WANT them to switch
      if target.stages[:ATTACK] >= 2 || target.stages[:SPECIAL_ATTACK] >= 2
        score += 30  # Force out a setup sweeper = great!
      else
        score += 10  # Neutral to slightly good
      end
    end
    
    # Red Card on target - hitting them forces OUR switch
    if target.item_id == :REDCARD
      # Check if switching is bad for us
      if user.stages[:ATTACK] >= 2 || user.stages[:SPECIAL_ATTACK] >= 2
        score -= 40  # Don't lose our boosts!
      elsif user.effects[PBEffects::Substitute] && user.effects[PBEffects::Substitute] > 0
        score -= 30  # Don't lose our Sub!
      else
        score -= 10  # Generally don't want forced switch
      end
    end
    
    score
  end
  
  # Estimate incoming damage from opponent's strongest move
  def estimate_incoming_damage(defender, attacker)
    return 0 unless attacker && attacker.moves
    
    max_damage = 0
    attacker.moves.each do |move|
      next unless move && move.power > 0
      
      # Simple damage estimate
      atk = move.physicalMove? ? attacker.attack : attacker.spatk
      defense = move.physicalMove? ? defender.defense : defender.spdef
      defense = [defense, 1].max
      
      type_mod = Effectiveness.calculate(move.type, defender.types[0], defender.types[1])
      type_mult = type_mod.to_f / Effectiveness::NORMAL_EFFECTIVE.to_f
      
      stab = attacker.pbHasType?(move.type) ? 1.5 : 1.0
      
      damage = ((2 * attacker.level / 5.0 + 2) * move.power * atk / defense / 50 + 2)
      damage *= type_mult * stab
      
      max_damage = [max_damage, damage.to_i].max
    end
    
    max_damage
  end
  
  # Item Disruption Moves (Trick, Switcheroo, Knock Off, Thief, Covet)
  def score_item_disruption(move, user, target)
    score = 0
    
    # Trick / Switcheroo - swap items
    if [:TRICK, :SWITCHEROO].include?(move.id)
      # Can't swap if target has Sticky Hold
      return -50 if target.ability_id == :STICKYHOLD
      
      # Can't swap if we have no item to give
      return -30 if !user.item || user.item == :NONE
      
      # Swapping Choice items to non-Choice mons is great
      if [:CHOICEBAND, :CHOICESPECS, :CHOICESCARF].include?(user.item_id)
        score += 50  # Cripple their moveset
        # Even better if they rely on status moves
        status_count = target.moves.count { |m| m && m.statusMove? }
        score += status_count * 15
      end
      
      # Swapping Flame Orb / Toxic Orb
      if [:FLAMEORB, :TOXICORB].include?(user.item_id)
        return -50 if target.status != :NONE  # Already statused
        score += 40  # Inflict status
      end
      
      # Swapping Lagging Tail / Iron Ball to fast mons
      if [:LAGGINGTAIL, :IRONBALL].include?(user.item_id) && target.pbSpeed > 100
        score += 30  # Slow them down
      end
      
      # Getting a good item from target
      good_items = [:LEFTOVERS, :LIFEORB, :FOCUSSASH, :CHOICEBAND, :CHOICESPECS,
                    :CHOICESCARF, :ASSAULTVEST, :ROCKYHELMET, :EVIOLITE]
      if good_items.include?(target.item_id)
        score += 25  # We get a good item
      end
    end
    
    # Knock Off bonus (already handled in damage calc, but add strategic value)
    if move.id == :KNOCKOFF && target.item && target.item != :NONE
      # Removing key items is valuable
      valuable_items = [:LEFTOVERS, :EVIOLITE, :FOCUSSASH, :ASSAULTVEST,
                        :LIFEORB, :CHOICEBAND, :CHOICESPECS, :CHOICESCARF,
                        :ROCKYHELMET, :HEAVYDUTYBOOTS]
      if valuable_items.include?(target.item_id)
        score += 25
      else
        score += 10
      end
    end
    
    # Thief / Covet - steal item
    if [:THIEF, :COVET].include?(move.id)
      return -30 if user.item && user.item != :NONE  # We already have item
      return -30 if !target.item || target.item == :NONE  # Nothing to steal
      score += 20  # Steal their item
    end
    
    # Corrosive Gas - remove item from all adjacent
    if move.id == :CORROSIVEGAS
      score += 15 if target.item && target.item != :NONE
    end
    
    # Incinerate - destroy berry
    if move.id == :INCINERATE
      berry_items = AdvancedAI::Utilities::TYPE_RESIST_BERRIES.keys + 
                    [:SITRUSBERRY, :LUMBERRY, :AGUAVBERRY, :FIGYBERRY, :IAPAPABERRY,
                     :MAGOBERRY, :WIKIBERRY, :LIECHIBERRY, :PETAYABERRY, :SALACBERRY]
      if berry_items.include?(target.item_id)
        score += 20  # Destroy their berry
      end
    end
    
    score
  end
  
  #=============================================================================
  # MOODY PRESSURE - Prioritize attacking Moody Pokemon
  #=============================================================================
  def score_moody_pressure(move, user, target)
    return 0 unless target && target.ability_id == :MOODY
    
    bonus = 0
    
    # Prioritize attacking Moody Pokemon - don't let them accumulate boosts
    if move.damagingMove?
      bonus += 20  # Pressure Moody before they scale
      
      # Even higher if they already have boosts
      total_boosts = 0
      GameData::Stat.each_battle do |stat|
        stage = target.stages[stat.id] rescue 0
        total_boosts += stage if stage > 0
      end
      bonus += total_boosts * 8
    end
    
    # Haze/Clear Smog are excellent vs Moody
    if [:HAZE, :CLEARSMOG].include?(move.id)
      total_boosts = 0
      GameData::Stat.each_battle do |stat|
        stage = target.stages[stat.id] rescue 0
        total_boosts += stage if stage > 0
      end
      bonus += total_boosts * 15
    end
    
    # Taunt prevents Protect stalling for Moody boosts
    if move.id == :TAUNT
      bonus += 15
    end
    
    bonus
  end
  
  #=============================================================================
  # MIRROR HERB - Don't boost if opponent will copy
  #=============================================================================
  def score_setup_vs_mirror_herb(move, user, target)
    return 0 unless AdvancedAI.setup_move?(move.id)
    
    penalty = 0
    
    # Check if any opponent has Mirror Herb
    @battle.allOtherSideBattlers(user.index).each do |opp|
      next unless opp && !opp.fainted?
      
      if opp.item_id == :MIRRORHERB
        # They will copy our stat boosts!
        penalty -= 35  # Significant penalty
        
        # Worse if they're a physical attacker and we're boosting Atk
        if move.function_code.include?("Attack") && opp.attack > opp.spatk
          penalty -= 15
        end
      end
      
      # Also check Opportunist ability
      if opp.ability_id == :OPPORTUNIST
        penalty -= 25
      end
    end
    
    penalty
  end
  
  #=============================================================================
  # LUM BERRY TIMING - Don't status if they have Lum Berry
  #=============================================================================
  def score_status_vs_berry(move, user, target)
    return 0 unless move.statusMove?
    return 0 unless target
    
    # Status-inflicting function codes
    status_codes = ["Poison", "Paralyze", "Burn", "Sleep", "Freeze", "Confuse"]
    is_status_move = status_codes.any? { |code| move.function_code.include?(code) }
    
    # Direct status moves
    status_move_ids = [:WILLOWISP, :THUNDERWAVE, :TOXIC, :POISONPOWDER,
                       :STUNSPORE, :SLEEPPOWDER, :SPORE, :NUZZLE,
                       :GLARE, :HYPNOSIS, :DARKVOID, :YAWN, :CONFUSERAY]
    is_status_move ||= status_move_ids.include?(move.id)
    
    return 0 unless is_status_move
    
    penalty = 0
    
    # Lum Berry cures any status
    if target.item_id == :LUMBERRY
      penalty -= 60  # Status will be immediately cured - waste of turn!
    end
    
    # Chesto Berry specifically for Sleep
    if target.item_id == :CHESTOBERRY
      if move.function_code.include?("Sleep") || 
         [:SPORE, :SLEEPPOWDER, :HYPNOSIS, :DARKVOID, :YAWN].include?(move.id)
        penalty -= 50
      end
    end
    
    # Other status berries
    case target.item_id
    when :RAWSTBERRY
      penalty -= 40 if move.function_code.include?("Burn") || move.id == :WILLOWISP
    when :PECHABERRY
      penalty -= 40 if move.function_code.include?("Poison") || [:TOXIC, :POISONPOWDER].include?(move.id)
    when :CHERIBERRY
      penalty -= 40 if move.function_code.include?("Paralyze") || [:THUNDERWAVE, :STUNSPORE, :NUZZLE, :GLARE].include?(move.id)
    when :ASPEARBERRY
      penalty -= 40 if move.function_code.include?("Freeze")
    when :PERSIMBERRY
      penalty -= 40 if move.function_code.include?("Confuse") || move.id == :CONFUSERAY
    end
    
    # Own Tempo / Oblivious - confusion immunity
    if [:OWNTEMPO, :OBLIVIOUS].include?(target.ability_id)
      if move.function_code.include?("Confuse") || move.id == :CONFUSERAY || move.id == :SWAGGER
        penalty -= 50
      end
    end
    
    penalty
  end
  
  #=============================================================================
  # PROTECT / DETECT SCORING (Stall Strategies)
  #=============================================================================
  def score_protect_utility(move, user, target)
    return 0 unless AdvancedAI.protect_move?(move.id)
    return -100 if user.effects[PBEffects::ProtectRate] > 1  # Don't spam Protect
    
    score = 0
    
    # 1. Self-Recovery / Stat Boost Stall
    # Leftovers / Black Sludge / Ingrain / Aqua Ring / Poison Heal
    passive_recovery = (user.hasActiveItem?(:LEFTOVERS) || user.hasActiveItem?(:BLACKSLUDGE)) ||
                       user.effects[PBEffects::Ingrain] || user.effects[PBEffects::AquaRing] || 
                       (user.hasActiveAbility?(:POISONHEAL) && user.poisoned?) ||
                       (user.hasActiveAbility?([:DRYSKIN, :RAINDISH]) && [:Rain, :HeavyRain].include?(@battle.pbWeather)) ||
                       (user.hasActiveAbility?(:ICEBODY) && [:Hail, :Snow].include?(@battle.pbWeather)) ||
                       (@battle.field.terrain == :Grassy && user.battler.affectedByTerrain?)
                       
    if passive_recovery
      hp_percent = user.hp.to_f / user.totalhp
      if hp_percent < 0.9
        score += 40  # Heal up safely
        score += 20 if hp_percent < 0.5  # Critical heal
      end
    end

    # Speed Boost / Moody (Stall for stats)
    if user.hasActiveAbility?(:SPEEDBOOST) || user.hasActiveAbility?(:MOODY)
      score += 50  # Free boost
    end
    
    # Wish active? (Receive healing)
    wish_turns = user.effects[PBEffects::Wish] rescue 0
    if wish_turns.is_a?(Numeric) && wish_turns > 0
      score += 80  # Protect to receive Wish is standard play
    end

    # 2. Opponent Damage Stall
    # Poison / Burn / Leech Seed / Curse / Salt Cure
    if target
      leech_seed_val = (target.effects[PBEffects::LeechSeed] rescue -1)
      curse_val      = (target.effects[PBEffects::Curse] rescue false)
      salt_cure_val  = (defined?(PBEffects::SaltCure) ? (target.effects[PBEffects::SaltCure] rescue false) : false)
      passive_damage = target.poisoned? || target.burned? || 
                       (leech_seed_val.is_a?(Numeric) && leech_seed_val >= 0) ||
                       curse_val ||
                       salt_cure_val
                       
      if passive_damage
        score += 45  # Let them rot
        score += 20 if target.hp < target.totalhp * 0.25 # Finish them off
      end
      
      # Perish Song stalling
      perish_val = (target.effects[PBEffects::PerishSong] rescue 0)
      if perish_val.is_a?(Numeric) && perish_val > 0
        score += 60  # Stall out Perish turns
      end
    end
    
    # 3. Double Battle Scouting (Simple)
    if @battle.pbSideSize(0) > 1 && @battle.turnCount == 0
      score += 20  # Protect turn 1 in doubles is common
    end
    
    return score
  end

  #=============================================================================
  # PRANKSTER BONUS (Priority Status)
  #=============================================================================
  def score_prankster_bonus(move, user)
    return 0 unless user.hasActiveAbility?(:PRANKSTER)
    return 0 unless move.statusMove?
    
    score = 40  # Base bonus for having priority status
    
    # High value Prankster moves
    high_value_moves = [:THUNDERWAVE, :WILLOWISP, :TOXIC, :REFLECT, :LIGHTSCREEN, 
                        :AURORAVEIL, :TAILWIND, :TAUNT, :ENCORE, :DISABLE, :SUBSTITUTE,
                        :SPIKES, :STEALTHROCK, :TOXICSPIKES, :SPORE, :SLEEPPOWDER]
                        
    if high_value_moves.include?(move.id)
      score += 25  # Priority disable/hazards/screens are GODLY
    end
    
    return score
  end
  
  #=============================================================================
  # PIVOT UTILITY (Parting Shot, U-turn, etc.)
  #=============================================================================
  def score_pivot_utility(move, user, target, skill)
    return 0 unless AdvancedAI::PivotMoves::ALL_PIVOTS.include?(move.id)
    
    # Delegate to the specialized Pivot module
    # We add this score to the move's base damage/status score
    return AdvancedAI::PivotMoves.evaluate_pivot(@battle, user, move, target, skill)
  end
  
  #=============================================================================
  # MOVE REPETITION PENALTY (Prevents spamming the same move)
  #=============================================================================
  def score_move_repetition_penalty(move, user)
    score = 0
    
    # Check if this is the last move used
    last_move = user.battler.lastMoveUsed
    return 0 unless last_move  # No previous move
    
    # Penalize using the same move consecutively
    if move.id == last_move
      # Moves that SHOULD be spammed (setup sweepers, Protect stalling)
      spam_allowed = [:PROTECT, :DETECT, :KINGSSHIELD, :SPIKYSHIELD, :BANEFULBUNKER,
                      :OBSTRUCT, :SILKTRAP, :BURNINGBULWARK,  # Protect variants
                      :SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :QUIVERDANCE,  # Setup
                      :CALMMIND, :IRONDEFENSE, :AMNESIA, :AGILITY,  # More setup
                      :SHELLSMASH, :GEOMANCY, :VICTORYDANCE]  # Ultra setup
      
      # Also allow spamming moves that CHANGE effect on repeat (Rollout, Fury Cutter)
      escalating_moves = [:ROLLOUT, :ICEBALL, :FURYCUTTER, :ECHOEDVOICE]
      
      return 0 if spam_allowed.include?(move.id)
      return 0 if escalating_moves.include?(move.id)
      
      # Attacking moves: Small penalty (variety is good, but not critical)
      if move.damagingMove?
        score -= 15
        AdvancedAI.log("#{move.name}: -15 for repetition (attacking move)", "MoveSpam")
      end
      
      # Status moves: LARGE penalty (Taunt spam, Thunder Wave spam, etc.)
      if move.statusMove?
        score -= 40
        AdvancedAI.log("#{move.name}: -40 for repetition (status move spam prevention)", "MoveSpam")
      end
    end
    
    # Additional penalty if move was used multiple times recently (via Move Memory)
    if defined?(AdvancedAI::MoveMemory)
      frequency = AdvancedAI::MoveMemory.move_frequency(@battle, user, move.id)
      
      # If used 2+ times, add stacking penalty
      if frequency >= 3
        score -= 20  # Used 3+ times = major spam
        AdvancedAI.log("#{move.name}: -20 for frequency spam (used #{frequency} times)", "MoveSpam")
      elsif frequency >= 2
        score -= 10  # Used 2 times = minor spam
        AdvancedAI.log("#{move.name}: -10 for repeated use (used #{frequency} times)", "MoveSpam")
      end
    end
    
    return score
  end
  
  #=============================================================================
  # PRIORITY TIER SYSTEM - Role-Based Status Move Selection
  #=============================================================================
  def check_priority_tier_moves(move, user, target, skill)
    # Only status moves get priority
    return PriorityMoveResult.new unless move.statusMove?
    
    hp_percent = user.hp.to_f / user.totalhp
    turn = @battle.turnCount
    
    # === TIER 1: AUTO-SELECT (1000+) ===
    # These moves bypass normal scoring and are used immediately
    
    # 1. HAZARDS (Turn 1-3, healthy user)
    if [:STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB].include?(move.id)
      opponent_side = target.pbOwnSide
      
      # Stealth Rock - highest priority hazard
      if move.id == :STEALTHROCK && !opponent_side.effects[PBEffects::StealthRock]
        if turn <= 3 && hp_percent > 0.7
          return PriorityMoveResult.new(auto_select: true, priority_boost: 100)
        elsif turn <= 5 && hp_percent > 0.6
          return PriorityMoveResult.new(priority_boost: 250)
        end
      end
      
      # Spikes - layer 1 is critical
      if move.id == :SPIKES && opponent_side.effects[PBEffects::Spikes] < 3
        layers = opponent_side.effects[PBEffects::Spikes]
        if layers == 0 && turn <= 2 && hp_percent > 0.7
          return PriorityMoveResult.new(auto_select: true, priority_boost: 50)
        elsif layers < 3 && turn <= 4 && hp_percent > 0.6
          return PriorityMoveResult.new(priority_boost: 200)
        end
      end
      
      # Toxic Spikes
      if move.id == :TOXICSPIKES && opponent_side.effects[PBEffects::ToxicSpikes] < 2
        if opponent_side.effects[PBEffects::ToxicSpikes] == 0 && turn <= 3 && hp_percent > 0.7
          return PriorityMoveResult.new(auto_select: true, priority_boost: 40)
        end
      end
      
      # Sticky Web
      if move.id == :STICKYWEB && !opponent_side.effects[PBEffects::StickyWeb]
        if turn <= 2 && hp_percent > 0.7
          return PriorityMoveResult.new(auto_select: true, priority_boost: 60)
        end
      end
    end
    
    # 2. RECOVERY (Critical HP)
    if move.function_code.start_with?("HealUser")
      if hp_percent < 0.35
        # Check if we're not at immediate OHKO risk
        incoming_damage_estimate = 0
        if target && target.moves
          target.moves.each do |opp_move|
            next unless opp_move && opp_move.damagingMove?
            rough_dmg = calculate_rough_damage(opp_move, target, user) rescue 0
            incoming_damage_estimate = [incoming_damage_estimate, rough_dmg].max
          end
        end
        
        # If we won't get OHKO'd, heal is critical
        if incoming_damage_estimate < user.hp * 0.9
          return PriorityMoveResult.new(auto_select: true, priority_boost: 200)
        end
      elsif hp_percent < 0.5
        return PriorityMoveResult.new(priority_boost: 200)
      elsif hp_percent < 0.7
        return PriorityMoveResult.new(priority_boost: 120)
      end
    end
    
    # 3. SCREENS (Turn 1-2, healthy user)
    if [:REFLECT, :LIGHTSCREEN, :AURORAVEIL].include?(move.id)
      user_side = user.pbOwnSide
      
      # Reflect
      if move.id == :REFLECT && user_side.effects[PBEffects::Reflect] == 0
        if turn <= 2 && hp_percent > 0.6
          # Check if opponent has physical moves
          has_physical_threat = target.moves.any? { |m| m && m.physicalMove? }
          return PriorityMoveResult.new(auto_select: true, priority_boost: 80) if has_physical_threat
        elsif turn <= 4 && hp_percent > 0.5
          return PriorityMoveResult.new(priority_boost: 180)
        end
      end
      
      # Light Screen
      if move.id == :LIGHTSCREEN && user_side.effects[PBEffects::LightScreen] == 0
        if turn <= 2 && hp_percent > 0.6
          # Check if opponent has special moves
          has_special_threat = target.moves.any? { |m| m && m.specialMove? }
          return PriorityMoveResult.new(auto_select: true, priority_boost: 80) if has_special_threat
        elsif turn <= 4 && hp_percent > 0.5
          return PriorityMoveResult.new(priority_boost: 180)
        end
      end
      
      # Aurora Veil (requires Hail/Snow)
      if move.id == :AURORAVEIL && user_side.effects[PBEffects::AuroraVeil] == 0
        if [:Hail, :Snow].include?(@battle.pbWeather) && turn <= 2 && hp_percent > 0.6
          return PriorityMoveResult.new(auto_select: true, priority_boost: 90)
        end
      end
    end
    
    # === TIER 2: HIGH PRIORITY BOOST (100-300) ===
    # These moves get massive score boosts to compete with damage moves
    
    # 4. SETUP MOVES (when safe)
    if AdvancedAI.setup_move?(move.id) || move.function_code.start_with?("RaiseUser")
      if is_safe_to_setup?(user, target)
        # Determine setup value based on move
        setup_value = 200  # Base high priority
        
        # Extra value for sweep-enabling moves
        if [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :QUIVERDANCE, :SHELLSMASH].include?(move.id)
          setup_value = 250  # Sweep enablers
        end
        
        # Bonus if user is healthy and can sweep
        if hp_percent > 0.7
          setup_value += 50
        end
        
        return PriorityMoveResult.new(priority_boost: setup_value)
      end
    end
    
    # 5. STATUS INFLICTION (tactical value)
    if [:THUNDERWAVE, :WILLOWISP, :TOXIC, :SLEEPPOWDER, :SPORE].include?(move.id)
      if target.status == :NONE
        # Thunder Wave - cripple faster threats
        if move.id == :THUNDERWAVE && target.pbSpeed > user.pbSpeed
          return PriorityMoveResult.new(priority_boost: 180)
        end
        
        # Will-O-Wisp - nerf physical attackers
        if move.id == :WILLOWISP && target.attack > target.spatk
          return PriorityMoveResult.new(priority_boost: 180)
        end
        
        # Toxic - destroy walls
        if move.id == :TOXIC
          if target.defense + target.spdef > 200
            return PriorityMoveResult.new(priority_boost: 200)
          else
            return PriorityMoveResult.new(priority_boost: 140)
          end
        end
        
        # Sleep - ultimate control
        if [:SLEEPPOWDER, :SPORE].include?(move.id)
          return PriorityMoveResult.new(priority_boost: 220)
        end
      end
    end
    
    # 6. TAILWIND (speed control)
    if move.id == :TAILWIND && user.pbOwnSide.effects[PBEffects::Tailwind] == 0
      if turn <= 3
        return PriorityMoveResult.new(priority_boost: 160)
      end
    end
    
    # Default: no priority
    return PriorityMoveResult.new
  end
  
  #=============================================================================
  # ROLE SYNERGY SCORING
  #=============================================================================
  # Adjusts move scores based on the user's detected role.
  # Sweepers prefer setup/priority, Walls prefer recovery/status, etc.
  # This ensures each role actually PLAYS like its archetype.
  #=============================================================================
  def score_role_synergy(move, user, target, skill)
    return 0 unless user && target && move
    return 0 unless skill >= 55  # Only for mid+ skill trainers
    
    # Get role from the full detection system
    primary_role, secondary_role = AdvancedAI.detect_roles(user)
    return 0 if primary_role == :balanced && secondary_role.nil?
    
    score = 0
    move_id = move.id
    
    # === SWEEPER: Setup + Priority + Coverage ===
    if primary_role == :sweeper || secondary_role == :sweeper
      # Sweepers love setup moves (Swords Dance, Dragon Dance, Nasty Plot)
      if AdvancedAI.setup_move?(move_id)
        score += 20
        # Even more valuable early game (not yet boosted)
        user_boosts = user.stages.values.count { |s| s > 0 }
        score += 15 if user_boosts == 0 && user.hp > user.totalhp * 0.7
      end
      
      # Priority moves are the sweeper's insurance policy
      if AdvancedAI.priority_move?(move_id) && move.damagingMove?
        score += 15
        # Extra value when low HP (clean up before going down)
        score += 10 if user.hp < user.totalhp * 0.4
      end
      
      # Coverage moves (super-effective) are key for sweeping
      if move.damagingMove?
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        score += 10 if Effectiveness.super_effective?(type_mod)
      end
      
      # Sweepers should avoid non-damaging utility (except setup)
      if move.statusMove? && !AdvancedAI.setup_move?(move_id)
        score -= 10 unless [:SUBSTITUTE, :TAUNT].include?(move_id)
      end
    end
    
    # === WALL: Recovery + Status + Phazing ===
    if primary_role == :wall || secondary_role == :wall
      # Walls need recovery to do their job
      if AdvancedAI.healing_move?(move_id)
        score += 20
        hp_percent = user.hp.to_f / user.totalhp
        score += 15 if hp_percent < 0.65  # More urgent when damaged
      end
      
      # Status moves are the wall's way to threaten
      if AdvancedAI.status_move?(move_id) || [:TOXIC, :WILLOWISP, :THUNDERWAVE].include?(move_id)
        score += 15 if target.status == :NONE
      end
      
      # Phazing racks up hazard damage
      if [:WHIRLWIND, :ROAR, :DRAGONTAIL, :CIRCLETHROW].include?(move_id)
        score += 15
      end
      
      # Walls don't benefit much from setup (except Iron Defense / Calm Mind on some)
      if AdvancedAI.setup_move?(move_id)
        setup_data = AdvancedAI::MoveCategories.get_setup_data(move_id)
        unless setup_data && (setup_data[:stat] == :DEFENSE || setup_data[:stat] == :SPECIAL_DEFENSE)
          score -= 10  # Offensive setup is suboptimal for walls
        end
      end
    end
    
    # === TANK: Bulky Offense — reliable STAB + Recovery ===
    if primary_role == :tank || secondary_role == :tank
      # Tanks want strong reliable STAB moves
      if move.damagingMove? && user.pbHasType?(move.type)
        score += 10  # STAB reliability matters for tanks
        score += 10 if move.power >= 80  # Prefer solid power
      end
      
      # Tanks also value recovery (they have the bulk to use it)
      if AdvancedAI.healing_move?(move_id)
        score += 15
        hp_percent = user.hp.to_f / user.totalhp
        score += 10 if hp_percent < 0.55
      end
      
      # Coverage for tanks
      if move.damagingMove?
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        score += 10 if Effectiveness.super_effective?(type_mod)
      end
    end
    
    # === SUPPORT: Screens + Hazards + Status ===
    if primary_role == :support || secondary_role == :support
      # Screens are high priority for support
      if AdvancedAI.screen_move?(move_id)
        score += 25
        # Check if screen is already active (don't re-set)
        own_side = user.index.even? ? @battle.sides[0] : @battle.sides[1]
        if move_id == :REFLECT && own_side.effects[PBEffects::Reflect] > 0
          score -= 40  # Already active
        elsif move_id == :LIGHTSCREEN && own_side.effects[PBEffects::LightScreen] > 0
          score -= 40  # Already active
        elsif move_id == :AURORAVEIL && own_side.effects[PBEffects::AuroraVeil] > 0
          score -= 40  # Already active
        end
      end
      
      # Hazards are the support's primary job
      if AdvancedAI.hazard_move?(move_id)
        score += 25
        # Boost early game, penalty if already set
        score += 15 if @battle.turnCount <= 3
        opponent_side = user.index.even? ? @battle.sides[1] : @battle.sides[0]
        if move_id == :STEALTHROCK && opponent_side.effects[PBEffects::StealthRock]
          score -= 50  # Already up — DON'T use again
        end
        if [:SPIKES, :TOXICSPIKES].include?(move_id)
          max_layers = move_id == :SPIKES ? 3 : 2
          current = move_id == :SPIKES ? opponent_side.effects[PBEffects::Spikes] : opponent_side.effects[PBEffects::ToxicSpikes]
          score -= 50 if current >= max_layers  # Maxed out
        end
      end
      
      # Status infliction is key for support
      if [:TOXIC, :WILLOWISP, :THUNDERWAVE, :TAUNT, :ENCORE].include?(move_id)
        score += 20 if target.status == :NONE || [:TAUNT, :ENCORE].include?(move_id)
      end
      
      # Healing support (Wish, Heal Bell, Aromatherapy)
      if [:WISH, :HEALBELL, :AROMATHERAPY].include?(move_id)
        score += 20
      end
      
      # Support mons should deprioritize weak attacks once their job is done
      if move.damagingMove? && move.power < 70
        score -= 10  # Weak attacks are not the support's focus
      end
    end
    
    # === WALLBREAKER: Raw Power + Coverage ===
    if primary_role == :wallbreaker || secondary_role == :wallbreaker
      if move.damagingMove?
        # Wallbreakers want maximum damage output
        score += 15 if move.power >= 100
        score += 10 if move.power >= 80 && move.power < 100
        
        # Coverage is king for wallbreakers
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        score += 15 if Effectiveness.super_effective?(type_mod)
        
        # STAB bonus stacks
        score += 10 if user.pbHasType?(move.type)
        
        # Mixed coverage: wallbreakers should pick the move that hits harder
        if move.physicalMove? && user.attack > user.spatk
          score += 5  # Using better offensive stat
        elsif move.specialMove? && user.spatk > user.attack
          score += 5
        end
      end
      
      # Wallbreakers mostly ignore utility
      if move.statusMove? && ![:SWORDSDANCE, :NASTYPLOT, :CLOSECOMBAT].include?(move_id)
        score -= 15 unless AdvancedAI.setup_move?(move_id)  # One setup move is OK
      end
    end
    
    # === PIVOT: U-turn/Volt Switch optimization ===
    if primary_role == :pivot || secondary_role == :pivot
      if AdvancedAI.pivot_move?(move_id)
        # Pivots should use their pivot moves in bad matchups
        has_type_disadvantage = false
        target.moves.each do |t_move|
          next unless t_move && t_move.damagingMove? && t_move.type
          type_mod = Effectiveness.calculate(t_move.type, *user.pbTypes(true))
          has_type_disadvantage = true if Effectiveness.super_effective?(type_mod)
        end
        score += 25 if has_type_disadvantage  # GET OUT with momentum
        score += 10 unless has_type_disadvantage  # Still good for scouting
      end
      
      # Pivots should avoid committing to non-pivot moves in bad matchups
      if !AdvancedAI.pivot_move?(move_id) && move.damagingMove?
        has_type_disadvantage = false
        target.moves.each do |t_move|
          next unless t_move && t_move.damagingMove? && t_move.type
          type_mod = Effectiveness.calculate(t_move.type, *user.pbTypes(true))
          has_type_disadvantage = true if Effectiveness.super_effective?(type_mod)
        end
        score -= 10 if has_type_disadvantage  # Should be pivoting out, not attacking
      end
    end
    
    # === LEAD: Turn 1 Hazards + Taunt ===
    if primary_role == :lead || secondary_role == :lead
      if @battle.turnCount <= 1
        # Turn 1: Leads should set up hazards ASAP
        if AdvancedAI.hazard_move?(move_id)
          score += 30  # Top priority on turn 1
          # Stealth Rock is the most universally valuable
          score += 10 if move_id == :STEALTHROCK
        end
        
        # Taunt opposing leads/supports
        if move_id == :TAUNT
          score += 25
          opp_role, _ = AdvancedAI.detect_roles(target)
          score += 15 if [:lead, :support, :wall, :stall].include?(opp_role)
        end
        
        # Fake Out for free chip + flinch
        score += 20 if move_id == :FAKEOUT
      end
      
      # After hazards are set, leads should pivot out or attack
      if @battle.turnCount > 2
        opponent_side = user.index.even? ? @battle.sides[1] : @battle.sides[0]
        hazards_set = opponent_side.effects[PBEffects::StealthRock] ||
                      opponent_side.effects[PBEffects::Spikes] > 0 ||
                      opponent_side.effects[PBEffects::ToxicSpikes] > 0
        if hazards_set
          # Job done — prefer pivot moves to bring in a sweeper
          score += 20 if AdvancedAI.pivot_move?(move_id)
          # Hazard moves become useless (already set)
          score -= 20 if AdvancedAI.hazard_move?(move_id)
        end
      end
    end
    
    return score
  end
  
  #=============================================================================
  # STALL SYNERGY SCORING
  #=============================================================================
  # Boosts stall-relevant moves when the user has a stall moveset.
  # This prevents the AI from seeing stall moves as "terrible" and wanting
  # to switch endlessly (Blissey <-> Toxapex loop).
  #=============================================================================
  def score_stall_synergy(move, user, target)
    return 0 unless user && target && move
    
    # Only activate if user has a stall moveset
    return 0 unless AdvancedAI.has_stall_moveset?(user)
    
    stall_data = AdvancedAI.get_stall_data(move.id)
    return 0 unless stall_data
    
    score = 0
    
    # === BASE STALL IDENTITY BONUS ===
    # Stall moves ARE the gameplan — don't penalize them for being "low damage"
    score += 30  # Baseline: stall moves are always valuable for stall mons
    
    case stall_data[:role]
    when :passive_damage
      # === TOXIC / LEECH SEED / WILL-O-WISP ===
      # These are the WIN CONDITION for stall teams
      if target.status == :NONE
        score += 40  # Applying status IS the stall gameplan
        
        # Extra value if user has Protect (can stall out damage)
        has_protect = user.battler.moves.any? { |m| m && AdvancedAI.protect_move?(m.id) }
        score += 25 if has_protect
        
        # Extra value if user has recovery (can outlast)
        has_recovery = user.battler.moves.any? { |m| m && AdvancedAI.healing_move?(m.id) }
        score += 20 if has_recovery
      end
      
      # Leech Seed specific: extra value for self-healing component
      if move.id == :LEECHSEED
        leech_seed_val = (target.effects[PBEffects::LeechSeed] rescue -1)
        if leech_seed_val.is_a?(Numeric) && leech_seed_val < 0
          # Not yet seeded — high priority
          score += 35
          # Bonus vs bulky targets (more HP to drain)
          score += 20 if target.totalhp > 300
        end
      end
      
    when :recovery
      # === RECOVER / SOFTBOILED / WISH / ROOST ===
      # Enhanced recovery scoring for stall mons
      hp_percent = user.hp.to_f / user.totalhp
      
      # Stall mons should recover EARLIER than offensive mons
      if hp_percent < 0.75
        score += 30  # Stall mons want to stay near full HP
      end
      
      # Extra value when opponent has passive damage ticking
      leech_seed_val = (target.effects[PBEffects::LeechSeed] rescue -1)
      target_has_passive = target.poisoned? || target.burned? ||
                           (leech_seed_val.is_a?(Numeric) && leech_seed_val >= 0)
      if target_has_passive
        score += 35  # We're winning the long game, just stay alive
      end
      
      # Wish-specific: plan ahead
      if move.id == :WISH
        wish_turns = user.effects[PBEffects::Wish] rescue 0
        if wish_turns.is_a?(Numeric) && wish_turns == 0 && hp_percent < 0.85
          score += 25  # Set up future healing proactively
        end
      end
      
    when :protection
      # === PROTECT / BANEFUL BUNKER / etc. ===
      # Already handled well by score_protect_utility, but add stall identity bonus
      leech_seed_val = (target.effects[PBEffects::LeechSeed] rescue -1)
      target_has_passive = target.poisoned? || target.burned? ||
                           (leech_seed_val.is_a?(Numeric) && leech_seed_val >= 0)
      if target_has_passive
        score += 20  # Protect is the core of the Toxic stall loop
      end
      
    when :utility
      # === SCALD / KNOCK OFF / HAZE / PHAZE ===
      if move.id == :SCALD && target.status == :NONE && target.attack > target.spatk
        score += 25  # Scald burn chance is the stall gameplan vs physical mons
      end
      
      if [:WHIRLWIND, :ROAR].include?(move.id)
        # Phazing is key for stall — rack up hazard damage
        opponent_side = user.index.even? ? @battle.sides[1] : @battle.sides[0]
        if opponent_side.effects[PBEffects::StealthRock] ||
           opponent_side.effects[PBEffects::Spikes] > 0
          score += 30  # Phaze into hazards
        end
        # Phaze setup sweepers
        target_boosts = target.stages.values.count { |s| s > 0 }
        score += 25 if target_boosts >= 2
      end
      
    when :hazard
      # Hazards already have good scoring, just add stall identity bonus
      score += 15  # Stall teams rely on chip damage
    end
    
    return score
  end

  #=============================================================================
  # TACTICAL ENHANCEMENTS (#6-#17)
  #=============================================================================

  # #6: Trapping moves in singles (Mean Look, Block, Spirit Shackle, etc.)
  TRAPPING_MOVES = [
    :MEANLOOK, :BLOCK, :SPIRITSHACKLE, :ANCHORSHOT, :JAWLOCK,
    :THOUSANDWAVES, :OCTOLOCK, :BIND, :WRAP,
    :FIRESPIN, :WHIRLPOOL, :SANDTOMB, :CLAMP, :MAGMASTORM,
    :INFESTATION, :THUNDERCAGE, :SNAPTRAP
  ]

  def score_trapping_moves(move, user, target, skill)
    return 0 unless target
    return 0 unless TRAPPING_MOVES.include?(move.id)
    score = 0

    # Don't trap if target is Ghost (can escape Mean Look/Block)
    if [:MEANLOOK, :BLOCK].include?(move.id)
      target_types = target.respond_to?(:pbTypes) ? target.pbTypes : [target.type1, target.type2].compact rescue [:NORMAL]
      return -30 if target_types.include?(:GHOST)
    end

    # High value: trap a bad matchup for the opponent
    incoming = estimate_incoming_damage(user, target)
    if incoming < user.totalhp * 0.2
      score += 40  # They can't break us, we win this 1v1
      AdvancedAI.log("  Trapping #{target.name}: +40 (favorable)", "Tactic")
    elsif incoming < user.totalhp * 0.35
      score += 20
    elsif incoming > user.totalhp * 0.5
      score -= 20  # Don't trap what kills us
    end

    # Trap + Toxic/Perish Song = great combo
    user.moves.each do |m|
      next unless m
      score += 15 if m.id == :TOXIC
      score += 10 if m.id == :PERISHSONG
    end if user.respond_to?(:moves)

    score += 10 if skill >= 80
    score
  end

  # #8: Choice pre-lock logic — pick the best move to lock into
  def score_choice_prelock(move, user, target)
    return 0 unless target
    user_battler = user.respond_to?(:battler) ? user.battler : user
    item = user_battler.item_id rescue nil
    return 0 unless [:CHOICEBAND, :CHOICESPECS, :CHOICESCARF].include?(item)

    # Only matters if not yet locked
    last = user_battler.lastMoveUsed rescue nil
    return 0 if last  # Already locked

    score = 0

    # Pivot moves = premium on Choice (maintain flexibility)
    if AdvancedAI.pivot_move?(move.id)
      score += 25
      AdvancedAI.log("  Choice pre-lock: +25 pivot", "Tactic")
    end

    # Lock into broadest-coverage damaging move
    if move.damagingMove?
      neutral_or_better = 0
      @battle.allOtherSideBattlers(user.index).each do |opp|
        next if !opp || opp.fainted?
        opp_types = opp.respond_to?(:pbTypes) ? opp.pbTypes : [opp.type1, opp.type2].compact rescue [:NORMAL]
        eff = 1.0
        opp_types.each { |t| eff *= Effectiveness.calculate_one(move.type, t) rescue 1.0 }
        neutral_or_better += 1 if eff >= 1.0
      end
      score += 15 if neutral_or_better >= 2
    end

    # Status on Choice = locked into uselessness
    if move.category == :Status && !AdvancedAI.pivot_move?(move.id)
      score -= 40
      AdvancedAI.log("  Choice pre-lock: -40 (status on Choice)", "Tactic")
    end

    score
  end

  # #9: Cleric urgency scaling (Heal Bell / Aromatherapy)
  def score_cleric_urgency(move, user)
    return 0 unless [:HEALBELL, :AROMATHERAPY].include?(move.id)
    score = 0
    statused_count = 0
    critical_statused = 0

    party = @battle.pbParty(user.index)
    party.each do |pkmn|
      next if !pkmn || pkmn.fainted? || pkmn.egg?
      if pkmn.status != :NONE
        statused_count += 1
        critical_statused += 1 if pkmn.attack >= 100 || pkmn.spatk >= 100 || pkmn.speed >= 100
      end
    end

    if statused_count == 0
      score -= 80  # Nobody needs cleansing
    elsif statused_count == 1
      score += 15
    elsif statused_count == 2
      score += 35
    else
      score += 55  # Multiple teammates cured
    end
    score += critical_statused * 15

    AdvancedAI.log("  Cleric: #{statused_count} statused, bonus=#{score}", "Tactic") if statused_count > 0
    score
  end

  # #10a: User Destiny Bond — proactive at low HP
  def score_user_destiny_bond(move, user, target)
    return 0 unless move.id == :DESTINYBOND
    return 0 unless target
    score = 0

    user_hp_pct = user.hp.to_f / user.totalhp
    user_spd = user.respond_to?(:pbSpeed) ? user.pbSpeed : (user.speed rescue 80)
    target_spd = target.respond_to?(:pbSpeed) ? target.pbSpeed : (target.speed rescue 80)

    if user_hp_pct <= 0.25
      score += 60  # About to die — take them with us
      score += 20 if user_spd < target_spd   # Slower = they attack into DB
      score -= 10 if user_spd >= target_spd   # Faster = DB fades before they move
    elsif user_hp_pct <= 0.40
      score += 30
    else
      score -= 40  # Too healthy
    end

    # High value target (boosted threat)
    target_boosts = target.stages.values.sum rescue 0
    score += 15 if target_boosts >= 3

    AdvancedAI.log("  User Destiny Bond: #{score} (HP=#{(user_hp_pct*100).to_i}%)", "Tactic") if score > 0
    score
  end

  # #10b: Ghost-type Curse (sacrifice 50% HP for 1/4 chip per turn)
  def score_ghost_curse(move, user, target)
    return 0 unless move.id == :CURSE
    return 0 unless target

    user_types = user.respond_to?(:pbTypes) ? user.pbTypes : [user.type1, user.type2].compact rescue [:NORMAL]
    return 0 unless user_types.include?(:GHOST)  # Only Ghost Curse is different

    score = 0
    user_hp_pct = user.hp.to_f / user.totalhp

    # Need >50% HP to survive the cost
    if user_hp_pct <= 0.3
      score -= 50
    elsif user_hp_pct <= 0.55
      score += 10
    else
      score += 40
    end

    # Great against recovery users (25% chip overwhelms most healing)
    if AdvancedAI.has_healing_move?(@battle, target)
      score += 20
    end

    # Excellent against stall/walls
    target_roles = AdvancedAI.detect_roles(target) rescue [:balanced]
    if target_roles.include?(:stall) || target_roles.include?(:wall)
      score += 25
      AdvancedAI.log("  Ghost Curse vs stall: +25", "Tactic")
    end

    # Penalize if target can pivot out easily
    target_memory = AdvancedAI.get_memory(@battle, target) rescue nil
    if target_memory && target_memory[:moves]
      score -= 20 if target_memory[:moves].any? { |m| AdvancedAI.pivot_move?(m) }
    end

    score
  end

  # #11: Counter / Mirror Coat intelligence
  def score_counter_mirror_coat(move, user, target)
    return 0 unless [:COUNTER, :MIRRORCOAT, :METALBURST].include?(move.id)
    return 0 unless target
    score = 0

    # Must survive the incoming hit
    incoming = estimate_incoming_damage(user, target)
    if incoming >= user.hp
      return -60  # Dead before reflecting
    end

    # Predict physical vs special
    predicted_move = AdvancedAI.predict_next_move(@battle, target) rescue nil
    if predicted_move
      pred_data = GameData::Move.try_get(predicted_move)
      if pred_data
        if move.id == :COUNTER && pred_data.physicalMove?
          score += 50
          AdvancedAI.log("  Counter vs predicted physical: +50", "Tactic")
        elsif move.id == :MIRRORCOAT && pred_data.specialMove?
          score += 50
          AdvancedAI.log("  Mirror Coat vs predicted special: +50", "Tactic")
        elsif move.id == :METALBURST && pred_data.power > 0
          score += 35  # Metal Burst reflects both
        elsif move.id == :COUNTER && !pred_data.physicalMove?
          score -= 40  # Wrong type
        elsif move.id == :MIRRORCOAT && !pred_data.specialMove?
          score -= 40
        end
      end
    else
      # Heuristic: physical attacker → Counter, special → Mirror Coat
      if move.id == :COUNTER && target.attack > target.spatk
        score += 25
      elsif move.id == :MIRRORCOAT && target.spatk > target.attack
        score += 25
      elsif move.id == :METALBURST
        score += 20  # Works against either
      end
    end

    score += 10 if user.hp > user.totalhp * 0.7  # More HP = bigger reflect
    score
  end

  # #14: Disable target optimization
  def score_disable_optimization(move, user, target)
    return 0 unless move.id == :DISABLE
    return 0 unless target
    score = 0

    last_used = target.respond_to?(:lastMoveUsed) ? target.lastMoveUsed : nil
    last_used ||= AdvancedAI.last_move(@battle, target) rescue nil
    return -30 unless last_used  # Can't Disable without target using a move

    last_data = GameData::Move.try_get(last_used)
    return -20 unless last_data

    if last_data.power >= 100
      score += 40  # Disabling a nuke
    elsif last_data.power >= 70
      score += 25
    elsif AdvancedAI.setup_move?(last_used)
      score += 35
    elsif AdvancedAI.healing_move?(last_used)
      score += 30
    elsif last_data.category == :Status
      score += 15
    else
      score += 10
    end

    # More impactful with limited moveset
    memory = AdvancedAI.get_memory(@battle, target) rescue nil
    if memory && memory[:moves] && memory[:moves].length <= 2
      score += 15
    end

    AdvancedAI.log("  Disable #{last_used}: +#{score}", "Tactic") if score > 0
    score
  end

  # #15: Healing Wish / Lunar Dance improved teammate evaluation
  def score_healing_wish_target(move, user)
    return 0 unless [:HEALINGWISH, :LUNARDANCE].include?(move.id)

    user_hp_pct = user.hp.to_f / user.totalhp
    return 0 if user_hp_pct > 0.45  # Already handled in Special_Moves

    best_value = 0
    party = @battle.pbParty(user.index)
    party.each do |pkmn|
      next if !pkmn || pkmn.fainted? || pkmn.egg?
      next if pkmn == (user.respond_to?(:pokemon) ? user.pokemon : user)

      hp_pct = pkmn.hp.to_f / pkmn.totalhp
      next if hp_pct > 0.8

      value = 0
      bst = pkmn.attack + pkmn.spatk + pkmn.speed
      value += ((1.0 - hp_pct) * 30).to_i
      value += 20 if bst >= 300
      value += 15 if pkmn.status != :NONE
      value += 10 if move.id == :LUNARDANCE && pkmn.moves.any? { |m| m && m.pp < m.total_pp / 2 }

      best_value = value if value > best_value
    end

    AdvancedAI.log("  #{move.name} teammate value: #{best_value}", "Tactic") if best_value > 0
    best_value.to_i
  end

  # #16: Mixed attacker modeling — exploit weaker defensive stat
  def score_mixed_attacker(move, user, target)
    return 0 unless target && move.damagingMove?
    score = 0

    if move.physicalMove? && target.spdef < target.defense * 0.75
      score -= 5  # A special move would hit harder
    elsif move.specialMove? && target.defense < target.spdef * 0.75
      score -= 5  # A physical move would hit harder
    end

    # Psyshock/Psystrike/Secret Sword hit the target's Defense with special attack
    if [:PSYSHOCK, :PSYSTRIKE, :SECRETSWORD].include?(move.id)
      if target.defense < target.spdef
        score += 15  # Exploiting lower Def
        AdvancedAI.log("  Mixed: #{move.name} exploits lower Def (+15)", "Tactic")
      end
    end

    score
  end

  # #17: Transform / Ditto handling
  def score_transform_ditto(move, user, target)
    return 0 unless move.id == :TRANSFORM
    return 0 unless target
    score = 0

    target_bst = (target.attack + target.defense + target.spatk + target.spdef + target.speed) rescue 300
    score += 30 if target_bst >= 500
    score += 15 if target_bst >= 400 && target_bst < 500

    # Copy boosts = huge value
    target_boosts = target.stages.values.sum rescue 0
    if target_boosts >= 3
      score += 40
      AdvancedAI.log("  Transform copies +#{target_boosts} boosts! (+40)", "Tactic")
    elsif target_boosts >= 1
      score += 15
    elsif target_boosts < 0
      score -= 20
    end

    score -= 10 if target.moves.count { |m| m && m.power > 0 } <= 2
    score
  end
end

AdvancedAI.log("Move Scorer loaded", "Scorer")
AdvancedAI.log("  - Moody pressure logic", "Scorer")
AdvancedAI.log("  - Mirror Herb awareness", "Scorer")
AdvancedAI.log("  - Lum Berry timing", "Scorer")

### FILE: Disruption_Moves.rb ###
#===============================================================================
# Advanced AI System - Disruption Move Intelligence
# Handles Taunt, Encore, Knock Off, Trick, and other disruption strategies
#===============================================================================

class Battle::AI
  # ============================================================================
  # TAUNT STRATEGY
  # ============================================================================
  
  alias disruption_pbRegisterMove pbRegisterMove
  def pbRegisterMove(user, move)
    score = disruption_pbRegisterMove(user, move)
    
    return score unless user && move
    
    targets = @battle.allOtherSideBattlers(user.index)
    targets.each do |target|
      next unless target && !target.fainted?
      
      # TAUNT: Block setup/support moves
      if move.id == :TAUNT
        score += evaluate_taunt_value(user, target)
      end
      
      # ENCORE: Lock into last move
      if move.id == :ENCORE
        score += evaluate_encore_value(user, target)
      end
      
      # KNOCK OFF: Remove item + damage
      if move.id == :KNOCKOFF
        score += evaluate_knockoff_value(user, target)
      end
      
      # TRICK/SWITCHEROO: Swap items
      if [:TRICK, :SWITCHEROO].include?(move.id)
        score += evaluate_trick_value(user, target)
      end
    end
    
    return score
  end
  
  # ============================================================================
  # TAUNT EVALUATION
  # ============================================================================
  
  def evaluate_taunt_value(user, target)
    score = 0
    
    # Don't use if target already taunted
    if target.effects[PBEffects::Taunt] > 0
      AdvancedAI.log("  Taunt blocked: Already taunted", "Disruption")
      return -90
    end
    
    # Count status/support moves on target
    status_moves = target.moves.count { |m| m && m.statusMove? }
    
    if status_moves == 0
      score -= 50  # Useless
      AdvancedAI.log("  Taunt: -50 (no status moves)", "Disruption")
      return score
    end
    
    # HIGH VALUE: Setup sweepers
    setup_moves = [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :QUIVERDANCE, :CALMMIND,
                   :SHELLSMASH, :COIL, :BULKUP, :AGILITY, :ROCKPOLISH]
    has_setup = target.moves.any? { |m| m && setup_moves.include?(m.id) }
    
    if has_setup
      score += 60
      AdvancedAI.log("  Taunt vs setup: +60 (blocks sweep)", "Disruption")
      
      # URGENT if they're setting up right now
      if target.stages.values.any? { |stage| stage > 0 }
        score += 40
        AdvancedAI.log("  Already boosted: +40 (stop snowball)", "Disruption")
      end
    end
    
    # HIGH VALUE: Walls (recovery/support)
    recovery_moves = [:RECOVER, :ROOST, :SOFTBOILED, :WISH, :REST, :SLACKOFF, 
                     :MOONLIGHT, :SYNTHESIS, :MORNINGSUN]
    has_recovery = target.moves.any? { |m| m && recovery_moves.include?(m.id) }
    
    if has_recovery
      score += 45
      AdvancedAI.log("  Taunt vs wall: +45 (blocks recovery)", "Disruption")
    end
    
    # MEDIUM VALUE: Entry hazard users
    hazard_moves = [:STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB]
    has_hazards = target.moves.any? { |m| m && hazard_moves.include?(m.id) }
    
    if has_hazards
      score += 35
      AdvancedAI.log("  Taunt vs hazard setter: +35", "Disruption")
    end
    
    # MEDIUM VALUE: Substitute users
    if target.moves.any? { |m| m && m.id == :SUBSTITUTE }
      score += 30
      AdvancedAI.log("  Taunt vs Substitute: +30", "Disruption")
    end
    
    # LOW VALUE: Status spammers (Thunder Wave, Will-O-Wisp)
    status_inflict = [:THUNDERWAVE, :WILLOWISP, :TOXIC, :SLEEPPOWDER, :SPORE]
    has_status = target.moves.any? { |m| m && status_inflict.include?(m.id) }
    
    if has_status
      score += 20
      AdvancedAI.log("  Taunt vs status: +20", "Disruption")
    end
    
    # BONUS: If target is slow (can't switch out easily)
    if user.battler.pbSpeed > target.pbSpeed * 1.3
      score += 15
      AdvancedAI.log("  Outspeeds: +15 (locks them in)", "Disruption")
    end
    
    return score
  end
  
  # ============================================================================
  # ENCORE EVALUATION
  # ============================================================================
  
  def evaluate_encore_value(user, target)
    score = 0
    
    # Don't use if target already Encored
    if target.effects[PBEffects::Encore] > 0
      AdvancedAI.log("  Encore blocked: Already encored", "Disruption")
      return -90
    end
    
    # Can only Encore if target just used a move
    last_move = target.lastMoveUsed
    return -80 unless last_move  # No move used yet
    
    # Get the move they just used
    last_move_data = GameData::Move.try_get(last_move)
    return -80 unless last_move_data
    
    # HIGH VALUE: Lock into setup moves
    setup_moves = [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :SHELLSMASH, :CALMMIND]
    if setup_moves.include?(last_move)
      score += 80
      AdvancedAI.log("  Encore setup move: +80 (waste turns)", "Disruption")
      
      # Even better if we can set up while they're locked
      if user.moves.any? { |m| m && setup_moves.include?(m.id) }
        score += 30
        AdvancedAI.log("  Can counter-setup: +30", "Disruption")
      end
    end
    
    # HIGH VALUE: Lock into non-damaging moves
    if last_move_data.statusMove?
      score += 50
      AdvancedAI.log("  Encore status move: +50 (free turns)", "Disruption")
    end
    
    # MEDIUM VALUE: Lock into resisted moves
    if last_move_data.damagingMove?
      type_mod = Effectiveness.calculate(last_move_data.type, *user.battler.pbTypes(true))
      if Effectiveness.not_very_effective?(type_mod)
        score += 40
        AdvancedAI.log("  Encore resisted move: +40", "Disruption")
      elsif Effectiveness.ineffective?(type_mod)
        score += 70
        AdvancedAI.log("  Encore immune move: +70 (free turns!)", "Disruption")
      end
    end
    
    # LOW VALUE: Lock into weak moves (Splash, etc.)
    weak_moves = [:SPLASH, :CELEBRATE, :TELEPORT]
    if weak_moves.include?(last_move)
      score += 90
      AdvancedAI.log("  Encore useless move: +90 (jackpot!)", "Disruption")
    end
    
    # PENALTY: Don't Encore strong super-effective moves
    if last_move_data.damagingMove?
      type_mod = Effectiveness.calculate(last_move_data.type, *user.battler.pbTypes(true))
      if Effectiveness.super_effective?(type_mod)
        score -= 40
        AdvancedAI.log("  Encore SE move: -40 (bad idea)", "Disruption")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # KNOCK OFF EVALUATION
  # ============================================================================
  
  def evaluate_knockoff_value(user, target)
    score = 0
    
    # No item = no bonus (but still decent damage)
    unless target.item
      AdvancedAI.log("  Knock Off: No item (still 65 BP)", "Disruption")
      return 0  # Base damage is fine
    end
    
    item_id = target.item_id
    
    # Check if item is unlosable (Mega Stones, Z-Crystals, etc.)
    # Knock Off CANNOT remove unlosable items!
    item_data = GameData::Item.get(item_id)
    if item_data.unlosable?
      AdvancedAI.log("  Knock Off: Item is unlosable (no bonus)", "Disruption")
      return 0  # Base damage only, can't remove item
    end
    
    # CRITICAL VALUE: Remove mega stones (prevents Mega Evolution)
    # NOTE: This should never trigger since Mega Stones are unlosable,
    # but keeping for compatibility with custom implementations
    #if item_data.is_mega_stone?
      #score += 100
      #AdvancedAI.log("  Knock Off Mega Stone: +100 (prevents Mega!)", "Disruption")
    #end
    
    # VERY HIGH VALUE: Choiced items (unlocks them)
    choice_items = [:CHOICEBAND, :CHOICESCARF, :CHOICESPECS]
    if choice_items.include?(item_id)
      score += 70
      AdvancedAI.log("  Knock Off Choice item: +70 (unlocks moves)", "Disruption")
    end
    
    # HIGH VALUE: Defensive items
    defensive_items = [:LEFTOVERS, :ASSAULTVEST, :ROCKYHELMET, :EVIOLITE, :HEAVYDUTYBOOTS]
    if defensive_items.include?(item_id)
      score += 50
      AdvancedAI.log("  Knock Off defensive item: +50", "Disruption")
      
      # Eviolite on NFE Pokemon is CRITICAL
      if item_id == :EVIOLITE
        score += 30
        AdvancedAI.log("  Eviolite removal: +30 (cuts bulk)", "Disruption")
      end
      
      # Heavy-Duty Boots if hazards are up
      if item_id == :HEAVYDUTYBOOTS
        our_side = @battle.pbOwnedByPlayer?(user.index) ? @battle.sides[0] : @battle.sides[1]
        if our_side.effects[PBEffects::StealthRock] || our_side.effects[PBEffects::Spikes] > 0
          score += 40
          AdvancedAI.log("  Boots removal (hazards up): +40", "Disruption")
        end
      end
    end
    
    # HIGH VALUE: Offensive items
    offensive_items = [:LIFEORB, :EXPERTBELT, :WISEGLASSES, :MUSCLEBAND]
    if offensive_items.include?(item_id)
      score += 45
      AdvancedAI.log("  Knock Off offensive item: +45", "Disruption")
    end
    
    # MEDIUM VALUE: Focus Sash (removes survival)
    if item_id == :FOCUSSASH && target.hp == target.totalhp
      score += 60
      AdvancedAI.log("  Knock Off Focus Sash: +60 (removes survival)", "Disruption")
    end
    
    # MEDIUM VALUE: Weakness Policy
    if item_id == :WEAKNESSPOLICY
      score += 35
      AdvancedAI.log("  Knock Off Weakness Policy: +35", "Disruption")
    end
    
    # LOW VALUE: Berries
    if GameData::Item.get(item_id).is_berry?
      score += 25
      AdvancedAI.log("  Knock Off Berry: +25", "Disruption")
    end
    
    # BONUS: 1.5x damage multiplier when target has item
    score += 20  # Damage boost
    AdvancedAI.log("  Knock Off damage boost: +20 (97.5 BP)", "Disruption")
    
    return score
  end
  
  # ============================================================================
  # TRICK/SWITCHEROO EVALUATION
  # ============================================================================
  
  def evaluate_trick_value(user, target)
    score = 0
    user_item = user.battler.item_id
    target_item = target.item_id
    
    # Can't Trick if either has no item
    return -80 unless user_item || target_item
    
    # BEST CASE: Give Choice item to status-move user
    choice_items = [:CHOICEBAND, :CHOICESCARF, :CHOICESPECS]
    if choice_items.include?(user_item)
      # Count status moves on target
      status_moves = target.moves.count { |m| m && m.statusMove? }
      
      if status_moves >= 2
        score += 80
        AdvancedAI.log("  Trick Choice item: +80 (cripples support)", "Disruption")
      elsif status_moves >= 1
        score += 50
        AdvancedAI.log("  Trick Choice item: +50", "Disruption")
      end
      
      # BONUS: Lock walls into defensive moves
      recovery_moves = [:RECOVER, :ROOST, :WISH, :REST, :PROTECT]
      if target.moves.any? { |m| m && recovery_moves.include?(m.id) }
        score += 40
        AdvancedAI.log("  Trick vs wall: +40 (limits options)", "Disruption")
      end
    end
    
    # GOOD CASE: Give Lagging Tail / Iron Ball (speed reduction)
    if [:LAGGINGTAIL, :IRONBALL].include?(user_item)
      score += 60
      AdvancedAI.log("  Trick speed item: +60 (cripples speed)", "Disruption")
    end
    
    # GOOD CASE: Steal valuable items
    if target_item
      valuable_items = [:LEFTOVERS, :LIFEORB, :CHOICEBAND, :CHOICESCARF, :CHOICESPECS,
                       :ASSAULTVEST, :FOCUSSASH, :WEAKNESSPOLICY]
      if valuable_items.include?(target_item)
        score += 50
        AdvancedAI.log("  Trick steal valuable: +50", "Disruption")
      end
    end
    
    # PENALTY: Don't give away our own valuable items
    if user_item && !choice_items.include?(user_item)
      valuable_items = [:LEFTOVERS, :LIFEORB, :ASSAULTVEST, :FOCUSSASH]
      if valuable_items.include?(user_item)
        score -= 40
        AdvancedAI.log("  Trick lose valuable: -40", "Disruption")
      end
    end
    
    return score
  end
end

AdvancedAI.log("Disruption Move Intelligence loaded", "Core")
AdvancedAI.log("  - Taunt (blocks setup/support)", "Disruption")
AdvancedAI.log("  - Encore (locks into moves)", "Disruption")
AdvancedAI.log("  - Knock Off (item removal)", "Disruption")
AdvancedAI.log("  - Trick/Switcheroo (item swap)", "Disruption")

### FILE: Move_Categories.rb ###
#===============================================================================
# [014] Move Categories - 900+ Move Classification
#===============================================================================
# Categorizes all Moves for intelligent AI decisions
#
# Categories:
# - Priority Moves (Quick Attack, Aqua Jet, Mach Punch, etc.)
# - Setup Moves (Swords Dance, Nasty Plot, Dragon Dance, etc.)
# - Hazard Moves (Stealth Rock, Spikes, Sticky Web, etc.)
# - Healing Moves (Roost, Recover, Synthesis, etc.)
# - OHKO Moves (Fissure, Guillotine, Sheer Cold, etc.)
# - Spread Moves (Earthquake, Surf, Rock Slide, etc.)
# - Protect Moves (Protect, Detect, Spiky Shield, etc.)
# - Status Moves (Will-O-Wisp, Thunder Wave, Toxic, etc.)
# - Screen Moves (Light Screen, Reflect, Aurora Veil, etc.)
# - Weather Moves (Rain Dance, Sunny Day, Sandstorm, etc.)
# - Terrain Moves (Electric Terrain, Grassy Terrain, etc.)
# - Pivot Moves (U-turn, Volt Switch, Flip Turn, etc.)
#===============================================================================

module AdvancedAI
  module MoveCategories
    
    #===========================================================================
    # Priority Move Detection
    #===========================================================================
    PRIORITY_MOVES = [
      # +5 Priority
      :HELPINGHAND,
      
      # +4 Priority
      :MAGICCOAT, :SNATCH,
      
      # +3 Priority
      :FAKEOUT, :SPOTLIGHT, :FOLLOWME, :RAGEPOWDER,
      
      # +2 Priority
      :EXTREMESPEED, :FEINT, :FIRSTIMPRESSION,
      
      # +1 Priority
      :ACCELEROCK, :AQUAJET, :BABYDOLLEYES, :BULLETPUNCH, :ICESHARD,
      :JETPUNCH, :MACHPUNCH, :QUICKATTACK, :SHADOWSNEAK, :SUCKERPUNCH,
      :VACUUMWAVE, :WATERSHURIKEN,
      
      # Prankster-affected (status moves with Prankster)
      :THUNDERWAVE, :WILLOWISP, :TOXIC, :SPORE, :SLEEPPOWDER,
      :STUNSPORE, :TAUNT, :ENCORE, :DISABLE, :LIGHTSCREEN,
      :REFLECT, :AURORAVEIL, :TAILWIND, :TRICKROOM,
    ]
    
    #===========================================================================
    # Setup Move Detection (Stat Boosts)
    #===========================================================================
    SETUP_MOVES = {
      # +2 Attack
      :SWORDSDANCE    => { stat: :attack, stages: 2 },
      :BULKUP         => { stat: :attack_defense, stages: 1 },
      :CURSE          => { stat: :attack_defense, stages: 1, speed: -1 },
      :COIL           => { stat: :attack_defense_accuracy, stages: 1 },
      :HONECLAWS      => { stat: :attack_accuracy, stages: 1 },
      :HOWL           => { stat: :attack, stages: 1 },
      :MEDITATE       => { stat: :attack, stages: 1 },
      :POWERUPPUNCH   => { stat: :attack, stages: 1, damage: true },
      :SHARPEN        => { stat: :attack, stages: 1 },
      
      # +2 Special Attack
      :NASTYPLOT      => { stat: :spatk, stages: 2 },
      :TAILGLOW       => { stat: :spatk, stages: 3 },
      :GEOMANCY       => { stat: :spatk_spdef_speed, stages: 2, charge: true },
      :GROWTH         => { stat: :attack_spatk, stages: 1 },
      :CHARGEBEAM     => { stat: :spatk, stages: 1, damage: true },
      :FIERYDANCE     => { stat: :spatk, stages: 1, damage: true },
      :METEORBEAM     => { stat: :spatk, stages: 1, charge: true },
      
      # +2 Defense
      :IRONDEFENSE    => { stat: :defense, stages: 2 },
      :ACIDARMOR      => { stat: :defense, stages: 2 },
      :BARRIER        => { stat: :defense, stages: 2 },
      :COTTONGUARD    => { stat: :defense, stages: 3 },
      :DEFENDORDER    => { stat: :defense, stages: 1 },
      :HARDEN         => { stat: :defense, stages: 1 },
      :STOCKPILE      => { stat: :defense_spdef, stages: 1 },
      :WITHDRAW       => { stat: :defense, stages: 1 },
      
      # +2 Special Defense
      :AMNESIA        => { stat: :spdef, stages: 2 },
      :CALMMIND       => { stat: :spatk_spdef, stages: 1 },
      
      # +2 Speed
      :AGILITY        => { stat: :speed, stages: 2 },
      :AUTOTOMIZE     => { stat: :speed, stages: 2 },
      :ROCKPOLISH     => { stat: :speed, stages: 2 },
      :DRAGONDANCE    => { stat: :attack_speed, stages: 1 },
      :QUIVERDANCE    => { stat: :spatk_spdef_speed, stages: 1 },
      :SHIFTGEAR      => { stat: :attack_speed, stages: 1, speed_extra: 1 },
      :FLAMECHARGE    => { stat: :speed, stages: 1, damage: true },
      
      # Multi-Stat
      :SHELLSMASH     => { stat: :attack_spatk_speed, stages: 2, defense_spdef: -1 },
      :VICTORYDANCE   => { stat: :attack_defense_speed, stages: 1 },
      :COIL           => { stat: :attack_defense_accuracy, stages: 1 },
      :ACUPRESSURE    => { stat: :random, stages: 2 },
      :ANCIENTPOWER   => { stat: :all, stages: 1, damage: true, chance: 10 },
      :OMINOUSWIND    => { stat: :all, stages: 1, damage: true, chance: 10 },
      :SILVERPOWDER   => { stat: :all, stages: 1, damage: true, chance: 10 },
      
      # Evasion
      :DOUBLETEAM     => { stat: :evasion, stages: 1 },
      :MINIMIZE       => { stat: :evasion, stages: 2 },
      
      # Accuracy
      :HONECLAWS      => { stat: :attack_accuracy, stages: 1 },
      
      # Ability-Based Setup
      :BELLYDRUM      => { stat: :attack, stages: 6, hp_cost: 0.5 },
      :NORETREAT      => { stat: :all, stages: 1, trap: true },
    }
    
    #===========================================================================
    # Hazard Move Detection
    #===========================================================================
    HAZARD_MOVES = {
      # Entry Hazards
      :STEALTHROCK    => { type: :entry, damage: :type_based, layers: 1 },
      :SPIKES         => { type: :entry, damage: :fixed, layers: 3 },
      :TOXICSPIKES    => { type: :entry, damage: :poison, layers: 2 },
      :STICKYWEB      => { type: :entry, effect: :speed_drop, layers: 1 },
      :GMAXSTEELSURGE => { type: :entry, damage: :type_based, layers: 1 },
      
      # Hazard Removal
      :RAPIDSPIN      => { type: :removal, damage: true },
      :DEFOG          => { type: :removal, stat_drop: true },
      :COURTCHANGE    => { type: :swap },
      :TIDYUP         => { type: :removal, stat_boost: true },
    }
    
    #===========================================================================
    # Healing Move Detection
    #===========================================================================
    HEALING_MOVES = {
      # 50% HP Recovery
      :RECOVER        => { heal: 0.5 },
      :ROOST          => { heal: 0.5, lose_flying: true },
      :SLACKOFF       => { heal: 0.5 },
      :SOFTBOILED     => { heal: 0.5 },
      :MILKDRINK      => { heal: 0.5 },
      :HEALORDER      => { heal: 0.5 },
      :SHOREUP        => { heal: 0.5, weather_boost: :sandstorm },
      
      # Weather-Based
      :SYNTHESIS      => { heal: 0.5, weather: true },
      :MOONLIGHT      => { heal: 0.5, weather: true },
      :MORNINGSUN     => { heal: 0.5, weather: true },
      
      # Wish (Delayed)
      :WISH           => { heal: 0.5, delayed: true },
      
      # Rest (Full Heal + Sleep)
      :REST           => { heal: 1.0, sleep: true },
      
      # Drain Moves
      :ABSORB         => { heal: 0.5, damage: true },
      :MEGADRAIN      => { heal: 0.5, damage: true },
      :GIGADRAIN      => { heal: 0.5, damage: true },
      :DRAINPUNCH     => { heal: 0.5, damage: true },
      :DRAININGKISS   => { heal: 0.75, damage: true },
      :LEECHLIFE      => { heal: 0.5, damage: true },
      :PARABOLICCHARGE => { heal: 0.5, damage: true, spread: true },
      :OBLIVIONWING   => { heal: 0.75, damage: true },
      :STRENGTHSAP    => { heal: :opponent_attack, stat_drop: true },
      
      # Passive Healing
      :AQUARING       => { heal: 0.0625, per_turn: true },
      :INGRAIN        => { heal: 0.0625, per_turn: true, trap: true },
      :LEECHSEED      => { heal: 0.125, per_turn: true, opponent_damage: true },
    }
    
    #===========================================================================
    # OHKO Move Detection
    #===========================================================================
    OHKO_MOVES = [
      :FISSURE,       # Ground-type
      :GUILLOTINE,    # Normal-type
      :HORNDRILL,     # Normal-type
      :SHEERCOLD,     # Ice-type
    ]
    
    #===========================================================================
    # Spread Move Detection (hits multiple targets in Doubles/Triples)
    #===========================================================================
    SPREAD_MOVES = [
      # Damaging Spread
      :EARTHQUAKE, :SURF, :DISCHARGE, :LAVAPLUME, :BLIZZARD,
      :ROCKSLIDE, :RAZORLEAF, :ICICLESPEAR, :BULLDOZE, :SNARL,
      :DAZZLINGGLEAM, :HEATWAVE, :PARABOLICCHARGE, :RELICSONG,
      :GLACIATE, :MUDDYWATER, :ORIGINPULSE, :PRECIPICEBLADES,
      
      # Status Spread
      :SWEETSCENT, :GROWL, :SCREECH, :STRINGSHOT, :SANDATTACK,
      :SMOKESCREEN, :CONFUSERAY, :SUPERSONIC, :LOVELYKISS,
      
      # Self + Ally
      :HEALPULSE, :POLLENPUFF, :FLORALHEALING,
    ]
    
    #===========================================================================
    # Protect Move Detection
    #===========================================================================
    PROTECT_MOVES = {
      :PROTECT        => { priority: 4, bypass: false },
      :DETECT         => { priority: 4, bypass: false },
      :KINGSSHIELD    => { priority: 4, bypass: false, effect: :attack_drop },
      :SPIKYSHIELD    => { priority: 4, bypass: false, effect: :damage },
      :BANEFULBUNKER  => { priority: 4, bypass: false, effect: :poison },
      :OBSTRUCT       => { priority: 4, bypass: false, effect: :defense_drop_2 },
      :SILKTRAP       => { priority: 4, bypass: false, effect: :speed_drop },
      :BURNINGBULWARK => { priority: 4, bypass: false, effect: :burn },
      :ENDURE         => { priority: 4, bypass: false, hp: 1 },
      :QUICKGUARD     => { priority: 3, bypass: false, team: true, priority_only: true },
      :WIDEGUARD      => { priority: 3, bypass: false, team: true, spread_only: true },
      :MATBLOCK       => { priority: 0, bypass: false, team: true, turn: 1 },
      :CRAFTYSHIELD   => { priority: 3, bypass: false, team: true, status_only: true },
    }
    
    #===========================================================================
    # Status Move Detection
    #===========================================================================
    STATUS_MOVES = {
      # Paralysis
      :THUNDERWAVE    => { status: :paralysis, accuracy: 90 },
      :STUNSPORE      => { status: :paralysis, accuracy: 75 },
      :GLARE          => { status: :paralysis, accuracy: 100 },
      :NUZZLE         => { status: :paralysis, damage: true },
      
      # Burn
      :WILLOWISP      => { status: :burn, accuracy: 85 },
      :SACREDFIRE     => { status: :burn, chance: 50, damage: true },
      
      # Poison
      :TOXIC          => { status: :toxic, accuracy: 90 },
      :POISONPOWDER   => { status: :poison, accuracy: 75 },
      :POISONGAS      => { status: :poison, accuracy: 90 },
      
      # Sleep
      :SPORE          => { status: :sleep, accuracy: 100 },
      :SLEEPPOWDER    => { status: :sleep, accuracy: 75 },
      :HYPNOSIS       => { status: :sleep, accuracy: 60 },
      :DARKVOID       => { status: :sleep, accuracy: 50 },
      :YAWN           => { status: :sleep, delayed: true },
      
      # Freeze
      :ICEBEAM        => { status: :freeze, chance: 10, damage: true },
      :BLIZZARD       => { status: :freeze, chance: 10, damage: true },
      
      # Confusion
      :CONFUSERAY     => { status: :confusion, accuracy: 100 },
      :SUPERSONIC     => { status: :confusion, accuracy: 55 },
      :SWEETKISS      => { status: :confusion, accuracy: 75 },
      
      # Infatuation
      :ATTRACT        => { status: :infatuation, accuracy: 100 },
      :CAPTIVATE      => { status: :infatuation, accuracy: 100 },
      
      # Flinch
      :FAKEOUT        => { status: :flinch, damage: true, turn: 1 },
      :AIRSLASH       => { status: :flinch, chance: 30, damage: true },
      :IRONHEAD       => { status: :flinch, chance: 30, damage: true },
    }
    
    #===========================================================================
    # Screen Move Detection
    #===========================================================================
    SCREEN_MOVES = {
      :LIGHTSCREEN    => { type: :special, duration: 5 },
      :REFLECT        => { type: :physical, duration: 5 },
      :AURORAVEIL     => { type: :both, duration: 5, weather: :hail },
      :SAFEGUARD      => { type: :status, duration: 5 },
      :MIST           => { type: :stat_drop, duration: 5 },
      :LUCKYCHANT     => { type: :crit, duration: 5 },
    }
    
    #===========================================================================
    # Weather Move Detection
    #===========================================================================
    WEATHER_MOVES = {
      :SUNNYDAY       => { weather: :sun, duration: 5 },
      :RAINDANCE      => { weather: :rain, duration: 5 },
      :SANDSTORM      => { weather: :sandstorm, duration: 5 },
      :HAIL           => { weather: :hail, duration: 5 },
      :SNOWSCAPE      => { weather: :snow, duration: 5 },  # Gen 9
    }
    
    #===========================================================================
    # Terrain Move Detection
    #===========================================================================
    TERRAIN_MOVES = {
      :ELECTRICTERRAIN => { terrain: :electric, duration: 5 },
      :GRASSYTERRAIN   => { terrain: :grassy, duration: 5 },
      :MISTYTERRAIN    => { terrain: :misty, duration: 5 },
      :PSYCHICTERRAIN  => { terrain: :psychic, duration: 5 },
    }
    
    #===========================================================================
    # Stall Move Detection (Toxic Stall / Defensive Strategy)
    #===========================================================================
    # Moves that define the stall archetype: passive damage + protection + recovery
    STALL_MOVES = {
      # Passive Damage Sources
      :TOXIC          => { role: :passive_damage, target: :opponent },
      :LEECHSEED      => { role: :passive_damage, target: :opponent, self_heal: true },
      :WILLOWISP      => { role: :passive_damage, target: :opponent },
      
      # Protection (Protect variants + Wish stalling)
      :PROTECT        => { role: :protection },
      :DETECT         => { role: :protection },
      :BANEFULBUNKER  => { role: :protection, effect: :poison },
      :SPIKYSHIELD    => { role: :protection, effect: :damage },
      :KINGSSHIELD    => { role: :protection, effect: :attack_drop },
      :OBSTRUCT       => { role: :protection, effect: :defense_drop },
      :SILKTRAP       => { role: :protection, effect: :speed_drop },
      :BURNINGBULWARK => { role: :protection, effect: :burn },
      
      # Recovery
      :RECOVER        => { role: :recovery, heal: 0.5 },
      :SOFTBOILED     => { role: :recovery, heal: 0.5 },
      :ROOST          => { role: :recovery, heal: 0.5 },
      :SLACKOFF       => { role: :recovery, heal: 0.5 },
      :WISH           => { role: :recovery, heal: 0.5, delayed: true },
      :REST           => { role: :recovery, heal: 1.0, sleep: true },
      :SYNTHESIS      => { role: :recovery, heal: 0.5, weather: true },
      :MOONLIGHT      => { role: :recovery, heal: 0.5, weather: true },
      :MORNINGSUN     => { role: :recovery, heal: 0.5, weather: true },
      :STRENGTHSAP    => { role: :recovery, heal: :opponent_attack },
      :SHOREUP        => { role: :recovery, heal: 0.5 },
      
      # Utility (Disruption that supports stall gameplan)
      :KNOCKOFF       => { role: :utility, effect: :item_removal },
      :SCALD          => { role: :utility, effect: :burn_chance },
      :HAZE           => { role: :utility, effect: :stat_reset },
      :WHIRLWIND      => { role: :utility, effect: :phaze },
      :ROAR           => { role: :utility, effect: :phaze },
      :DEFOG          => { role: :utility, effect: :hazard_removal },
      :RAPIDSPIN      => { role: :utility, effect: :hazard_removal },
      :TAUNT          => { role: :utility, effect: :move_restriction },
      :ENCORE         => { role: :utility, effect: :move_lock },
      
      # Hazards (Part of stall team identity)
      :STEALTHROCK    => { role: :hazard },
      :SPIKES         => { role: :hazard },
      :TOXICSPIKES    => { role: :hazard },
      :STICKYWEB      => { role: :hazard },
    }
    
    #===========================================================================
    # Pivot Move Detection (U-turn, Volt Switch, etc.)
    #===========================================================================
    PIVOT_MOVES = [
      :UTURN,         # Bug-type
      :VOLTSWITCH,    # Electric-type
      :FLIPTURN,      # Water-type
      :BATONPASS,     # Passes stat changes
      :PARTINGSHOT,   # Lowers stats + switches
      :TELEPORT,      # -6 priority (escape)
      :CHILLYRECEPTION, # Sets Snow + switches (Gen 9)
      :SHEDTAIL,      # Creates Substitute + switches (Gen 9)
    ]
    
    #===========================================================================
    # Move Category Checking Methods
    #===========================================================================
    
    def self.priority_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      
      # Check list
      return true if PRIORITY_MOVES.include?(move_id)
      
      # Check move data
      move = GameData::Move.try_get(move_id)
      return move && move.priority > 0
    end
    
    def self.setup_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return SETUP_MOVES.key?(move_id)
    end
    
    def self.hazard_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return HAZARD_MOVES.key?(move_id)
    end
    
    def self.healing_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return HEALING_MOVES.key?(move_id)
    end
    
    def self.ohko_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return OHKO_MOVES.include?(move_id)
    end
    
    def self.spread_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      
      # Check list
      return true if SPREAD_MOVES.include?(move_id)
      
      # Check move data
      move = GameData::Move.try_get(move_id)
      return move && move.target == :AllNearFoes
    end
    
    def self.protect_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return PROTECT_MOVES.key?(move_id)
    end
    
    def self.status_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return STATUS_MOVES.key?(move_id)
    end
    
    def self.screen_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return SCREEN_MOVES.key?(move_id)
    end
    
    def self.weather_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return WEATHER_MOVES.key?(move_id)
    end
    
    def self.terrain_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return TERRAIN_MOVES.key?(move_id)
    end
    
    def self.pivot_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return PIVOT_MOVES.include?(move_id)
    end
    
    def self.stall_move?(move_id)
      return false if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return STALL_MOVES.key?(move_id)
    end
    
    # Returns the stall role data for a move (or nil)
    def self.get_stall_data(move_id)
      return nil if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return STALL_MOVES[move_id]
    end
    
    # Checks if a Pokemon has a stall moveset (2+ stall-role moves)
    def self.has_stall_moveset?(pokemon)
      return false unless pokemon
      
      moves = if pokemon.respond_to?(:moves)
                pokemon.moves
              elsif pokemon.respond_to?(:battler) && pokemon.battler.respond_to?(:moves)
                pokemon.battler.moves
              else
                return false
              end
      
      return false unless moves
      
      stall_count = 0
      has_passive_damage = false
      has_recovery_or_protect = false
      
      moves.each do |m|
        next unless m
        move_id = m.respond_to?(:id) ? m.id : m
        data = STALL_MOVES[move_id]
        next unless data
        
        stall_count += 1
        has_passive_damage = true if data[:role] == :passive_damage
        has_recovery_or_protect = true if [:recovery, :protection].include?(data[:role])
      end
      
      # A stall mon has 2+ stall moves AND either passive damage + recovery/protect
      stall_count >= 2 && (has_passive_damage || has_recovery_or_protect)
    end
    
    # Returns Setup Data (which Stat, by how much)
    def self.get_setup_data(move_id)
      return nil if !move_id
      move_id = move_id.to_sym if move_id.is_a?(String)
      return SETUP_MOVES[move_id]
    end
    
    # Categorizes Move
    def self.categorize_move(move_id)
      categories = []
      return categories if !move_id
      
      categories << :priority if priority_move?(move_id)
      categories << :setup if setup_move?(move_id)
      categories << :hazard if hazard_move?(move_id)
      categories << :healing if healing_move?(move_id)
      categories << :ohko if ohko_move?(move_id)
      categories << :spread if spread_move?(move_id)
      categories << :protect if protect_move?(move_id)
      categories << :status if status_move?(move_id)
      categories << :screen if screen_move?(move_id)
      categories << :weather if weather_move?(move_id)
      categories << :terrain if terrain_move?(move_id)
      categories << :pivot if pivot_move?(move_id)
      
      return categories
    end
    
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.priority_move?(move_id)
    MoveCategories.priority_move?(move_id)
  end
  
  def self.setup_move?(move_id)
    MoveCategories.setup_move?(move_id)
  end
  
  def self.hazard_move?(move_id)
    MoveCategories.hazard_move?(move_id)
  end
  
  def self.healing_move?(move_id)
    MoveCategories.healing_move?(move_id)
  end
  
  def self.ohko_move?(move_id)
    MoveCategories.ohko_move?(move_id)
  end
  
  def self.spread_move?(move_id)
    MoveCategories.spread_move?(move_id)
  end
  
  def self.protect_move?(move_id)
    MoveCategories.protect_move?(move_id)
  end
  
  def self.screen_move?(move_id)
    MoveCategories.screen_move?(move_id)
  end
  
  def self.status_move?(move_id)
    MoveCategories.status_move?(move_id)
  end
  
  def self.pivot_move?(move_id)
    MoveCategories.pivot_move?(move_id)
  end
  
  def self.stall_move?(move_id)
    MoveCategories.stall_move?(move_id)
  end
  
  def self.get_stall_data(move_id)
    MoveCategories.get_stall_data(move_id)
  end
  
  def self.has_stall_moveset?(pokemon)
    MoveCategories.has_stall_moveset?(pokemon)
  end
  
  def self.get_setup_data(move_id)
    MoveCategories.get_setup_data(move_id)
  end
  
  def self.categorize_move(move_id)
    MoveCategories.categorize_move(move_id)
  end
end

### FILE: Move_Memory.rb ###
#===============================================================================
# Advanced AI System - Move Memory
# Tracks all opponent moves for intelligent predictions (Reborn-inspired)
#===============================================================================

module AdvancedAI
  module MoveMemory
    # Cache for Move Memory per Battle
    @battle_memory = {}
    
    # Initializes Move Memory for a Battle
    def self.initialize_battle(battle)
      @battle_memory[battle.object_id] ||= {}
    end
    
    # Remembers a Move
    def self.remember_move(battle, battler, move)
      return unless battle && battler && move
      initialize_battle(battle)
      
      battler_key = "#{battler.index}_#{battler.pokemon.personalID}"
      @battle_memory[battle.object_id][battler_key] ||= {
        moves: [],
        move_counts: Hash.new(0),
        last_move: nil,
        priority_moves: [],
        healing_moves: [],
        setup_moves: [],
        status_moves: [],
        max_power: 0
      }
      
      memory = @battle_memory[battle.object_id][battler_key]
      move_id = move.id
      
      # Save Move
      memory[:moves] << move_id unless memory[:moves].include?(move_id)
      memory[:move_counts][move_id] += 1
      memory[:last_move] = move_id
      
      # Categorize Move
      # Categorize Move
      # move is a Battle::Move object
      memory[:priority_moves] << move_id if move.priority > 0 && !memory[:priority_moves].include?(move_id)
      memory[:healing_moves] << move_id if move.healingMove? && !memory[:healing_moves].include?(move_id)
      
      # Check for setup moves (stat raising)
      is_setup = move.function_code.start_with?("RaiseUser")
      memory[:setup_moves] << move_id if is_setup && !memory[:setup_moves].include?(move_id)
      
      memory[:status_moves] << move_id if move.statusMove? && !memory[:status_moves].include?(move_id)
      memory[:max_power] = [memory[:max_power], move.power].max
      
      # Enhanced logging with move details
      move_type = if move.damagingMove?
                    "Damaging (#{move.power} BP)"
                  elsif move.statusMove?
                    "Status"
                  else
                    "Other"
                  end
      AdvancedAI.log("Move Memory: #{battler.name} used #{move.name} (#{move_type}) - Total uses: #{memory[:move_counts][move_id]}", "Memory")
    end
    
    # Gets Memory for a Battler
    def self.get_memory(battle, battler)
      return {} unless battle && battler
      initialize_battle(battle)
      
      battler_key = "#{battler.index}_#{battler.pokemon.personalID}"
      @battle_memory[battle.object_id][battler_key] || {}
    end
    
    # Checks if Move is known
    def self.knows_move?(battle, battler, move_id)
      memory = get_memory(battle, battler)
      memory[:moves]&.include?(move_id) || false
    end
    
    # Checks if Battler has Priority Moves
    def self.has_priority_move?(battle, battler)
      memory = get_memory(battle, battler)
      !memory[:priority_moves].nil? && memory[:priority_moves].any?
    end
    
    # Checks if Battler has Healing Moves
    def self.has_healing_move?(battle, battler)
      memory = get_memory(battle, battler)
      !memory[:healing_moves].nil? && memory[:healing_moves].any?
    end
    
    # Checks if Battler has Setup Moves
    def self.has_setup_move?(battle, battler)
      memory = get_memory(battle, battler)
      !memory[:setup_moves].nil? && memory[:setup_moves].any?
    end
    
    # Gets strongest known Move
    def self.strongest_known_move(battle, battler)
      memory = get_memory(battle, battler)
      return nil if memory[:moves].nil? || memory[:moves].empty?
      
      memory[:moves].max_by do |move_id|
        GameData::Move.get(move_id).power
      end
    end
    
    # Estimates max damage
    def self.max_known_damage(battle, attacker, defender)
      return 0 unless attacker && defender
      memory = get_memory(battle, attacker)
      return 0 if memory[:moves].nil? || memory[:moves].empty?
      
      max_damage = 0
      
      memory[:moves].each do |move_id|
        move_data = GameData::Move.get(move_id)
        next unless move_data.damaging?
        
        # Simplified Damage Calculation
        bp = move_data.power
        type_mod = Effectiveness.calculate(move_data.type, defender.types[0], defender.types[1])
        stab = attacker.pbHasType?(move_data.type) ? 1.5 : 1.0
        
        atk = move_data.physical? ? attacker.attack : attacker.spatk
        defense = move_data.physical? ? defender.defense : defender.spdef
        
        damage = ((2 * attacker.level / 5.0 + 2) * bp * atk / defense / 50 + 2)
        damage *= type_mod * stab
        
        max_damage = [max_damage, damage.to_i].max
      end
      
      max_damage
    end
    
    # Gets last Move
    def self.last_move(battle, battler)
      memory = get_memory(battle, battler)
      memory[:last_move]
    end
    
    # Gets Move Frequency
    def self.move_frequency(battle, battler, move_id)
      memory = get_memory(battle, battler)
      memory[:move_counts]&.[](move_id) || 0
    end
    
    # Cleanup after Battle
    def self.cleanup_battle(battle)
      @battle_memory.delete(battle.object_id) if battle
    end
  end
end

# Integration in Battle
class Battle
  alias aai_memory_pbEndOfBattle pbEndOfBattle
  def pbEndOfBattle
    AdvancedAI::MoveMemory.cleanup_battle(self)
    aai_memory_pbEndOfBattle
  end
end

# Integration in Move Usage
class Battle::Battler
  alias aai_memory_pbUseMoveSimple pbUseMoveSimple
  def pbUseMoveSimple(move_id, target = -1, idx = -1, specialUsage = false)
    # Remember Move for ALL battlers (player AND AI)
    # This is needed for move repetition penalties and advanced AI strategies
    AdvancedAI::MoveMemory.remember_move(@battle, self, @moves[idx]) if @moves[idx]
    
    aai_memory_pbUseMoveSimple(move_id, target, idx, specialUsage)
  end
end

# API Wrapper for simple access
module AdvancedAI
  def self.get_memory(battle, battler)
    MoveMemory.get_memory(battle, battler)
  end
  
  def self.knows_move?(battle, battler, move_id)
    MoveMemory.knows_move?(battle, battler, move_id)
  end
  
  def self.has_priority_move?(battle, battler)
    MoveMemory.has_priority_move?(battle, battler)
  end
  
  def self.has_healing_move?(battle, battler)
    MoveMemory.has_healing_move?(battle, battler)
  end
  
  def self.has_setup_move?(battle, battler)
    MoveMemory.has_setup_move?(battle, battler)
  end
  
  def self.strongest_known_move(battle, battler)
    MoveMemory.strongest_known_move(battle, battler)
  end
  
  def self.max_known_damage(battle, attacker, defender)
    MoveMemory.max_known_damage(battle, attacker, defender)
  end
  
  def self.last_move(battle, battler)
    MoveMemory.last_move(battle, battler)
  end
  
  def self.move_frequency(battle, battler, move_id)
    MoveMemory.move_frequency(battle, battler, move_id)
  end
end

AdvancedAI.log("Move Memory System loaded (Reborn-inspired)", "Memory")

#===============================================================================
# Integration in Battle::AI - Wires move memory into scoring pipeline
#===============================================================================
class Battle::AI
  def apply_move_memory(score, move, user, target)
    return score unless move && target
    
    # Penalize overly repetitive moves (predictable play)
    freq = AdvancedAI.move_frequency(@battle, user, move.id)
    if freq >= 3
      score -= 10  # Slight penalty for using same move 3+ times
    end
    
    # If we know the opponent has a priority move, slight boost to bulky plays
    if AdvancedAI.has_priority_move?(@battle, target)
      if AdvancedAI.protect_move?(move.id)
        score += 10  # Protect is good against priority users
      end
    end
    
    # If opponent has healing, boost status/setup over weak attacks
    if AdvancedAI.has_healing_move?(@battle, target)
      if move.damagingMove? && move.power < 60
        score -= 10  # Weak attacks get outhealed
      end
      if AdvancedAI.setup_move?(move.id)
        score += 5  # Setup to overpower healing
      end
    end
    
    return score
  end
end

### FILE: Special_Moves.rb ###
#===============================================================================
# Advanced AI System - Special Sacrifice & Utility Moves
# Handles Pain Split, Healing Wish, Final Gambit, Memento, etc.
#===============================================================================

class Battle::AI
  # ============================================================================
  # SPECIAL MOVE EVALUATION
  # ============================================================================
  
  alias special_moves_pbRegisterMove pbRegisterMove
  def pbRegisterMove(user, move)
    score = special_moves_pbRegisterMove(user, move)
    
    return score unless user && move
    
    case move.id
    when :PAINSPLIT
      score += evaluate_pain_split(user, move)
    when :HEALINGWISH, :LUNARDANCE
      score += evaluate_healing_wish(user, move)
    when :FINALGAMBIT
      score += evaluate_final_gambit(user, move)
    when :MEMENTO, :MISTYEXPLOSION, :HEALINGWISH
      score += evaluate_sacrifice_moves(user, move)
    when :RAPIDSPIN, :DEFOG
      score += evaluate_hazard_removal(user, move)
    when :ENDEAVOR
      score += evaluate_endeavor(user, move)
    end
    
    return score
  end
  
  # ============================================================================
  # PAIN SPLIT EVALUATION
  # ============================================================================
  
  def evaluate_pain_split(user, move)
    score = 0
    
    targets = @battle.allOtherSideBattlers(user.index)
    targets.each do |target|
      next unless target && !target.fainted?
      
      user_hp_percent = user.hp.to_f / user.totalhp
      target_hp_percent = target.hp.to_f / target.totalhp
      
      # Pain Split averages HP% between both Pokemon
      average_hp = (user_hp_percent + target_hp_percent) / 2.0
      user_gain = average_hp - user_hp_percent
      target_loss = target_hp_percent - average_hp
      
      # HIGH VALUE: We're low, they're high
      if user_hp_percent < 0.35 && target_hp_percent > 0.6
        score += 80
        AdvancedAI.log("  Pain Split (#{(user_hp_percent * 100).to_i}% vs #{(target_hp_percent * 100).to_i}%): +80 (huge heal)", "Special")
        
        # CRITICAL: Could save us from KO
        if user_hp_percent < 0.2
          score += 40
          AdvancedAI.log("  Emergency heal: +40", "Special")
        end
      elsif user_hp_percent < 0.5 && target_hp_percent > 0.5
        # MEDIUM VALUE
        score += 50
        AdvancedAI.log("  Pain Split: +50 (good heal)", "Special")
      elsif user_hp_percent > target_hp_percent
        # BAD: We lose HP
        score -= 40
        AdvancedAI.log("  Pain Split: -40 (we lose HP)", "Special")
      else
        # Minimal benefit
        score += 10
        AdvancedAI.log("  Pain Split: +10 (slight benefit)", "Special")
      end
      
      # BONUS: High max HP target (more HP to average)
      if target.totalhp > user.totalhp * 1.3
        score += 20
        AdvancedAI.log("  High HP target: +20", "Special")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # HEALING WISH / LUNAR DANCE EVALUATION
  # ============================================================================
  
  def evaluate_healing_wish(user, move)
    score = 0
    
    # User faints to fully heal next Pokemon
    # Only use if:
    # 1. We're about to die anyway
    # 2. We have a valuable teammate to heal
    
    user_hp_percent = user.hp.to_f / user.totalhp
    
    # Don't sacrifice if healthy
    if user_hp_percent > 0.4
      AdvancedAI.log("  #{move.name}: -70 (too healthy to sacrifice)", "Special")
      return -70
    end
    
    # Check party for valuable teammates
    party = @battle.pbParty(user.index)
    valuable_teammates = 0
    injured_sweepers = 0
    
    party.each do |pkmn|
      next if !pkmn || pkmn.fainted? || pkmn.egg?
      next if pkmn == user.battler.pokemon  # Skip self
      
      hp_percent = pkmn.hp.to_f / pkmn.totalhp
      
      # Valuable if injured and has high stats
      if hp_percent < 0.6 && (pkmn.attack > 100 || pkmn.spatk > 100)
        injured_sweepers += 1
      end
      
      # Valuable if status'd
      if pkmn.status != :NONE
        valuable_teammates += 1 if move.id == :LUNARDANCE  # Lunar Dance cures status
      end
    end
    
    if injured_sweepers > 0
      score += injured_sweepers * 50
      AdvancedAI.log("  #{move.name}: +#{injured_sweepers * 50} (heal sweeper)", "Special")
      
      # CRITICAL: Last Pokemon standing, sacrifice for win condition
      alive_count = party.count { |p| p && !p.fainted? }
      if alive_count == 2 && user_hp_percent < 0.25
        score += 60
        AdvancedAI.log("  Last hope sacrifice: +60", "Special")
      end
    else
      # No good targets
      score -= 50
      AdvancedAI.log("  #{move.name}: -50 (no valuable teammates)", "Special")
    end
    
    # Lunar Dance bonus for status'd team
    if move.id == :LUNARDANCE && valuable_teammates > 0
      score += 30
      AdvancedAI.log("  Cures status: +30", "Special")
    end
    
    return score
  end
  
  # ============================================================================
  # FINAL GAMBIT EVALUATION
  # ============================================================================
  
  def evaluate_final_gambit(user, move)
    score = 0
    
    targets = @battle.allOtherSideBattlers(user.index)
    targets.each do |target|
      next unless target && !target.fainted?
      
      # Final Gambit: Deals damage equal to user's current HP, user faints
      damage = user.hp
      target_hp = target.hp
      
      # BEST CASE: KO high-value target
      if damage >= target_hp
        score += 100
        AdvancedAI.log("  Final Gambit: +100 (KOs target)", "Special")
        
        # BONUS: Target is a sweeper
        if target.stages.values.sum >= 2
          score += 50
          AdvancedAI.log("  KOs boosted sweeper: +50", "Special")
        end
        
        # BONUS: Target is last Pokemon
        enemy_count = @battle.allOtherSideBattlers(user.index).count { |b| b && !b.fainted? }
        if enemy_count == 1
          score += 80
          AdvancedAI.log("  KOs last Pokemon: +80 (wins game!)", "Special")
        end
      else
        # Doesn't KO - check if worth it
        damage_percent = damage.to_f / target.totalhp
        
        if damage_percent > 0.6
          score += 40
          AdvancedAI.log("  Final Gambit: +40 (big damage)", "Special")
        elsif damage_percent > 0.4
          score += 20
          AdvancedAI.log("  Final Gambit: +20 (decent damage)", "Special")
        else
          score -= 60
          AdvancedAI.log("  Final Gambit: -60 (waste)", "Special")
        end
      end
      
      # PENALTY: We're valuable
      user_hp_percent = user.hp.to_f / user.totalhp
      if user_hp_percent > 0.5
        score -= 50
        AdvancedAI.log("  Too healthy: -50", "Special")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # SACRIFICE MOVES (Memento, Misty Explosion, etc.)
  # ============================================================================
  
  def evaluate_sacrifice_moves(user, move)
    score = 0
    user_hp_percent = user.hp.to_f / user.totalhp
    
    # Memento: -2 Atk/SpAtk to target, user faints
    # Misty Explosion: 2x power on Misty Terrain, user faints
    
    if move.id == :MEMENTO
      targets = @battle.allOtherSideBattlers(user.index)
      targets.each do |target|
        next unless target && !target.fainted?
        
        # HIGH VALUE: Cripple setup sweeper
        if target.stages[:ATTACK] >= 1 || target.stages[:SPECIAL_ATTACK] >= 1
          score += 70
          AdvancedAI.log("  Memento vs boosted: +70 (cripple)", "Special")
        elsif target.attack > 120 || target.spatk > 120
          score += 50
          AdvancedAI.log("  Memento vs strong: +50", "Special")
        else
          score += 20
          AdvancedAI.log("  Memento: +20", "Special")
        end
      end
      
      # Only if we're dying anyway
      if user_hp_percent > 0.3
        score -= 60
        AdvancedAI.log("  Too healthy to Memento: -60", "Special")
      end
    end
    
    if move.id == :MISTYEXPLOSION
      # 2x power on Misty Terrain
      if @battle.field.terrain == :Misty
        score += 40
        AdvancedAI.log("  Misty Explosion (terrain): +40", "Special")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # HAZARD REMOVAL (Rapid Spin, Defog)
  # ============================================================================
  
  def evaluate_hazard_removal(user, move)
    score = 0
    
    # Check our side for hazards
    our_side = @battle.pbOwnedByPlayer?(user.index) ? @battle.sides[0] : @battle.sides[1]
    
    hazard_count = 0
    hazard_count += 1 if our_side.effects[PBEffects::StealthRock]
    hazard_count += our_side.effects[PBEffects::Spikes]
    hazard_count += our_side.effects[PBEffects::ToxicSpikes]
    hazard_count += 1 if our_side.effects[PBEffects::StickyWeb]
    
    if hazard_count == 0
      AdvancedAI.log("  #{move.name}: -70 (no hazards)", "Special")
      return -70
    end
    
    # HIGH VALUE: Remove hazards
    score += hazard_count * 30
    AdvancedAI.log("  #{move.name}: +#{hazard_count * 30} (remove #{hazard_count} hazards)", "Special")
    
    # BONUS: Stealth Rock is critical
    if our_side.effects[PBEffects::StealthRock]
      score += 25
      AdvancedAI.log("  Remove Stealth Rock: +25", "Special")
    end
    
    # BONUS: We have Pokemon weak to hazards
    party = @battle.pbParty(user.index)
    weak_to_rocks = party.count do |pkmn|
      next false if !pkmn || pkmn.fainted?
      type_mod = Effectiveness.calculate(:ROCK, *pkmn.types)
      Effectiveness.super_effective?(type_mod)
    end
    
    if weak_to_rocks > 0
      score += weak_to_rocks * 15
      AdvancedAI.log("  Protect weak teammates: +#{weak_to_rocks * 15}", "Special")
    end
    
    # Defog ALSO removes opponent's hazards and screens
    if move.id == :DEFOG
      opp_side = @battle.pbOwnedByPlayer?(user.index) ? @battle.sides[1] : @battle.sides[0]
      
      # Remove opponent screens (bad for us usually)
      if opp_side.effects[PBEffects::Reflect] > 0 || opp_side.effects[PBEffects::LightScreen] > 0
        score += 40
        AdvancedAI.log("  Remove opponent screens: +40", "Special")
      end
      
      # Remove opponent hazards (gives them benefit)
      opp_hazards = 0
      opp_hazards += 1 if opp_side.effects[PBEffects::StealthRock]
      opp_hazards += opp_side.effects[PBEffects::Spikes]
      if opp_hazards > 0
        score -= opp_hazards * 15
        AdvancedAI.log("  Also removes our hazards: -#{opp_hazards * 15}", "Special")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # ENDEAVOR EVALUATION
  # ============================================================================
  
  def evaluate_endeavor(user, move)
    score = 0
    
    targets = @battle.allOtherSideBattlers(user.index)
    targets.each do |target|
      next unless target && !target.fainted?
      
      # Endeavor: Set target HP to user's current HP
      user_hp = user.hp
      target_hp = target.hp
      
      # Only good if we're low HP
      user_hp_percent = user_hp.to_f / user.totalhp
      
      if user_hp_percent > 0.5
        score -= 60
        AdvancedAI.log("  Endeavor: -60 (too healthy)", "Special")
        return score
      end
      
      # HIGH VALUE: Target at high HP, we're low
      if target_hp > user_hp * 2
        damage = target_hp - user_hp
        damage_percent = damage.to_f / target.totalhp
        
        score += 60
        AdvancedAI.log("  Endeavor: +60 (#{(damage_percent * 100).to_i}% damage)", "Special")
        
        # COMBO: Follow up with priority move
        priority_moves = user.moves.select { |m| m && m.priority > 0 }
        if priority_moves.any?
          score += 40
          AdvancedAI.log("  Have priority follow-up: +40", "Special")
        end
      else
        score -= 40
        AdvancedAI.log("  Endeavor: -40 (target too low)", "Special")
      end
    end
    
    return score
  end
end

AdvancedAI.log("Special Sacrifice & Utility Moves loaded", "Core")
AdvancedAI.log("  - Pain Split (HP averaging)", "Special")
AdvancedAI.log("  - Healing Wish/Lunar Dance (sacrifice heal)", "Special")
AdvancedAI.log("  - Final Gambit (sacrifice damage)", "Special")
AdvancedAI.log("  - Memento/Misty Explosion", "Special")
AdvancedAI.log("  - Rapid Spin/Defog (hazard removal)", "Special")
AdvancedAI.log("  - Endeavor (HP matching)", "Special")
AdvancedAI.log("  - False Swipe = -999 in PVP (already in Move_Scorer)", "Special")

### FILE: Advanced_Abilities.rb ###
#===============================================================================
# Advanced AI System - Advanced Ability Awareness
# Handles complex ability interactions and strategic implications
#===============================================================================

module AdvancedAI
  # Ability threat multipliers for strategic awareness
  SNOWBALL_ABILITIES = {
    :MOXIE         => 1.8,  # +1 Atk on KO - snowball threat
    :BEASTBOOST    => 1.8,  # +1 highest stat on KO
    :SOULDEVOURING => 1.8,  # +1 all stats on KO (custom)
    :CHILLINGNEIGH => 1.7,  # +1 Atk on KO (Ice)
    :GRIMNEIGH     => 1.7,  # +1 SpAtk on KO (Dark)
  }
  
  SPEED_SHIFT_ABILITIES = {
    :UNBURDEN      => 2.5,  # 2x Speed after item consumed - MASSIVE threat
    :SLOWSTART     => 0.3,  # Half Atk/Speed for 5 turns - weakling
    :SPEEDBOOST    => 1.6,  # +1 Speed per turn
  }
  
  REVERSE_ABILITIES = {
    :CONTRARY      => 2.0,  # Inverts stat changes (Leaf Storm = +2 SpAtk)
    :DEFIANT       => 1.7,  # +2 Atk when stat lowered
    :COMPETITIVE   => 1.7,  # +2 SpAtk when stat lowered
  }
  
  SWITCH_ABILITIES = {
    :REGENERATOR   => 1.4,  # Heals 33% on switch-out - free recovery
    :NATURALCURE   => 1.3,  # Cures status on switch-out
    :SHEDSKIN      => 1.2,  # 33% chance to cure status per turn
  }
end

class Battle::AI
  # ============================================================================
  # SNOWBALL THREAT DETECTION (Moxie, Beast Boost)
  # ============================================================================
  
  alias advanced_abilities_pbRegisterMove pbRegisterMove
  def pbRegisterMove(user, move)
    score = advanced_abilities_pbRegisterMove(user, move)
    
    return score unless user && move
    
    # Check all targets for snowball abilities
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      # SNOWBALL ABILITIES: Don't feed kills to Moxie/Beast Boost users
      if AdvancedAI::SNOWBALL_ABILITIES.key?(target.ability_id)
        score += evaluate_snowball_threat(user, move, target)
      end
      
      # REVERSE ABILITIES: Stat drops = stat boosts!
      if AdvancedAI::REVERSE_ABILITIES.key?(target.ability_id)
        score += evaluate_reverse_ability(user, move, target)
      end
      
      # SPEED SHIFT: Unburden activation warning
      if target.ability_id == :UNBURDEN && target.item
        score += evaluate_unburden_threat(user, move, target)
      end
    end
    
    # REGENERATOR: Bonus for forcing switch
    if move.function_code == "SwitchOutUserStatusMove" # Whirlwind, Roar, Dragon Tail
      @battle.allOtherSideBattlers(user.index).each do |target|
        next unless target && target.ability_id == :REGENERATOR
        score -= 15  # Penalty - they get free 33% heal
        AdvancedAI.log("  #{move.name} vs Regenerator: -15 (free heal on force-out)", "Abilities")
      end
    end
    
    return score
  end
  
  # Evaluate Moxie/Beast Boost snowball threat
  def evaluate_snowball_threat(user, move, target)
    return 0 unless move.damagingMove?
    
    score = 0
    ability_name = GameData::Ability.get(target.ability_id).name
    
    # Check if this move would KO the target
    rough_damage = AdvancedAI::CombatUtilities.estimate_damage(user, move, target, as_percent: true)
    would_ko = (rough_damage >= target.hp.to_f / target.totalhp)
    
    if would_ko
      # KOing Moxie/Beast Boost user is GOOD (prevent snowball)
      score += 30
      AdvancedAI.log("  KO #{target.name} (#{ability_name}): +30 (prevent snowball)", "Abilities")
    else
      # DON'T leave them at low HP for easy snowball
      hp_percent = target.hp.to_f / target.totalhp
      if hp_percent < 0.35 && rough_damage > 0.2
        score -= 20  # They can easily KO us next turn and get +1
        AdvancedAI.log("  Damage to #{ability_name}: -20 (sets up snowball)", "Abilities")
      end
    end
    
    # If they already have +1 or more, URGENT to KO
    if target.stages[:ATTACK] >= 1 || target.stages[:SPECIAL_ATTACK] >= 1
      score += 25
      AdvancedAI.log("  #{ability_name} already boosted: +25 (stop snowball)", "Abilities")
    end
    
    return score
  end
  
  # Evaluate Contrary/Defiant/Competitive
  def evaluate_reverse_ability(user, move, target)
    score = 0
    ability_id = target.ability_id
    
    case ability_id
    when :CONTRARY
      # DON'T use stat-lowering moves on Contrary users (they become buffs!)
      if move.statusMove?
        # Check if move lowers target's stats
        stat_drops = [:LOWER_TARGET_ATK_1, :LOWER_TARGET_DEF_1, :LOWER_TARGET_SPATK_1, 
                      :LOWER_TARGET_SPDEF_1, :LOWER_TARGET_SPEED_1, :LOWER_TARGET_ATK_2].include?(move.function_code.to_sym)
        
        if stat_drops
          score -= 50  # NEVER do this
          AdvancedAI.log("  #{move.name} vs Contrary: -50 (inverts to buff!)", "Abilities")
        end
      end
      
      # Contrary users love Leaf Storm, Draco Meteor, Overheat (self-drops = boosts)
      # Prioritize KOing them
      if move.damagingMove?
        score += 15
        AdvancedAI.log("  Damage to Contrary: +15 (prevent reverse setup)", "Abilities")
      end
      
    when :DEFIANT, :COMPETITIVE
      # DON'T use Intimidate switch-ins or stat-lowering moves
      if move.statusMove?
        stat_drops = [:LOWER_TARGET_ATK_1, :LOWER_TARGET_SPEED_1].include?(move.function_code.to_sym)
        if stat_drops
          score -= 40  # They get +2 Atk/SpAtk!
          AdvancedAI.log("  #{move.name} vs #{ability_id}: -40 (triggers +2)", "Abilities")
        end
      end
      
      # Intimidate on-switch warning (handled elsewhere but noted here)
      if user.ability_id == :INTIMIDATE && move.function_code == "SwitchOutUserPassOnEffects"
        score -= 30
        AdvancedAI.log("  Intimidate vs #{ability_id}: -30 (triggers +2)", "Abilities")
      end
    end
    
    return score
  end
  
  # Evaluate Unburden threat
  def evaluate_unburden_threat(user, move, target)
    return 0 unless target.item  # No item = no threat
    
    score = 0
    
    # If move removes item (Knock Off, Thief)
    if [:KNOCK_OFF, :THIEF, :COVET].include?(move.function_code.to_sym)
      score -= 35  # DON'T trigger Unburden unless KO
      AdvancedAI.log("  #{move.name} vs Unburden: -35 (doubles speed!)", "Abilities")
      
      # Unless it KOs
      rough_damage = CombatUtilities.estimate_damage(user.battler, move, target, as_percent: true)
      if rough_damage >= target.hp.to_f / target.totalhp
        score += 50  # KO is fine
        AdvancedAI.log("  But KOs: +50 (worth it)", "Abilities")
      end
    end
    
    # Warn if target has consumable item (Berry) that could trigger Unburden
    consumable_items = [:SITRUSBERRY, :LUMBERRY, :ORANBERRY, :AGUAVBERRY, 
                       :FIGYBERRY, :IAPAPABERRY, :MAGOBERRY, :WIKIBERRY]
    if consumable_items.include?(target.item_id)
      score -= 10  # Might trigger via damage
      AdvancedAI.log("  Unburden + Berry: -10 (might auto-trigger)", "Abilities")
    end
    
    return score
  end
  
  # ============================================================================
  # REGENERATOR SWITCH PREDICTION
  # ============================================================================
  
  def predict_regenerator_switch(target)
    return false unless target.ability_id == :REGENERATOR
    
    hp_percent = target.hp.to_f / target.totalhp
    
    # Regenerator users switch out at 40-60% HP for free recovery
    if hp_percent < 0.6 && hp_percent > 0.2
      AdvancedAI.log("  Regenerator switch predicted (#{(hp_percent * 100).to_i}% HP)", "Abilities")
      return true
    end
    
    return false
  end
  
  # ============================================================================
  # ABILITY-BASED THREAT ASSESSMENT
  # ============================================================================
  
  def calculate_ability_threat_modifier(battler)
    return 1.0 unless battler.ability_id
    
    multiplier = 1.0
    
    # Snowball abilities
    if AdvancedAI::SNOWBALL_ABILITIES.key?(battler.ability_id)
      base = AdvancedAI::SNOWBALL_ABILITIES[battler.ability_id]
      # Higher if already boosted
      if battler.stages[:ATTACK] >= 1 || battler.stages[:SPECIAL_ATTACK] >= 1
        multiplier = base * 1.3
      else
        multiplier = base
      end
    end
    
    # Speed shift abilities
    if AdvancedAI::SPEED_SHIFT_ABILITIES.key?(battler.ability_id)
      multiplier = AdvancedAI::SPEED_SHIFT_ABILITIES[battler.ability_id]
      
      # Unburden: Only threat if item consumed
      if battler.ability_id == :UNBURDEN && battler.item
        multiplier = 1.0  # Not active yet
      elsif battler.ability_id == :UNBURDEN && !battler.item
        multiplier = 2.5  # ACTIVE - extreme threat
      end
    end
    
    # Reverse abilities
    if AdvancedAI::REVERSE_ABILITIES.key?(battler.ability_id)
      multiplier = AdvancedAI::REVERSE_ABILITIES[battler.ability_id]
    end
    
    # Switch abilities
    if AdvancedAI::SWITCH_ABILITIES.key?(battler.ability_id)
      multiplier = AdvancedAI::SWITCH_ABILITIES[battler.ability_id]
    end
    
    return multiplier
  end
end

AdvancedAI.log("Advanced Abilities System loaded", "Core")
AdvancedAI.log("  - Snowball detection (Moxie, Beast Boost)", "Abilities")
AdvancedAI.log("  - Reverse abilities (Contrary, Defiant, Competitive)", "Abilities")
AdvancedAI.log("  - Speed shift (Unburden, Speed Boost)", "Abilities")
AdvancedAI.log("  - Switch abilities (Regenerator, Natural Cure)", "Abilities")

### FILE: Critical_Hits.rb ###
#===============================================================================
# Advanced AI System - Critical Hit Strategies
# Super Luck, Sniper, high crit moves, Focus Energy builds
#===============================================================================

module AdvancedAI
  module CriticalHits
    #===========================================================================
    # Critical Hit Move Lists
    #===========================================================================
    
    HIGH_CRIT_MOVES = [
      :AEROBLAST, :AIRCUTTER, :ATTACKORDER, :BLAZEKICK, :CRABHAMMER,
      :CROSSCHOP, :CROSSPOISON, :DRILLRUN, :KARATECHOP, :LEAFBLADE,
      :NIGHTSLASH, :POISONTAIL, :PSYCHOCUT, :RAZORLEAF, :RAZORWIND,
      :SHADOWCLAW, :SLASH, :SPACIALREND, :STONEEDGE
      # Note: STORMTHROW, FLOWERTRICK, WICKEDBLOW, SURGINGSTRIKES are ALWAYS_CRIT
    ]
    
    ALWAYS_CRIT_MOVES = [
      :FROSTBREATH, :STORMTHROW, :WICKEDBLOW, :SURGINGSTRIKES, :FLOWERTRICK
    ]
    
    #===========================================================================
    # Critical Hit Rate Calculation
    #===========================================================================
    
    # Calculate crit stage and rate
    def self.get_crit_stage(attacker, move)
      stage = 0
      
      # Move's inherent crit ratio
      if move && HIGH_CRIT_MOVES.include?(move.id)
        stage += 1
      end
      
      # Always crit moves
      if move && ALWAYS_CRIT_MOVES.include?(move.id)
        return { stage: 99, rate: 100 }
      end
      
      # Super Luck ability
      if attacker.ability_id == :SUPERLUCK
        stage += 1
      end
      
      # Focus Energy
      if attacker.effects[PBEffects::FocusEnergy] && attacker.effects[PBEffects::FocusEnergy] > 0
        stage += 2
      end
      
      # Lansat Berry (eaten)
      # Note: Need to track if consumed
      
      # Items
      case attacker.item_id
      when :SCOPELENS, :RAZORCLAW
        stage += 1
      when :LUCKYPUNCH  # Chansey only
        if attacker.species == :CHANSEY
          stage += 2
        end
      when :LEEK, :STICK  # Farfetch'd / Sirfetch'd only
        if [:FARFETCHD, :SIRFETCHD, :FARFETCHDGALAR].include?(attacker.species)
          stage += 2
        end
      end
      
      # Convert stage to rate
      rate = case stage
             when 0 then 4.17   # 1/24
             when 1 then 12.5   # 1/8
             when 2 then 50     # 1/2
             else 100           # Always crit at stage 3+
             end
      
      { stage: [stage, 3].min, rate: rate }
    end
    
    #===========================================================================
    # Sniper Ability
    #===========================================================================
    
    # Sniper boosts crit damage from 1.5x to 2.25x
    def self.evaluate_sniper_build(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 70
      return 0 unless attacker.ability_id == :SNIPER
      return 0 unless move && move.damagingMove?
      
      score = 0
      crit_data = get_crit_stage(attacker, move)
      
      # Sniper makes high crit builds very strong
      if crit_data[:rate] >= 50
        score += 40  # 2.25x damage on half hits
      elsif crit_data[:rate] >= 12.5
        score += 20
      end
      
      # Always crit = 2.25x every time
      if ALWAYS_CRIT_MOVES.include?(move.id)
        score += 60
      end
      
      score
    end
    
    #===========================================================================
    # Focus Energy Evaluation
    #===========================================================================
    
    def self.evaluate_focus_energy(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless move.id == :FOCUSENERGY
      
      score = 0
      
      # Already have Focus Energy?
      if attacker.effects[PBEffects::FocusEnergy] && attacker.effects[PBEffects::FocusEnergy] > 0
        return -80
      end
      
      # Check if we have high crit moves
      high_crit_count = attacker.moves.count { |m| m && HIGH_CRIT_MOVES.include?(m.id) }
      score += high_crit_count * 20
      
      # Super Luck makes Focus Energy = 100% crits
      if attacker.ability_id == :SUPERLUCK
        score += 50
      end
      
      # Scope Lens also stacks
      if attacker.item_id == :SCOPELENS
        score += 30
      end
      
      # Sniper makes crits devastating
      if attacker.ability_id == :SNIPER
        score += 40
      end
      
      # Kingambit special: Kowtow Cleave always crits + high attack
      if attacker.species == :KINGAMBIT
        score += 35
      end
      
      score
    end
    
    #===========================================================================
    # Critical Hit Build Synergy
    #===========================================================================
    
    # Evaluate high crit move usage
    def self.evaluate_high_crit_move(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 55
      return 0 unless move && HIGH_CRIT_MOVES.include?(move.id)
      
      score = 0
      crit_data = get_crit_stage(attacker, move)
      
      # Base bonus for crit potential
      score += (crit_data[:rate] / 5).to_i
      
      # Crits ignore defense boosts
      if target && target.stages[:DEFENSE] > 0 && move.physicalMove?
        score += target.stages[:DEFENSE] * 10  # Bypass their bulk
      end
      if target && target.stages[:SPECIAL_DEFENSE] > 0 && move.specialMove?
        score += target.stages[:SPECIAL_DEFENSE] * 10
      end
      
      # Crits ignore Reflect/Light Screen
      our_opp_side = battle.sides[(attacker.index + 1) % 2]
      if move.physicalMove? && our_opp_side.effects[PBEffects::Reflect] && our_opp_side.effects[PBEffects::Reflect] > 0
        score += 15
      end
      if move.specialMove? && our_opp_side.effects[PBEffects::LightScreen] && our_opp_side.effects[PBEffects::LightScreen] > 0
        score += 15
      end
      
      score
    end
    
    # Always crit moves are premium
    def self.evaluate_always_crit_move(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 50
      return 0 unless move && ALWAYS_CRIT_MOVES.include?(move.id)
      
      score = 20  # Base bonus for guaranteed crit
      
      # Sniper makes these amazing
      if attacker.ability_id == :SNIPER
        score += 35
      end
      
      score
    end
    
    #===========================================================================
    # Counter-Play: Battle Armor / Shell Armor
    #===========================================================================
    
    def self.check_crit_immunity(battle, target, move, skill_level = 100)
      return 0 unless skill_level >= 50
      return 0 unless target
      return 0 unless move && move.damagingMove?
      
      crit_immune = [:BATTLEARMOR, :SHELLARMOR]
      
      if crit_immune.include?(target.ability_id)
        # Reduce value of crit builds
        # Use battle parameter, not @battle (this is a module method)
        attacker = battle&.battlers&.find { |b| b && !b.fainted? }
        crit_data = get_crit_stage(attacker, move)
        
        if HIGH_CRIT_MOVES.include?(move.id) || ALWAYS_CRIT_MOVES.include?(move.id)
          return -20  # Our crit advantage is nullified
        end
      end
      
      0
    end
    
    #===========================================================================
    # Lucky Chant Awareness
    #===========================================================================
    
    def self.check_lucky_chant(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 60
      
      opp_side = battle.sides[(attacker.index + 1) % 2]
      
      # Lucky Chant prevents crits
      if opp_side.effects[PBEffects::LuckyChant] && opp_side.effects[PBEffects::LuckyChant] > 0
        if HIGH_CRIT_MOVES.include?(move.id) || ALWAYS_CRIT_MOVES.include?(move.id)
          return -25  # Crit advantage nullified
        end
      end
      
      0
    end
    
    #===========================================================================
    # Dire Hit Item Usage (for future implementation)
    #===========================================================================
    
    def self.should_use_dire_hit?(battle, battler, skill_level = 100)
      return false unless skill_level >= 70
      
      # Would Focus Energy be better?
      return false if battler.effects[PBEffects::FocusEnergy] && battler.effects[PBEffects::FocusEnergy] > 0
      
      # Check crit build potential
      has_high_crit = battler.moves.any? { |m| m && HIGH_CRIT_MOVES.include?(m.id) }
      has_sniper = battler.ability_id == :SNIPER
      
      (has_high_crit || has_sniper) && battler.hp > battler.totalhp * 0.5
    end
  end
end

# API Methods
module AdvancedAI
  def self.get_crit_stage(attacker, move)
    CriticalHits.get_crit_stage(attacker, move)
  end
  
  def self.evaluate_sniper_build(battle, attacker, move, skill_level = 100)
    CriticalHits.evaluate_sniper_build(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_focus_energy(battle, attacker, move, skill_level = 100)
    CriticalHits.evaluate_focus_energy(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_high_crit_move(battle, attacker, move, target, skill_level = 100)
    CriticalHits.evaluate_high_crit_move(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_always_crit_move(battle, attacker, move, skill_level = 100)
    CriticalHits.evaluate_always_crit_move(battle, attacker, move, skill_level)
  end
  
  def self.check_crit_immunity(battle, target, move, skill_level = 100)
    CriticalHits.check_crit_immunity(battle, target, move, skill_level)
  end
  
  def self.is_high_crit_move?(move)
    return false unless move
    CriticalHits::HIGH_CRIT_MOVES.include?(move.id) || CriticalHits::ALWAYS_CRIT_MOVES.include?(move.id)
  end
end

AdvancedAI.log("Critical Hit Strategies loaded", "Crit")
AdvancedAI.log("  - Crit stage calculation", "Crit")
AdvancedAI.log("  - Super Luck awareness", "Crit")
AdvancedAI.log("  - Sniper build optimization", "Crit")
AdvancedAI.log("  - Focus Energy evaluation", "Crit")
AdvancedAI.log("  - Always-crit moves (Wicked Blow, etc.)", "Crit")
AdvancedAI.log("  - Battle Armor / Shell Armor counter-play", "Crit")
AdvancedAI.log("  - Lucky Chant awareness", "Crit")

### FILE: Field_Effects.rb ###
#===============================================================================
# Advanced AI System - Field Effects
# Weather, Terrain, Trick Room, Gravity Awareness
#===============================================================================

module AdvancedAI
  module FieldEffects
    # Main Function: Calculates Field Effect Bonus
    def self.field_effect_bonus(battle, move, user, target, skill_level = 100)
      return 0 unless skill_level >= 70
      
      bonus = 0
      bonus += weather_bonus(battle, move, user, target)
      bonus += terrain_bonus(battle, move, user, target)
      bonus += trick_room_bonus(battle, move, user, target)
      bonus += gravity_bonus(battle, move, user, target)
      bonus += room_bonus(battle, move, user, target)
      
      bonus
    end
    
    # Weather Bonus
    def self.weather_bonus(battle, move, user, target)
      return 0 unless battle.field.weather
      
      bonus = 0
      weather = battle.field.weather
      
      case weather
      when :Sun, :HarshSun
        if move.type == :FIRE
          bonus += 30  # Fire moves x1.5
        elsif move.type == :WATER
          bonus -= 30  # Water moves x0.5
        end
        
        # Weather Ball
        bonus += 20 if move.id == :WEATHERBALL
        # Growth gives +2/+2 in Sun instead of +1/+1
        bonus += 30 if move.id == :GROWTH  # Doubled effectiveness
        # Solar Beam/Blade no charge
        bonus += 25 if [:SOLARBEAM, :SOLARBLADE].include?(move.id)
        
        # Solar Power risk assessment - user loses 1/8 HP each turn
        if user.ability_id == :SOLARPOWER
          bonus -= 10 if user.hp < user.totalhp * 0.4  # Low HP = risky
        end
        
      when :Rain, :HeavyRain
        if move.type == :WATER
          bonus += 30  # Water moves x1.5
        elsif move.type == :FIRE
          bonus -= 30  # Fire moves x0.5
        end
        
        bonus += 25 if move.id == :THUNDER || move.id == :HURRICANE  # 100% accuracy
        bonus += 20 if move.id == :WEATHERBALL
        
      when :Sandstorm
        bonus += 20 if move.id == :WEATHERBALL
        bonus += 15 if move.id == :SHOREUP  # Heals more
        
        # Rock types get +50% SpDef boost in Sandstorm
        if move.specialMove? && target && target.pbHasType?(:ROCK)
          bonus -= 20  # Special attacks do less damage to Rock types
        end
        
        # Non-immune types take residual damage
        if target && !target.pbHasType?(:ROCK) && !target.pbHasType?(:STEEL) && !target.pbHasType?(:GROUND)
          bonus += 10  # Target takes residual damage
        end
        
        # Sand Veil evasion - accuracy moves less reliable
        if target && target.ability_id == :SANDVEIL
          bonus -= 10  # 20% evasion boost makes moves less accurate
        end
        
      when :Hail, :Snow
        bonus += 30 if move.id == :BLIZZARD  # 100% accuracy
        bonus += 20 if move.id == :WEATHERBALL
        bonus += 25 if move.id == :AURORAVEIL  # Aurora Veil only in Hail/Snow
        
        # Ice types immune to Hail damage
        bonus += 5 if user.pbHasType?(:ICE)
        
        # Snow Cloak evasion - accuracy moves less reliable
        if target && target.ability_id == :SNOWCLOAK
          bonus -= 10  # 20% evasion boost makes moves less accurate
        end
      end
      
      # Ability Synergies
      ability = user.ability_id
      case ability
      when :SWIFTSWIM
        bonus += 20 if weather == :Rain || weather == :HeavyRain
      when :CHLOROPHYLL
        bonus += 20 if weather == :Sun || weather == :HarshSun
      when :SANDRUSH
        bonus += 20 if weather == :Sandstorm
      when :SLUSHRUSH
        bonus += 20 if weather == :Hail || weather == :Snow
      # Paradox Pokemon abilities
      when :PROTOSYNTHESIS
        if weather == :Sun || weather == :HarshSun || user.item_id == :BOOSTERENERGY
          bonus += 25  # Stat boost active
          # Extra bonus if Speed is their highest stat (speed control)
          if user.speed >= [user.attack, user.defense, user.spatk, user.spdef].max
            bonus += 15  # Speed Protosynthesis is very strong
          end
        end
      end
      
      # Check target for Quark Drive (Electric Terrain activates it but handled in terrain_bonus)
      if target && target.ability_id == :QUARKDRIVE && target.item_id == :BOOSTERENERGY
        bonus -= 15  # Target has Quark Drive boost from Booster Energy
      end
      
      bonus
    end
    
    # Terrain Bonus
    def self.terrain_bonus(battle, move, user, target)
      return 0 unless battle.field.terrain
      
      bonus = 0
      terrain = battle.field.terrain
      
      case terrain
      when :Electric
        if move.type == :ELECTRIC && user.affectedByTerrain?
          bonus += 25  # x1.3 power
        end
        bonus -= 40 if move.id == :SLEEPPOWDER || move.id == :SPORE  # Can't sleep
        
      when :Grassy
        if move.type == :GRASS && user.affectedByTerrain?
          bonus += 25  # x1.3 power
        end
        bonus -= 20 if move.id == :EARTHQUAKE || move.id == :MAGNITUDE  # x0.5 power
        bonus += 15 if move.id == :GIGADRAIN || move.id == :DRAINPUNCH  # Better healing
        
        # Grassy Glide gets priority
        bonus += 30 if move.id == :GRASSYGLIDE && user.affectedByTerrain?
        
        # End-of-turn 1/16 HP heal for grounded Pokemon
        # Makes stalling/defensive play more valuable
        if user.affectedByTerrain? && move.statusMove?
          bonus += 8  # Small bonus for staying in and healing
        end
        
      when :Psychic
        if move.type == :PSYCHIC && user.affectedByTerrain?
          bonus += 25  # x1.3 power
        end
        prio = move.respond_to?(:priority) ? move.priority : (move.respond_to?(:move) ? move.move.priority : 0)
        bonus -= 40 if prio > 0  # Priority blocked
        
      when :Misty
        if move.type == :DRAGON
          bonus -= 30  # x0.5 power
        end
        bonus -= 40 if move.statusMove? && target && target.affectedByTerrain?  # Status blocked
        # Misty Explosion boost
        bonus += 25 if move.id == :MISTYEXPLOSION
      end
      
      # Ability Synergies
      ability = user.ability_id
      bonus += 20 if ability == :SURGESURFER && terrain == :Electric
      
      # Quark Drive (Paradox Pokemon) - activates in Electric Terrain or with Booster Energy
      if ability == :QUARKDRIVE
        if terrain == :Electric || user.item_id == :BOOSTERENERGY
          bonus += 25  # Stat boost active
          # Extra bonus if Speed is their highest stat
          if user.speed >= [user.attack, user.defense, user.spatk, user.spdef].max
            bonus += 15  # Speed Quark Drive is very strong
          end
        end
      end
      
      # Check target for Protosynthesis with Booster Energy (Sun handled in weather_bonus)
      if target && target.ability_id == :PROTOSYNTHESIS && target.item_id == :BOOSTERENERGY
        bonus -= 15  # Target has Protosynthesis boost from Booster Energy
      end
      
      bonus
    end
    
    # Trick Room Bonus
    def self.trick_room_bonus(battle, move, user, target)
      return 0 unless battle.field.effects[PBEffects::TrickRoom] > 0
      
      bonus = 0
      
      # If Trick Room active, prefer slow Pokemon
      if user.pbSpeed < 50
        bonus += 20  # Slow Pokemon benefits
      elsif user.pbSpeed > 120
        bonus -= 20  # Fast Pokemon penalized
      end
      
      # Priority Moves are stronger in Trick Room
      prio = move.respond_to?(:priority) ? move.priority : (move.respond_to?(:move) ? move.move.priority : 0)
      bonus += 15 if prio > 0
      
      bonus
    end
    
    # Gravity Bonus
    def self.gravity_bonus(battle, move, user, target)
      return 0 unless battle.field.effects[PBEffects::Gravity] > 0
      
      bonus = 0
      
      # OHKO moves 100% accuracy
      if [:GUILLOTINE, :FISSURE, :SHEERCOLD, :HORNDRILL].include?(move.id)
        bonus += 40
      end
      
      # Ground moves hit Flying/Levitate
      if move.type == :GROUND && target
        bonus += 30 if target.pbHasType?(:FLYING) || target.ability_id == :LEVITATE
      end
      
      bonus
    end
    
    # Room Effects (Magic Room, Wonder Room)
    def self.room_bonus(battle, move, user, target)
      bonus = 0
      
      # Magic Room (items disabled)
      if battle.field.effects[PBEffects::MagicRoom] > 0
        # Item-dependent Moves are weaker
        bonus -= 20 if move.id == :FLING || move.id == :NATURALGIFT
      end
      
      # Wonder Room (Def/SpDef swapped)
      if battle.field.effects[PBEffects::WonderRoom] > 0
        if move.physicalMove? && target && target.spdef > target.defense
          bonus += 15  # Physical hits SpDef now (better)
        elsif move.specialMove? && target && target.defense > target.spdef
          bonus += 15  # Special hits Def now (better)
        end
      end
      
      bonus
    end
    
    # Weather Setting Bonus
    def self.weather_setting_bonus(battle, move, user, skill_level = 100)
      return 0 unless skill_level >= 70
      
      bonus = 0
      
      # Check if Team benefits from Weather
      party = battle.pbParty(user.index)
      
      case move.id
      when :SUNNYDAY
        sun_users = party.count { |p| p && [:CHLOROPHYLL, :DROUGHT, :SOLARPOWER].include?(p.ability) }
        bonus += sun_users * 20
        
      when :RAINDANCE
        rain_users = party.count { |p| p && [:SWIFTSWIM, :DRIZZLE, :RAINDISH].include?(p.ability) }
        bonus += rain_users * 20
        
      when :SANDSTORM
        sand_users = party.count { |p| p && [:SANDRUSH, :SANDSTREAM, :SANDFORCE].include?(p.ability) }
        bonus += sand_users * 20
        
      when :HAIL, :SNOWSCAPE
        hail_users = party.count { |p| p && [:SLUSHRUSH, :SNOWWARNING, :ICEBODY].include?(p.ability) }
        bonus += hail_users * 20
      end
      
      bonus
    end
  end
  
  #===========================================================================
  # Weather War Aggression - Override opponent's weather
  #===========================================================================
  module FieldEffects
    def self.weather_war_bonus(battle, move, user, skill_level = 100)
      return 0 unless skill_level >= 75
      
      bonus = 0
      current_weather = battle.field.weather
      
      # Weather-setting moves
      weather_moves = {
        :SUNNYDAY   => [:Sun, :HarshSun],
        :RAINDANCE  => [:Rain, :HeavyRain],
        :SANDSTORM  => [:Sandstorm],
        :HAIL       => [:Hail],
        :SNOWSCAPE  => [:Snow]
      }
      
      return 0 unless weather_moves.key?(move.id)
      target_weathers = weather_moves[move.id]
      
      # Already have our preferred weather
      return -50 if target_weathers.include?(current_weather)
      
      # Check if opponent BENEFITS from current weather
      opponent_benefits = false
      battle.allOtherSideBattlers(user.index).each do |opp|
        next unless opp && !opp.fainted?
        
        case current_weather
        when :Sun, :HarshSun
          if [:CHLOROPHYLL, :SOLARPOWER, :LEAFGUARD, :FLOWERGIFT, :PROTOSYNTHESIS].include?(opp.ability_id)
            opponent_benefits = true
          end
          if opp.moves.any? { |m| m && m.type == :FIRE }
            opponent_benefits = true
          end
        when :Rain, :HeavyRain
          if [:SWIFTSWIM, :RAINDISH, :DRYSKIN, :HYDRATION].include?(opp.ability_id)
            opponent_benefits = true
          end
        when :Sandstorm
          if [:SANDRUSH, :SANDFORCE, :SANDVEIL].include?(opp.ability_id)
            opponent_benefits = true
          end
        when :Hail, :Snow
          if [:SLUSHRUSH, :ICEBODY, :SNOWCLOAK].include?(opp.ability_id)
            opponent_benefits = true
          end
        end
      end
      
      # HIGH PRIORITY: Override opponent's beneficial weather
      if opponent_benefits
        bonus += 60  # Actively disrupt their weather advantage
        
        # Even higher if they JUST set it
        if battle.field.weatherDuration && battle.field.weatherDuration >= 4
          bonus += 20  # They just set it, maximum disruption
        end
      end
      
      # Check if WE benefit from the new weather
      party = battle.pbParty(user.index)
      our_synergy = count_weather_synergy(party, target_weathers.first)
      bonus += our_synergy * 15
      
      bonus
    end
    
    # Terrain War - Override opponent's terrain
    def self.terrain_war_bonus(battle, move, user, skill_level = 100)
      return 0 unless skill_level >= 75
      
      bonus = 0
      current_terrain = battle.field.terrain
      
      terrain_moves = {
        :ELECTRICTERRAIN => :Electric,
        :GRASSYTERRAIN   => :Grassy,
        :PSYCHICTERRAIN  => :Psychic,
        :MISTYTERRAIN    => :Misty
      }
      
      return 0 unless terrain_moves.key?(move.id)
      target_terrain = terrain_moves[move.id]
      
      # Already have this terrain
      return -50 if current_terrain == target_terrain
      
      # Check if opponent benefits from CURRENT terrain
      opponent_benefits = false
      battle.allOtherSideBattlers(user.index).each do |opp|
        next unless opp && !opp.fainted?
        
        case current_terrain
        when :Electric
          if [:SURGESURFER, :QUARKDRIVE].include?(opp.ability_id)
            opponent_benefits = true
          end
          if opp.pbHasType?(:ELECTRIC) && (opp.respond_to?(:affectedByTerrain?) ? opp.affectedByTerrain? : true)
            opponent_benefits = true
          end
        when :Grassy
          if opp.pbHasType?(:GRASS) && (opp.respond_to?(:affectedByTerrain?) ? opp.affectedByTerrain? : true)
            opponent_benefits = true
          end
        when :Psychic
          # Psychic Terrain blocks OUR priority
          if user.moves.any? { |m| m && m.priority > 0 && m.damagingMove? }
            opponent_benefits = true  # They're protected from our priority!
          end
        end
      end
      
      if opponent_benefits
        bonus += 50
      end
      
      bonus
    end
    
    def self.count_weather_synergy(party, weather)
      synergy = {
        :Sun  => [:CHLOROPHYLL, :SOLARPOWER, :LEAFGUARD, :FLOWERGIFT, :HARVEST],
        :Rain => [:SWIFTSWIM, :RAINDISH, :DRYSKIN, :HYDRATION],
        :Sandstorm => [:SANDRUSH, :SANDFORCE, :SANDVEIL],
        :Hail => [:SLUSHRUSH, :ICEBODY, :SNOWCLOAK],
        :Snow => [:SLUSHRUSH, :ICEBODY, :SNOWCLOAK]
      }
      
      abilities = synergy[weather] || []
      party.count { |p| p && abilities.include?(p.ability) }
    end
    
    #===========================================================================
    # Mimicry Type Consideration
    #===========================================================================
    def self.mimicry_type_from_terrain(terrain)
      case terrain
      when :Electric then :ELECTRIC
      when :Grassy   then :GRASS
      when :Psychic  then :PSYCHIC
      when :Misty    then :FAIRY
      else nil
      end
    end
    
    def self.mimicry_bonus(battle, move, user, target, skill_level = 100)
      return 0 unless skill_level >= 70
      
      bonus = 0
      
      # Check if target has Mimicry
      if target && target.ability_id == :MIMICRY
        actual_type = mimicry_type_from_terrain(battle.field.terrain)
        
        if actual_type
          eff = Effectiveness.calculate(move.type, actual_type, target.types[1])
          
          if Effectiveness.super_effective?(eff)
            bonus += 25  # Our move is SE against their Mimicry type!
          elsif Effectiveness.not_very_effective?(eff)
            bonus -= 15
          elsif Effectiveness.ineffective?(eff)
            bonus -= 50
          end
        end
      end
      
      # Check if OUR Pokemon has Mimicry
      if user.ability_id == :MIMICRY
        new_type = mimicry_type_from_terrain(battle.field.terrain)
        
        if new_type && move.type == new_type
          bonus += 20  # We get STAB from Mimicry!
        end
      end
      
      bonus
    end
  end
end

# API-Wrapper
module AdvancedAI
  def self.field_effect_bonus(battle, move, user, target, skill_level = 100)
    FieldEffects.field_effect_bonus(battle, move, user, target, skill_level)
  end
  
  def self.weather_bonus(battle, move, user, target)
    FieldEffects.weather_bonus(battle, move, user, target)
  end
  
  def self.terrain_bonus(battle, move, user, target)
    FieldEffects.terrain_bonus(battle, move, user, target)
  end
  
  def self.trick_room_bonus(battle, move, user, target)
    FieldEffects.trick_room_bonus(battle, move, user, target)
  end
  
  def self.weather_setting_bonus(battle, move, user, skill_level = 100)
    FieldEffects.weather_setting_bonus(battle, move, user, skill_level)
  end
end

# Integration in Battle::AI
class Battle::AI
  def apply_field_effects(score, move, user, target)
    skill = @trainer&.skill || 100
    return score unless AdvancedAI.feature_enabled?(:core, skill)
    return score unless target
    
    # user and target are AIBattlers, need real battlers
    real_user = user.respond_to?(:battler) ? user.battler : user
    real_target = target.respond_to?(:battler) ? target.battler : target
    
    score += AdvancedAI.field_effect_bonus(@battle, move, real_user, real_target, skill)
    score += AdvancedAI.weather_setting_bonus(@battle, move, real_user, skill)
    
    return score
  end
end

AdvancedAI.log("Field Effects System loaded", "Field")

### FILE: Hazard_Control.rb ###
#===============================================================================
# Advanced AI System - Hazard Control
# Entry hazard priorities, Defog timing, Heavy-Duty Boots awareness
#===============================================================================

module AdvancedAI
  module HazardControl
    #===========================================================================
    # Hazard Definitions
    #===========================================================================
    
    HAZARD_SETTERS = [:STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB]
    HAZARD_REMOVERS = [:DEFOG, :RAPIDSPIN, :COURTCHANGE, :MORTALSPIN, :TIDYUP]
    
    #===========================================================================
    # Hazard Damage Calculation
    #===========================================================================
    
    # Calculate exact hazard damage for a Pokemon switching in
    def self.calculate_hazard_damage(battle, battler, side_effects)
      return 0 unless battler
      
      total_damage = 0
      
      # Stealth Rock
      if side_effects[PBEffects::StealthRock]
        sr_damage = calculate_stealth_rock_damage(battler)
        total_damage += sr_damage
      end
      
      # Spikes (1, 2, or 3 layers)
      spikes = side_effects[PBEffects::Spikes] || 0
      if spikes > 0 && is_grounded?(battler)
        spikes_damage = case spikes
                        when 1 then battler.totalhp / 8
                        when 2 then battler.totalhp / 6
                        else battler.totalhp / 4  # 3 layers
                        end
        total_damage += spikes_damage
      end
      
      # Toxic Spikes (poison or badly poison)
      # Doesn't do direct damage, but important to track
      
      # Sticky Web (speed drop, not damage)
      
      total_damage
    end
    
    # Stealth Rock damage based on type
    def self.calculate_stealth_rock_damage(battler)
      return 0 unless battler
      
      type_mod = Effectiveness.calculate(:ROCK, *battler.pbTypes(true))
      
      # Base: 1/8 max HP, modified by effectiveness
      base = battler.totalhp / 8
      
      multiplier = type_mod / Effectiveness::NORMAL_EFFECTIVE.to_f
      (base * multiplier).to_i
    end
    
    # Check if grounded (for Spikes/Toxic Spikes/Sticky Web)
    def self.is_grounded?(battler)
      return false unless battler
      
      # Flying type
      return false if battler.pbHasType?(:FLYING)
      
      # Levitate
      return false if battler.ability_id == :LEVITATE
      
      # Air Balloon
      return false if battler.item_id == :AIRBALLOON
      
      # Magnet Rise effect
      if battler.effects[PBEffects::MagnetRise] && battler.effects[PBEffects::MagnetRise] > 0
        return false
      end
      
      # Telekinesis
      if battler.effects[PBEffects::Telekinesis] && battler.effects[PBEffects::Telekinesis] > 0
        return false
      end
      
      true
    end
    
    #===========================================================================
    # Hazard Setting Priority
    #===========================================================================
    
    def self.evaluate_hazard_setting(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 50
      return 0 unless HAZARD_SETTERS.include?(move.id)
      
      score = 0
      opp_side = battle.sides[(attacker.index + 1) % 2]
      
      case move.id
      when :STEALTHROCK
        score += evaluate_stealth_rock(battle, attacker, opp_side, skill_level)
      when :SPIKES
        score += evaluate_spikes(battle, attacker, opp_side, skill_level)
      when :TOXICSPIKES
        score += evaluate_toxic_spikes(battle, attacker, opp_side, skill_level)
      when :STICKYWEB
        score += evaluate_sticky_web(battle, attacker, opp_side, skill_level)
      end
      
      # Penalty if opponent has Defog/Spin user
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      has_removal = opponents.any? do |opp|
        opp.moves.any? { |m| m && HAZARD_REMOVERS.include?(m.id) }
      end
      
      if has_removal
        score -= 15  # They might remove it
      end
      
      # Bonus if opponent switches a lot
      # (Would need switch tracking to implement properly)
      
      score
    end
    
    def self.evaluate_stealth_rock(battle, attacker, opp_side, skill_level)
      # Already up?
      if opp_side.effects[PBEffects::StealthRock]
        return -80
      end
      
      score = 30  # Base value
      
      # Check opponent's team for SR weakness
      opp_party = battle.pbParty((attacker.index + 1) % 2)
      
      opp_party.each do |pkmn|
        next unless pkmn && !pkmn.fainted?
        
        # Party Pokemon use type1/type2, not types array
        type_mod = Effectiveness.calculate(:ROCK, pkmn.type1, pkmn.type2)
        
        if type_mod >= Effectiveness::SUPER_EFFECTIVE_ONE * 2  # 4x weak
          score += 25
        elsif type_mod >= Effectiveness::SUPER_EFFECTIVE_ONE  # 2x weak
          score += 15
        elsif type_mod <= Effectiveness::NOT_VERY_EFFECTIVE_ONE  # Resist
          score -= 5
        end
        
        # Heavy-Duty Boots negates
        if pkmn.item_id == :HEAVYDUTYBOOTS
          score -= 10
        end
      end
      
      score
    end
    
    def self.evaluate_spikes(battle, attacker, opp_side, skill_level)
      layers = opp_side.effects[PBEffects::Spikes] || 0
      
      # Max 3 layers
      if layers >= 3
        return -80
      end
      
      score = 20 - (layers * 5)  # Diminishing returns
      
      # Check grounded opponents
      opp_party = battle.pbParty((attacker.index + 1) % 2)
      grounded = opp_party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted?
        # Party Pokemon use hasType? not pbHasType?, and ability_id not ability
        !pkmn.hasType?(:FLYING) && pkmn.ability_id != :LEVITATE
      end
      
      score += grounded * 10
      
      # Heavy-Duty Boots check
      boots_users = opp_party.count { |p| p && p.item_id == :HEAVYDUTYBOOTS }
      score -= boots_users * 8
      
      score
    end
    
    def self.evaluate_toxic_spikes(battle, attacker, opp_side, skill_level)
      layers = opp_side.effects[PBEffects::ToxicSpikes] || 0
      
      # Max 2 layers
      if layers >= 2
        return -80
      end
      
      score = 25 - (layers * 10)
      
      opp_party = battle.pbParty((attacker.index + 1) % 2)
      
      # Poison/Steel types absorb or are immune
      absorbers = opp_party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted?
        # Party Pokemon use hasType? not pbHasType?
        pkmn.hasType?(:POISON) || pkmn.hasType?(:STEEL)
      end
      
      if absorbers > 0
        score -= absorbers * 15  # Poison types remove T-Spikes
      end
      
      # Grounded non-immune targets
      valid_targets = opp_party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted?
        is_grounded_basic?(pkmn) && !pkmn.hasType?(:POISON) && !pkmn.hasType?(:STEEL)
      end
      
      score += valid_targets * 12
      
      score
    end
    
    def self.evaluate_sticky_web(battle, attacker, opp_side, skill_level)
      # Already up?
      if opp_side.effects[PBEffects::StickyWeb]
        return -80
      end
      
      score = 25
      
      opp_party = battle.pbParty((attacker.index + 1) % 2)
      
      # Fast grounded opponents benefit us
      fast_grounded = opp_party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted?
        is_grounded_basic?(pkmn) && pkmn.speed >= 80
      end
      
      score += fast_grounded * 15
      
      # Defiant/Competitive punish - use ability_id for party Pokemon
      punishers = opp_party.count do |p|
        p && !p.fainted? && [:DEFIANT, :COMPETITIVE, :CONTRARY].include?(p.ability_id)
      end
      
      score -= punishers * 20
      
      score
    end
    
    #===========================================================================
    # Hazard Removal Priority
    #===========================================================================
    
    def self.evaluate_hazard_removal(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 55
      return 0 unless HAZARD_REMOVERS.include?(move.id)
      
      score = 0
      our_side = battle.sides[attacker.index % 2]
      opp_side = battle.sides[(attacker.index + 1) % 2]
      
      case move.id
      when :DEFOG
        score += evaluate_defog(battle, attacker, our_side, opp_side, skill_level)
      when :RAPIDSPIN
        score += evaluate_rapid_spin(battle, attacker, our_side, skill_level)
      when :COURTCHANGE
        score += evaluate_court_change(battle, our_side, opp_side, skill_level)
      when :MORTALSPIN
        score += evaluate_mortal_spin(battle, attacker, our_side, skill_level)
      when :TIDYUP
        score += evaluate_tidy_up_hazards(battle, attacker, skill_level)
      end
      
      score
    end
    
    def self.evaluate_defog(battle, attacker, our_side, opp_side, skill_level)
      score = 0
      
      # Value of removing our hazards
      if our_side.effects[PBEffects::StealthRock]
        score += 25
        
        # Extra value if we have SR-weak Pokemon in back
        party = battle.pbParty(attacker.index)
        sr_weak = party.count do |p|
          next false unless p && !p.fainted? && p != attacker.pokemon
          # Party Pokemon use type1/type2, not types[]
          type_mod = Effectiveness.calculate(:ROCK, p.type1, p.type2)
          type_mod >= Effectiveness::SUPER_EFFECTIVE_ONE
        end
        score += sr_weak * 10
      end
      
      spikes = our_side.effects[PBEffects::Spikes] || 0
      score += spikes * 10
      
      tspikes = our_side.effects[PBEffects::ToxicSpikes] || 0
      score += tspikes * 8
      
      if our_side.effects[PBEffects::StickyWeb]
        score += 20
      end
      
      # Penalty for removing opponent's hazards too
      if opp_side.effects[PBEffects::StealthRock]
        score -= 15
      end
      
      opp_spikes = opp_side.effects[PBEffects::Spikes] || 0
      score -= opp_spikes * 8
      
      # Also removes screens (bad if we have screens)
      if our_side.effects[PBEffects::Reflect] && our_side.effects[PBEffects::Reflect] > 0
        score -= 20
      end
      if our_side.effects[PBEffects::LightScreen] && our_side.effects[PBEffects::LightScreen] > 0
        score -= 20
      end
      
      score
    end
    
    def self.evaluate_rapid_spin(battle, attacker, our_side, skill_level)
      score = 0
      
      # Only removes our side hazards
      if our_side.effects[PBEffects::StealthRock]
        score += 25
      end
      
      spikes = our_side.effects[PBEffects::Spikes] || 0
      score += spikes * 10
      
      tspikes = our_side.effects[PBEffects::ToxicSpikes] || 0
      score += tspikes * 8
      
      if our_side.effects[PBEffects::StickyWeb]
        score += 20
      end
      
      # Removes Leech Seed, Bind, etc.
      if attacker.effects[PBEffects::LeechSeed] && attacker.effects[PBEffects::LeechSeed] >= 0
        score += 15
      end
      
      # Also raises Speed in Gen 8+
      score += 10
      
      # Ghost types make Spin fail
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      ghost_present = opponents.any? { |o| o.pbHasType?(:GHOST) }
      
      if ghost_present
        score -= 40  # Will fail
      end
      
      score
    end
    
    def self.evaluate_court_change(battle, our_side, opp_side, skill_level)
      score = 0
      
      # Swap hazards - good if we have none and they have some
      our_hazards = count_hazards(our_side)
      their_hazards = count_hazards(opp_side)
      
      # Also swaps screens, Tailwind, etc.
      our_screens = count_screens(our_side)
      their_screens = count_screens(opp_side)
      
      # Net hazard advantage
      score += (our_hazards - their_hazards) * 15
      
      # Net screen disadvantage (we lose screens, they gain them)
      score -= (our_screens - their_screens) * 20
      
      score
    end
    
    def self.evaluate_mortal_spin(battle, attacker, our_side, skill_level)
      score = 0
      
      # Rapid Spin + Poison effect
      if our_side.effects[PBEffects::StealthRock]
        score += 20
      end
      
      spikes = our_side.effects[PBEffects::Spikes] || 0
      score += spikes * 8
      
      # Poisons all adjacent opponents
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      poisonable = opponents.count do |o|
        o.status == :NONE && !o.pbHasType?(:POISON) && !o.pbHasType?(:STEEL)
      end
      
      score += poisonable * 15
      
      score
    end
    
    def self.evaluate_tidy_up_hazards(battle, attacker, skill_level)
      score = 0
      
      our_side = battle.sides[attacker.index % 2]
      opp_side = battle.sides[(attacker.index + 1) % 2]
      
      # Removes ALL hazards (both sides)
      our_hazards = count_hazards(our_side)
      their_hazards = count_hazards(opp_side)
      
      score += our_hazards * 15
      score -= their_hazards * 10
      
      # Also removes Substitutes
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      subs = opponents.count { |o| o.effects[PBEffects::Substitute] && o.effects[PBEffects::Substitute] > 0 }
      score += subs * 20
      
      # +1 Atk and Speed
      score += 20
      
      score
    end
    
    #===========================================================================
    # Heavy-Duty Boots Awareness
    #===========================================================================
    
    def self.has_heavy_duty_boots?(battler)
      return false unless battler
      battler.item_id == :HEAVYDUTYBOOTS
    end
    
    def self.evaluate_boots_vs_hazards(battle, battler, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless battler
      
      our_side = battle.sides[battler.index % 2]
      
      score = 0
      
      if has_heavy_duty_boots?(battler)
        # We're immune to hazards - switch in freely
        if our_side.effects[PBEffects::StealthRock]
          sr_damage = calculate_stealth_rock_damage(battler)
          score += (sr_damage * 100 / battler.totalhp)  # % HP saved
        end
        
        spikes = our_side.effects[PBEffects::Spikes] || 0
        if spikes > 0 && is_grounded?(battler)
          score += spikes * 5
        end
      end
      
      score
    end
    
    #===========================================================================
    # Helper Methods
    #===========================================================================
    private
    
    def self.count_hazards(side_effects)
      count = 0
      count += 1 if side_effects[PBEffects::StealthRock]
      count += side_effects[PBEffects::Spikes] || 0
      count += side_effects[PBEffects::ToxicSpikes] || 0
      count += 1 if side_effects[PBEffects::StickyWeb]
      count
    end
    
    def self.count_screens(side_effects)
      count = 0
      count += 1 if side_effects[PBEffects::Reflect] && side_effects[PBEffects::Reflect] > 0
      count += 1 if side_effects[PBEffects::LightScreen] && side_effects[PBEffects::LightScreen] > 0
      count += 1 if side_effects[PBEffects::AuroraVeil] && side_effects[PBEffects::AuroraVeil] > 0
      count
    end
    
    def self.is_grounded_basic?(pokemon)
      return false unless pokemon
      # Party Pokemon (Pokemon objects) use hasType? and ability_id
      !pokemon.hasType?(:FLYING) && pokemon.ability_id != :LEVITATE
    end
  end
end

# API Methods
module AdvancedAI
  def self.calculate_hazard_damage(battle, battler, side_effects)
    HazardControl.calculate_hazard_damage(battle, battler, side_effects)
  end
  
  def self.calculate_stealth_rock_damage(battler)
    HazardControl.calculate_stealth_rock_damage(battler)
  end
  
  def self.evaluate_hazard_setting(battle, attacker, move, skill_level = 100)
    HazardControl.evaluate_hazard_setting(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_hazard_removal(battle, attacker, move, skill_level = 100)
    HazardControl.evaluate_hazard_removal(battle, attacker, move, skill_level)
  end
  
  def self.is_grounded?(battler)
    HazardControl.is_grounded?(battler)
  end
  
  def self.has_heavy_duty_boots?(battler)
    HazardControl.has_heavy_duty_boots?(battler)
  end
  
  def self.evaluate_boots_vs_hazards(battle, battler, skill_level = 100)
    HazardControl.evaluate_boots_vs_hazards(battle, battler, skill_level)
  end
end

AdvancedAI.log("Hazard Control System loaded", "Hazards")
AdvancedAI.log("  - Hazard damage calculation", "Hazards")
AdvancedAI.log("  - Stealth Rock type weakness check", "Hazards")
AdvancedAI.log("  - Spikes layer optimization", "Hazards")
AdvancedAI.log("  - Toxic Spikes vs Poison types", "Hazards")
AdvancedAI.log("  - Sticky Web speed control", "Hazards")
AdvancedAI.log("  - Defog decision making", "Hazards")
AdvancedAI.log("  - Rapid Spin (Ghost blocker awareness)", "Hazards")
AdvancedAI.log("  - Court Change hazard swapping", "Hazards")
AdvancedAI.log("  - Heavy-Duty Boots awareness", "Hazards")

### FILE: PP_Tracker.rb ###
#===============================================================================
# Advanced AI System - PP Tracker
# Tracks PP usage, Pressure ability, and Struggle prediction
#===============================================================================

module AdvancedAI
  module PPTracker
    # PP tracking cache per battle
    @pp_cache = {}
    @battle_id = nil
    
    #===========================================================================
    # PP Tracking Core
    #===========================================================================
    
    # Initialize PP tracking for a new battle
    def self.init_tracking(battle)
      battle_hash = battle.object_id
      return if @battle_id == battle_hash
      
      @battle_id = battle_hash
      @pp_cache = {}
      
      # Initialize all battlers
      battle.allBattlers.each do |battler|
        next unless battler
        init_battler_pp(battler)
      end
    end
    
    # Initialize PP for a battler
    def self.init_battler_pp(battler)
      return unless battler && battler.pokemon
      
      key = battler_key(battler)
      @pp_cache[key] ||= {}
      
      battler.moves.each do |move|
        next unless move
        # Assume max PP unless we've tracked usage
        @pp_cache[key][move.id] ||= {
          max_pp: move.total_pp,
          current_pp: move.total_pp,
          times_used: 0
        }
      end
    end
    
    # Record a move being used
    def self.record_move_use(battle, battler, move)
      return unless battler && move
      
      init_tracking(battle)
      init_battler_pp(battler)
      
      key = battler_key(battler)
      return unless @pp_cache[key]
      
      # Calculate PP drain
      drain = 1
      
      # Check for Pressure ability on opponents
      battle.allOtherSideBattlers(battler.index).each do |opp|
        next unless opp && !opp.fainted?
        if opp.ability_id == :PRESSURE
          drain += 1  # Pressure doubles PP usage
        end
      end
      
      # Update PP
      if @pp_cache[key][move.id]
        @pp_cache[key][move.id][:times_used] += 1
        @pp_cache[key][move.id][:current_pp] = 
          [@pp_cache[key][move.id][:current_pp] - drain, 0].max
      else
        # New move we haven't seen
        move_data = GameData::Move.try_get(move.id)
        max_pp = move_data ? move_data.total_pp : 10
        @pp_cache[key][move.id] = {
          max_pp: max_pp,
          current_pp: [max_pp - drain, 0].max,
          times_used: 1
        }
      end
    end
    
    # Get estimated remaining PP for a move
    def self.get_remaining_pp(battler, move_id)
      return nil unless battler
      
      key = battler_key(battler)
      return nil unless @pp_cache[key] && @pp_cache[key][move_id]
      
      @pp_cache[key][move_id][:current_pp]
    end
    
    # Check if move is likely out of PP
    def self.move_out_of_pp?(battler, move_id)
      pp = get_remaining_pp(battler, move_id)
      pp && pp <= 0
    end
    
    # Get all moves that are low on PP
    def self.get_low_pp_moves(battler, threshold = 2)
      return [] unless battler
      
      key = battler_key(battler)
      return [] unless @pp_cache[key]
      
      low_pp = []
      @pp_cache[key].each do |move_id, data|
        if data[:current_pp] <= threshold
          low_pp << { move_id: move_id, pp: data[:current_pp] }
        end
      end
      
      low_pp
    end
    
    # Check if battler is likely to Struggle soon
    def self.will_struggle_soon?(battler, turns = 3)
      return false unless battler
      
      key = battler_key(battler)
      return false unless @pp_cache[key]
      
      total_remaining_pp = 0
      @pp_cache[key].each do |move_id, data|
        total_remaining_pp += data[:current_pp]
      end
      
      total_remaining_pp <= turns
    end
    
    # Check if battler is currently forced to Struggle
    def self.must_struggle?(battler)
      return false unless battler
      
      key = battler_key(battler)
      return false unless @pp_cache[key]
      
      @pp_cache[key].all? { |move_id, data| data[:current_pp] <= 0 }
    end
    
    #===========================================================================
    # Pressure Ability Awareness
    #===========================================================================
    
    # Calculate effective PP drain rate
    def self.get_pp_drain_rate(battle, battler)
      drain = 1
      
      battle.allOtherSideBattlers(battler.index).each do |opp|
        next unless opp && !opp.fainted?
        if opp.ability_id == :PRESSURE
          drain += 1
        end
      end
      
      drain
    end
    
    # Calculate turns until move runs out
    def self.turns_until_pp_out(battle, battler, move_id)
      pp = get_remaining_pp(battler, move_id)
      return 999 unless pp
      
      drain = get_pp_drain_rate(battle, battler)
      return 999 if drain <= 0  # Guard against division by zero
      (pp / drain.to_f).ceil
    end
    
    # Pressure stall strategy - target low PP moves
    def self.evaluate_pressure_stall(battle, attacker, target, skill_level = 100)
      return 0 unless skill_level >= 75
      return 0 unless target
      
      score = 0
      
      # Check if we have Pressure
      if attacker.ability_id == :PRESSURE
        low_pp = get_low_pp_moves(target, 5)
        score += low_pp.length * 10
        
        # Bonus if they have low PP threats
        low_pp.each do |lp|
          move_data = GameData::Move.try_get(lp[:move_id])
          if move_data && move_data.power >= 80
            score += 15  # Their strong moves are running low
          end
        end
        
        # Extra bonus if they'll Struggle soon
        if will_struggle_soon?(target, 5)
          score += 30
        end
      end
      
      # Check if opponent has Pressure (we need to conserve PP)
      if target.ability_id == :PRESSURE
        # Prefer high PP moves
        attacker.moves.each_with_index do |move, i|
          next unless move
          pp = get_remaining_pp(attacker, move.id)
          if pp && pp <= 3
            score -= 20  # We're running low on this move
          end
        end
      end
      
      score
    end
    
    #===========================================================================
    # PP Conservation Strategies
    #===========================================================================
    
    # Should we conserve PP on this move?
    def self.should_conserve_pp?(battle, attacker, move, skill_level = 100)
      return false unless skill_level >= 65
      return false unless move
      
      remaining = get_remaining_pp(attacker, move.id)
      return false unless remaining
      
      # Low PP moves need conservation
      if remaining <= 3
        # Exception: If it's the only move that can hit the target
        return false if only_viable_move?(attacker, move)
        return true
      end
      
      # Check Pressure impact
      drain = get_pp_drain_rate(battle, attacker)
      if drain >= 2 && remaining <= 6
        return true  # Pressure draining fast
      end
      
      false
    end
    
    # Penalty for using low PP moves unnecessarily
    def self.apply_pp_conservation_penalty(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 65
      return 0 unless move
      
      remaining = get_remaining_pp(attacker, move.id)
      return 0 unless remaining
      
      penalty = 0
      
      if remaining <= 2
        penalty -= 40  # Very low - save for critical moment
      elsif remaining <= 5
        penalty -= 15  # Getting low
      end
      
      # Adjust by move importance
      if move.power >= 100
        penalty /= 2  # Strong moves are worth using
      end
      
      penalty
    end
    
    #===========================================================================
    # Move Selection Based on PP
    #===========================================================================
    
    # Boost high PP alternatives when low on main move
    def self.suggest_pp_alternative(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless move
      
      main_pp = get_remaining_pp(attacker, move.id)
      return 0 unless main_pp && main_pp <= 3
      
      # Look for alternatives
      alternatives = []
      attacker.moves.each do |alt_move|
        next unless alt_move && alt_move.id != move.id
        next unless alt_move.damagingMove? == move.damagingMove?
        
        alt_pp = get_remaining_pp(attacker, alt_move.id)
        next unless alt_pp && alt_pp > 5
        
        # Same type/similar function
        if alt_move.type == move.type
          alternatives << alt_move
        end
      end
      
      alternatives.empty? ? 0 : 15
    end
    
    #===========================================================================
    # Low PP Move Detection (inherently scarce moves)
    #===========================================================================
    
    LOW_PP_MOVES = {
      # 5 PP moves
      FOCUSBLAST: 5, STONEEDGE: 5, FIREBLAST: 5, HYDROPUMP: 5, BLIZZARD: 5,
      THUNDER: 5, MEGAHORN: 5, DRAGONPULSE: 5, METEORMASH: 5, CLOSECOMBAT: 5,
      OUTRAGE: 5, PETALBLIZZARD: 5, OVERHEAT: 5, LEAFSTORM: 5, DRACOMETEOR: 5,
      PSYCHOBOOST: 5, FLEURCANNON: 5, CLANGINGSCALES: 5,
      # 8 PP moves
      EARTHQUAKE: 10, ICEBEAM: 10, THUNDERBOLT: 10, FLAMETHROWER: 10
    }
    
    def self.is_low_pp_move?(move)
      return false unless move
      move_data = GameData::Move.try_get(move.id)
      return false unless move_data
      
      move_data.total_pp <= 8
    end
    
    #===========================================================================
    # Prediction: What move will they use if low on PP?
    #===========================================================================
    
    def self.predict_forced_move(battle, battler, skill_level = 100)
      return nil unless skill_level >= 80
      return nil unless battler
      
      key = battler_key(battler)
      return nil unless @pp_cache[key]
      
      # Find moves with PP remaining
      usable_moves = []
      @pp_cache[key].each do |move_id, data|
        if data[:current_pp] > 0
          usable_moves << move_id
        end
      end
      
      # If only one usable move, we know what they'll use
      if usable_moves.length == 1
        return usable_moves.first
      end
      
      nil
    end
    
    #===========================================================================
    # Private Helpers
    #===========================================================================
    private
    
    def self.battler_key(battler)
      # Unique key combining side and species
      "#{battler.index}_#{battler.species}"
    end
    
    def self.only_viable_move?(attacker, move)
      return true unless attacker.moves
      
      attacker.moves.count do |m|
        m && m.id != move.id && get_remaining_pp(attacker, m.id).to_i > 0
      end == 0
    end
  end
end

# API Methods
module AdvancedAI
  def self.init_pp_tracking(battle)
    PPTracker.init_tracking(battle)
  end
  
  def self.record_pp_use(battle, battler, move)
    PPTracker.record_move_use(battle, battler, move)
  end
  
  def self.get_remaining_pp(battler, move_id)
    PPTracker.get_remaining_pp(battler, move_id)
  end
  
  def self.will_struggle_soon?(battler, turns = 3)
    PPTracker.will_struggle_soon?(battler, turns)
  end
  
  def self.must_struggle?(battler)
    PPTracker.must_struggle?(battler)
  end
  
  def self.evaluate_pressure_stall(battle, attacker, target, skill_level = 100)
    PPTracker.evaluate_pressure_stall(battle, attacker, target, skill_level)
  end
  
  def self.apply_pp_conservation(battle, attacker, move, skill_level = 100)
    PPTracker.apply_pp_conservation_penalty(battle, attacker, move, skill_level)
  end
  
  def self.predict_forced_move(battle, battler, skill_level = 100)
    PPTracker.predict_forced_move(battle, battler, skill_level)
  end
end

AdvancedAI.log("PP Tracker System loaded", "PP")
AdvancedAI.log("  - Move PP usage tracking", "PP")
AdvancedAI.log("  - Pressure ability awareness", "PP")
AdvancedAI.log("  - Struggle prediction", "PP")
AdvancedAI.log("  - PP conservation strategies", "PP")
AdvancedAI.log("  - Low PP move detection", "PP")

### FILE: Recoil_Tracking.rb ###
#===============================================================================
# Advanced AI System - Recoil and Self-Damage Tracking
# Life Orb, recoil moves, confusion self-hit, Belly Drum, substitute HP cost
#===============================================================================

module AdvancedAI
  module RecoilTracking
    
    #===========================================================================
    # Recoil Move Lists
    #===========================================================================
    
    # Moves with recoil damage (% of damage dealt or max HP)
    RECOIL_MOVES = {
      # High recoil (50% of damage dealt)
      :BRAVEBIRD => { type: :dealt, percent: 0.33 },
      :DOUBLEEDGE => { type: :dealt, percent: 0.33 },
      :HEADSMASH => { type: :dealt, percent: 0.50 },
      :VOLTTACKLE => { type: :dealt, percent: 0.33 },
      :WOODHAMMER => { type: :dealt, percent: 0.33 },
      :FLAREBLITZ => { type: :dealt, percent: 0.33 },
      :WILDCHARGE => { type: :dealt, percent: 0.25 },
      :SUBMISSION => { type: :dealt, percent: 0.25 },
      :TAKEDOWN => { type: :dealt, percent: 0.25 },
      
      # Drain HP moves (% of max HP)
      :BELLYDRUM => { type: :max_hp, percent: 0.50 },
      :MINDBLOWN => { type: :max_hp, percent: 0.50 },
      :STEELBEAM => { type: :max_hp, percent: 0.50 },
      :CHLOROBLAST => { type: :max_hp, percent: 0.50 },
    }
    
    # Life Orb: 10% max HP per attack
    LIFE_ORB_RECOIL = 0.10
    
    # Confusion self-hit: 40 BP typeless physical move, 50% chance
    CONFUSION_DAMAGE_BP = 40
    CONFUSION_CHANCE = 0.50
    
    # Substitute: 25% max HP
    SUBSTITUTE_COST = 0.25
    
    # Rocky Helmet / Rough Skin / Iron Barbs: 1/8 max HP per contact
    CONTACT_DAMAGE_FRACTION = 0.125
    
    #===========================================================================
    # Calculate Total Recoil/Self-Damage
    #===========================================================================
    
    def self.calculate_recoil_damage(user, move, damage_dealt = nil)
      return 0 unless user && move
      
      total_recoil = 0
      
      # Move-specific recoil
      if RECOIL_MOVES.key?(move.id)
        recoil_data = RECOIL_MOVES[move.id]
        
        if recoil_data[:type] == :dealt
          # Recoil based on damage dealt (need damage_dealt parameter)
          if damage_dealt && damage_dealt > 0
            total_recoil += (damage_dealt * recoil_data[:percent]).to_i
          else
            # Estimate: assume 50% HP damage dealt as conservative guess
            estimated_damage = user.totalhp * 0.5
            total_recoil += (estimated_damage * recoil_data[:percent]).to_i
          end
          
        elsif recoil_data[:type] == :max_hp
          # Recoil based on max HP (Belly Drum, Mind Blown, etc.)
          total_recoil += (user.totalhp * recoil_data[:percent]).to_i
        end
      end
      
      # Life Orb recoil (only on damaging moves)
      if move.damagingMove? && user.hasActiveItem?(:LIFEORB)
        # Rock Head negates Life Orb recoil
        unless user.hasActiveAbility?(:ROCKHEAD)
          total_recoil += (user.totalhp * LIFE_ORB_RECOIL).to_i
        end
      end
      
      # Magic Guard negates all recoil/self-damage
      if user.hasActiveAbility?(:MAGICGUARD)
        total_recoil = 0
      end
      
      return total_recoil
    end
    
    #===========================================================================
    # Score Penalty for Recoil Risk
    #===========================================================================
    
    def self.score_recoil_penalty(user, move, target, damage_dealt = nil)
      return 0 unless user && move
      
      recoil_damage = self.calculate_recoil_damage(user, move, damage_dealt)
      return 0 if recoil_damage == 0
      
      penalty = 0
      hp_percent_lost = (recoil_damage.to_f / [user.hp, 1].max)
      
      # Massive penalty if recoil would KO self
      if recoil_damage >= user.hp
        penalty += 500  # NEVER use move that kills self (unless it KOs opponent)
      elsif hp_percent_lost >= 0.75
        penalty += 120  # Extremely risky - 75%+ HP loss
      elsif hp_percent_lost >= 0.50
        penalty += 80   # Very risky - 50%+ HP loss
      elsif hp_percent_lost >= 0.33
        penalty += 50   # Risky - 33%+ HP loss
      elsif hp_percent_lost >= 0.20
        penalty += 30   # Moderate risk - 20%+ HP loss
      elsif hp_percent_lost >= 0.10
        penalty += 15   # Minor risk - 10%+ HP loss
      else
        penalty += 5    # Negligible risk
      end
      
      # EXCEPTION: If move will KO opponent, recoil is acceptable
      if move.damagingMove?
        # Rough damage estimate (simplified - could use actual damage calc)
        estimated_damage = self.calculate_rough_damage_for_recoil(user, move, target)
        
        if estimated_damage >= target.hp
          # Move will KO - reduce penalty heavily
          penalty = (penalty * 0.2).to_i  # 80% penalty reduction
          
          # If both die (trade KO scenario)
          if recoil_damage >= user.hp
            # Use team advantage calculator - get battle from battler
            battle = user.respond_to?(:battle) ? user.battle : user.instance_variable_get(:@battle)
            opposing_idx = user.pbOpposingIndices[0] rescue 1
            advantage = AdvancedAI::CombatUtilities.team_advantage(
              battle, user.index, opposing_idx
            )
            
            case advantage
            when 1
              # We have numbers advantage - trade is GOOD
              penalty = -30  # Small BONUS for trading when ahead
            when 0
              # Even teams - trade is NEUTRAL
              penalty = 10  # Tiny penalty (acceptable)
            when -1
              # We're behind - trade is BAD
              penalty = 40  # Moderate penalty (avoid unless necessary)
            end
          end
        end
      end
      
      return -penalty  # Return negative score (penalty)
    end
    
    #===========================================================================
    # Confusion Self-Damage Tracking
    #===========================================================================
    
    def self.calculate_confusion_damage(user)
      return 0 unless user
      return 0 if user.effects[PBEffects::Confusion] == 0
      
      # Confusion self-hit: 40 BP typeless physical move
      # Damage = ((2*Level/5 + 2) * 40 * Atk/Def / 50 + 2) * 0.5 chance
      level = user.level
      atk = user.attack
      defense = user.defense
      
      base_damage = ((2.0 * level / 5 + 2) * CONFUSION_DAMAGE_BP * atk / defense / 50 + 2)
      expected_damage = (base_damage * CONFUSION_CHANCE).to_i
      
      return expected_damage
    end
    
    def self.score_confusion_risk(user)
      return 0 unless user
      return 0 if user.effects[PBEffects::Confusion] == 0
      
      confusion_damage = calculate_confusion_damage(user)
      hp_percent = (confusion_damage.to_f / [user.hp, 1].max)
      
      penalty = 0
      if hp_percent >= 0.50
        penalty += 60  # Huge risk - 50%+ HP from self-hit
      elsif hp_percent >= 0.33
        penalty += 40
      elsif hp_percent >= 0.20
        penalty += 25
      else
        penalty += 10
      end
      
      return -penalty
    end
    
    #===========================================================================
    # Substitute HP Cost Tracking
    #===========================================================================
    
    def self.can_afford_substitute?(user)
      return false unless user
      
      # Need > 25% HP to use Substitute
      required_hp = (user.totalhp * SUBSTITUTE_COST).to_i
      return user.hp > required_hp
    end
    
    def self.score_substitute_cost(user)
      return 0 unless user
      return -200 unless can_afford_substitute?(user)  # Can't afford
      
      hp_percent = user.hp.to_f / user.totalhp
      
      # Lower HP = higher penalty for using Substitute
      penalty = 0
      if hp_percent < 0.40
        penalty += 80  # Very low HP - risky
      elsif hp_percent < 0.60
        penalty += 40  # Moderate HP
      else
        penalty += 10  # Healthy - minimal penalty
      end
      
      return -penalty
    end
    
    #===========================================================================
    # Helper: Rough Damage Estimate for Recoil Decisions
    #===========================================================================
    
    def self.calculate_rough_damage_for_recoil(user, move, target)
      # Use centralized damage calculator
      AdvancedAI::CombatUtilities.estimate_damage(user, move, target)
    end
    
  end
end

#===============================================================================
# Integration: Hook into pbRegisterMove
#===============================================================================

class Battle::AI
  alias recoil_tracking_pbRegisterMove pbRegisterMove
  
  def pbRegisterMove(user, move)
    score = recoil_tracking_pbRegisterMove(user, move)
    
    return score unless user && move
    
    # Apply recoil penalty for recoil moves
    if AdvancedAI::RecoilTracking::RECOIL_MOVES.key?(move.id) || 
       (move.damagingMove? && user.hasActiveItem?(:LIFEORB))
      target = @battle.allOtherSideBattlers(user.index).find { |b| b && !b.fainted? }
      if target
        recoil_penalty = AdvancedAI::RecoilTracking.score_recoil_penalty(user, move, target)
        score += recoil_penalty
      end
    end
    
    # Apply confusion risk if confused
    if user.effects[PBEffects::Confusion] > 0
      confusion_penalty = AdvancedAI::RecoilTracking.score_confusion_risk(user)
      score += confusion_penalty if confusion_penalty < 0
    end
    
    # Substitute cost
    if move.id == :SUBSTITUTE
      sub_penalty = AdvancedAI::RecoilTracking.score_substitute_cost(user)
      score += sub_penalty
    end
    
    return score
  end
end

### FILE: Sleep_Clause.rb ###
#===============================================================================
# Advanced AI System - Sleep Clause
# Sleep clause awareness and enforcement
#===============================================================================

module AdvancedAI
  module SleepClause
    #===========================================================================
    # Sleep Clause Logic
    #===========================================================================
    
    # Check if using a sleep move would violate sleep clause
    def self.would_violate_sleep_clause?(battle, attacker, target)
      return false unless target
      
      # Check if opponent already has a sleeping Pokemon
      opp_party = battle.pbParty((attacker.index + 1) % 2)
      
      already_asleep = opp_party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted?
        # Check if asleep (not from Rest)
        pkmn.status == :SLEEP && !is_rest_sleep?(pkmn)
      end
      
      # If opponent already has a sleeping mon, don't sleep another
      already_asleep > 0
    end
    
    # Check if sleep is from Rest (Rest sleep doesn't count for clause)
    def self.is_rest_sleep?(pokemon)
      # In Essentials, Rest sets a specific sleep counter
      # If sleepCount is exactly 3, it's likely from Rest
      # This is a heuristic - actual implementation may vary
      return false unless pokemon.status == :SLEEP
      
      # Check if statusCount matches Rest's 2-turn sleep
      pokemon.statusCount == 2 || pokemon.statusCount == 3
    end
    
    # Evaluate sleep moves with clause awareness
    def self.evaluate_sleep_move(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 50
      return 0 unless target
      
      sleep_moves = [:SPORE, :SLEEPPOWDER, :HYPNOSIS, :SING, :GRASSWHISTLE,
                     :LOVELYKISS, :DARKVOID, :YAWN, :RELICSONG]
      
      return 0 unless sleep_moves.include?(move.id)
      
      score = 0
      
      # Check sleep clause
      if would_violate_sleep_clause?(battle, attacker, target)
        return -100  # Would violate clause
      end
      
      # Already asleep?
      if target.status == :SLEEP
        return -80
      end
      
      # Immune to sleep?
      if target.status != :NONE  # Already has status
        return -70
      end
      
      # Check for Vital Spirit / Insomnia / Sweet Veil / Comatose
      sleep_immune = [:VITALSPIRIT, :INSOMNIA, :SWEETVEIL, :COMATOSE]
      if sleep_immune.include?(target.ability_id)
        return -80
      end
      
      # Electric Terrain prevents sleep
      if battle.field.terrain == :Electric && target.affectedByTerrain?
        return -80
      end
      
      # Misty Terrain prevents sleep
      if battle.field.terrain == :Misty && target.affectedByTerrain?
        return -80
      end
      
      # Safety Goggles blocks powder moves
      powder_moves = [:SPORE, :SLEEPPOWDER]
      if powder_moves.include?(move.id) && target.item_id == :SAFETYGOGGLES
        return -80
      end
      
      # Grass types immune to powder
      if powder_moves.include?(move.id) && target.pbHasType?(:GRASS)
        return -80
      end
      
      # Overcoat blocks powder
      if powder_moves.include?(move.id) && target.ability_id == :OVERCOAT
        return -80
      end
      
      # Sleep is very strong - base value
      score += 60
      
      # Accuracy considerations
      case move.id
      when :SPORE
        score += 40  # 100% accuracy, best sleep move
      when :SLEEPPOWDER
        score += 15  # 75% accuracy
      when :HYPNOSIS
        score += 0   # 60% accuracy - risky
      when :SING
        score -= 10  # 55% accuracy
      when :DARKVOID
        score += 20  # Hits multiple (when legal)
      when :YAWN
        score += 10  # Delayed but guaranteed
      end
      
      # Bonus if target is a threat
      if target.attack >= 120 || target.spatk >= 120
        score += 20  # Sleep the sweeper
      end
      
      # Bonus in doubles for removing a target temporarily
      if battle.pbSideSize(0) > 1
        score += 15
      end
      
      score
    end
    
    #===========================================================================
    # Yawn Specific Logic
    #===========================================================================
    
    def self.evaluate_yawn(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless move.id == :YAWN
      return 0 unless target
      
      score = 0
      
      # Yawn sets up forced switch or sleep
      # Check if target already drowsy
      if target.effects[PBEffects::Yawn] && target.effects[PBEffects::Yawn] > 0
        return -80  # Already drowsy
      end
      
      # Sleep clause check
      if would_violate_sleep_clause?(battle, attacker, target)
        # Yawn still forces switch even if they'd violate clause
        score += 30  # Forces switch
      else
        score += 50  # Will cause sleep or switch
      end
      
      # Yawn + Protect/hazards is strong
      has_protect = attacker.moves.any? { |m| m && [:PROTECT, :DETECT].include?(m.id) }
      if has_protect
        score += 20
      end
      
      # Hazards up means switch is punished
      opp_side = battle.sides[(attacker.index + 1) % 2]
      if opp_side.effects[PBEffects::StealthRock]
        score += 15
      end
      
      spikes = opp_side.effects[PBEffects::Spikes] || 0
      score += spikes * 5
      
      score
    end
    
    #===========================================================================
    # Anti-Sleep Strategies
    #===========================================================================
    
    # Evaluate switching to avoid sleep
    def self.evaluate_sleep_switch_in(battle, battler, skill_level = 100)
      return 0 unless skill_level >= 65
      return 0 unless battler
      
      score = 0
      
      # Check for sleep immunity
      sleep_immune = [:VITALSPIRIT, :INSOMNIA, :SWEETVEIL, :COMATOSE]
      if sleep_immune.include?(battler.ability_id)
        score += 40
      end
      
      # Safety Goggles
      if battler.item_id == :SAFETYGOGGLES
        score += 25
      end
      
      # Grass type (powder immunity)
      if battler.pbHasType?(:GRASS)
        score += 20
      end
      
      # Overcoat
      if battler.ability_id == :OVERCOAT
        score += 20
      end
      
      # Magic Bounce reflects sleep
      if battler.ability_id == :MAGICBOUNCE
        score += 35
      end
      
      score
    end
    
    # Value of Sleep Talk when asleep
    def self.evaluate_sleep_talk(battle, attacker, move, skill_level = 100)
      return 0 unless move.id == :SLEEPTALK
      
      score = 0
      
      # Sleep Talk only works when asleep
      if attacker.status == :SLEEP
        score += 50  # Can act while asleep
        
        # Better if we have good moves to call
        good_moves = attacker.moves.count do |m|
          m && m.id != :SLEEPTALK && m.damagingMove? && m.power >= 80
        end
        score += good_moves * 15
      else
        score -= 80  # Not asleep, Sleep Talk fails
      end
      
      score
    end
    
    # Rest + Sleep Talk combo
    def self.evaluate_rest_talk_combo(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 65
      
      score = 0
      
      if move.id == :REST
        # Check if we have Sleep Talk
        has_sleep_talk = attacker.moves.any? { |m| m && m.id == :SLEEPTALK }
        
        if has_sleep_talk
          score += 30  # RestTalk combo
          
          # Value based on HP
          hp_percent = attacker.hp.to_f / attacker.totalhp
          if hp_percent < 0.5
            score += 40
          elsif hp_percent < 0.3
            score += 60
          end
        end
      end
      
      score
    end
    
    #===========================================================================
    # Early Wake Detection
    #===========================================================================
    
    # Predict when opponent will wake up
    def self.predict_wake_turn(battler)
      return 0 unless battler && battler.status == :SLEEP
      
      # statusCount is turns remaining
      battler.statusCount
    end
    
    # Should we set up on sleeping target or attack?
    def self.evaluate_setup_on_sleeper(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 70
      return 0 unless target && target.status == :SLEEP
      
      turns_left = predict_wake_turn(target)
      
      # Setup moves while they sleep
      setup_moves = [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :CALMMIND,
                     :QUIVERDANCE, :BULKUP, :AGILITY, :SHELLSMASH]
      
      if setup_moves.include?(move.id)
        if turns_left >= 2
          return 40  # Safe to set up
        elsif turns_left == 1
          return 15  # Risky
        end
      end
      
      0
    end
  end
end

# API Methods
module AdvancedAI
  def self.would_violate_sleep_clause?(battle, attacker, target)
    SleepClause.would_violate_sleep_clause?(battle, attacker, target)
  end
  
  def self.evaluate_sleep_move(battle, attacker, move, target, skill_level = 100)
    SleepClause.evaluate_sleep_move(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_yawn(battle, attacker, move, target, skill_level = 100)
    SleepClause.evaluate_yawn(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_sleep_switch_in(battle, battler, skill_level = 100)
    SleepClause.evaluate_sleep_switch_in(battle, battler, skill_level)
  end
  
  def self.evaluate_sleep_talk(battle, attacker, move, skill_level = 100)
    SleepClause.evaluate_sleep_talk(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_rest_talk_combo(battle, attacker, move, skill_level = 100)
    SleepClause.evaluate_rest_talk_combo(battle, attacker, move, skill_level)
  end
  
  def self.predict_wake_turn(battler)
    SleepClause.predict_wake_turn(battler)
  end
  
  def self.evaluate_setup_on_sleeper(battle, attacker, move, target, skill_level = 100)
    SleepClause.evaluate_setup_on_sleeper(battle, attacker, move, target, skill_level)
  end
end

AdvancedAI.log("Sleep Clause System loaded", "Sleep")
AdvancedAI.log("  - Sleep clause enforcement", "Sleep")
AdvancedAI.log("  - Sleep move evaluation", "Sleep")
AdvancedAI.log("  - Yawn strategy", "Sleep")
AdvancedAI.log("  - Sleep immunity awareness", "Sleep")
AdvancedAI.log("  - Sleep Talk / RestTalk combos", "Sleep")
AdvancedAI.log("  - Wake prediction", "Sleep")

### FILE: Substitute_Logic.rb ###
#===============================================================================
# Advanced AI System - Substitute Logic
# Sub strategies, Sub + setup combos, breaking subs
#===============================================================================

module AdvancedAI
  module SubstituteLogic
    #===========================================================================
    # When to Use Substitute
    #===========================================================================
    
    # Evaluate using Substitute
    def self.evaluate_substitute(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 65
      return 0 unless move.id == :SUBSTITUTE
      
      score = 0
      
      # Can we afford to make a Sub?
      if attacker.hp <= attacker.totalhp / 4
        return -100  # Can't make Sub
      end
      
      if attacker.hp <= attacker.totalhp / 2
        score -= 20  # Risky
      end
      
      # Check if we already have a Sub
      if attacker.effects[PBEffects::Substitute] && attacker.effects[PBEffects::Substitute] > 0
        return -100  # Already have Sub
      end
      
      # Good reasons to Sub
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      
      # Sub on predicted switch
      opponents.each do |opp|
        # Weak matchup for them = likely switch
        our_stab_types = get_stab_types(attacker)
        weak_to_us = our_stab_types.any? do |type|
          type_mod = Effectiveness.calculate(type, *opp.pbTypes(true))
          Effectiveness.super_effective?(type_mod)
        end
        
        if weak_to_us
          score += 30  # They might switch, free Sub
        end
      end
      
      # Sub blocks status
      status_threats = opponents.count do |opp|
        opp.moves.any? { |m| m && [:THUNDERWAVE, :WILLOWISP, :TOXIC, :SPORE, :SLEEPPOWDER, :GLARE].include?(m.id) }
      end
      if status_threats > 0 && !attacker.status
        score += 25
      end
      
      # Sub + Setup combos
      has_setup = attacker.moves.any? do |m|
        m && [:SWORDSDANCE, :NASTYPLOT, :CALMMIND, :DRAGONDANCE, :QUIVERDANCE,
              :BULKUP, :AGILITY].include?(m.id)
      end
      if has_setup
        score += 30
      end
      
      # Sub + Focus Punch
      has_focus_punch = attacker.moves.any? { |m| m && m.id == :FOCUSPUNCH }
      if has_focus_punch
        score += 40
      end
      
      # Sub + Leech Seed
      has_leech_seed = attacker.moves.any? { |m| m && m.id == :LEECHSEED }
      if has_leech_seed
        score += 25
      end
      
      # Sub + Disable/Encore
      has_disable = attacker.moves.any? { |m| m && [:DISABLE, :ENCORE].include?(m.id) }
      if has_disable
        score += 20
      end
      
      # Leftovers recovery
      if attacker.item_id == :LEFTOVERS
        score += 15
      end
      
      # Sub + Baton Pass
      has_baton = attacker.moves.any? { |m| m && m.id == :BATONPASS }
      if has_baton
        score += 35  # Pass the Sub to a sweeper
      end
      
      # Punish sound-based moves (they bypass Sub) 
      sound_users = opponents.count do |opp|
        opp.moves.any? do |m| 
          m && [:HYPERVOICE, :BOOMBURST, :BUGBUZZ, :DISARMINGVOICE, :ROUND, 
                :SNARL, :UPROAR, :CHATTER, :OVERDRIVE].include?(m.id)
        end
      end
      if sound_users > 0
        score -= 20  # They can hit through Sub
      end
      
      # Infiltrator bypasses Sub
      infiltrators = opponents.count { |opp| opp.ability_id == :INFILTRATOR }
      if infiltrators > 0
        score -= 30
      end
      
      score
    end
    
    #===========================================================================
    # Breaking Opponent's Substitute
    #===========================================================================
    
    # Evaluate moves that break Sub efficiently
    def self.evaluate_sub_breaking(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 55
      return 0 unless target
      return 0 unless target.effects[PBEffects::Substitute] && target.effects[PBEffects::Substitute] > 0
      
      score = 0
      sub_hp = target.effects[PBEffects::Substitute]
      
      # === MULTI-HIT MOVES ===
      if move.multiHitMove?
        score += 50
        
        # Skill Link guarantees 5 hits = maximum Sub breaking value
        if attacker.ability_id == :SKILLLINK
          score += 15  # 5 guaranteed hits
        end
        
        # Loaded Dice increases minimum hits
        if attacker.item_id == :LOADEDDICE
          score += 10  # More consistent multi-hits
        end
        
        # Parent Bond hits twice (breaks Sub + damages)
        if attacker.ability_id == :PARENTALBOND
          score += 20
        end
        
        return score
      end
      
      # === SOUND MOVES ===
      # Sound moves BYPASS Sub completely (no breaking needed!)
      sound_moves = [:HYPERVOICE, :BOOMBURST, :BUGBUZZ, :DISARMINGVOICE, :ROUND,
                     :SNARL, :UPROAR, :CHATTER, :OVERDRIVE, :RELICSONG, :SPARKLINGARIA,
                     :ECHOEDVOICE, :GRASSYGLIDE, :CLANGINGSCALES, :CLANGOROUSSOUL,
                     :PERISHSONG, :SING, :SUPERSONIC]
      if sound_moves.include?(move.id)
        score += 60  # Bypasses Sub entirely!
        
        # Soundproof blocks this (opponent immune)
        if target.ability_id == :SOUNDPROOF
          score -= 100  # Move fails
        end
        
        return score
      end
      
      # === INFILTRATOR ABILITY ===
      # Infiltrator bypasses Sub, screens, etc.
      if attacker.ability_id == :INFILTRATOR
        score += 55  # Bypasses Sub
        return score
      end
      
      # === SPECIFIC MOVES THAT IGNORE SUB ===
      # These moves hit through Substitute
      bypass_sub_moves = [:CURSE, :NIGHTMARE, :PAINSPLIT]
      if bypass_sub_moves.include?(move.id)
        score += 40
        return score
      end
      
      # === POWERFUL SINGLE-HIT MOVES ===
      # Check if move can break the Sub in one hit
      if move.damagingMove?
        estimated_damage = estimate_move_damage(attacker, target, move)
        
        if estimated_damage >= sub_hp * 1.5
          score += 30  # Will break Sub + deal damage to target
        elsif estimated_damage >= sub_hp
          score += 20  # Will barely break Sub
        elsif estimated_damage >= sub_hp * 0.7
          score += 5   # Might break Sub with crit/roll
        else
          score -= 15  # Won't break Sub, wasted turn
        end
      end
      
      # === STATUS MOVES ===
      # Status moves FAIL against Sub (except sound-based or specific moves)
      if move.statusMove? && !sound_moves.include?(move.id) && !bypass_sub_moves.include?(move.id)
        score -= 60  # Will fail against Sub
      end
      
      # === FEINT ===
      # Feint hits through Protect/Sub (but doesn't break it)
      if move.id == :FEINT
        score += 10  # Can chip Sub
      end
      
      # === PRIORITIZE BREAKING SUB ===
      # If Sub is low HP, breaking it is high priority
      if sub_hp < target.totalhp / 8  # Less than 12.5% HP left
        score += 15  # Easy break, high value
      end
      
      score
    end
    
    #===========================================================================
    # Specific Sub Combo Evaluations
    #===========================================================================
    
    # Sub + Focus Punch
    def self.evaluate_focus_punch(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 70
      return 0 unless move.id == :FOCUSPUNCH
      
      score = 0
      
      # Have Sub up = Focus Punch guaranteed
      if attacker.effects[PBEffects::Substitute] && attacker.effects[PBEffects::Substitute] > 0
        score += 60  # Safe to use Focus Punch
      else
        # Risky without Sub
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        # Only use if opponent will likely use status/switch
        will_attack = opponents.any? do |opp|
          opp.moves.any? { |m| m && m.damagingMove? && m.priority >= 0 }
        end
        
        if will_attack
          score -= 40  # Likely to be hit first
        else
          score += 20  # They have no damaging moves?
        end
      end
      
      score
    end
    
    # Sub + Leech Seed stall
    def self.evaluate_leech_seed_stall(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 65
      return 0 unless move.id == :LEECHSEED
      return 0 unless target
      
      score = 0
      
      # Already seeded?
      if target.effects[PBEffects::LeechSeed] && target.effects[PBEffects::LeechSeed] >= 0
        return -50  # Already seeded
      end
      
      # Grass types immune
      if target.pbHasType?(:GRASS)
        return -80  # Immune
      end
      
      # Sub + Seed combo
      if attacker.effects[PBEffects::Substitute] && attacker.effects[PBEffects::Substitute] > 0
        score += 35  # Safe behind Sub
      end
      
      # Have Sub move?
      has_sub = attacker.moves.any? { |m| m && m.id == :SUBSTITUTE }
      if has_sub
        score += 20
      end
      
      # Have Protect for stall?
      has_protect = attacker.moves.any? { |m| m && [:PROTECT, :DETECT].include?(m.id) }
      if has_protect
        score += 25
      end
      
      # Big root boosts healing
      if attacker.item_id == :BIGROOT
        score += 15
      end
      
      score
    end
    
    # Sub + Disable
    def self.evaluate_disable_combo(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 75
      return 0 unless move.id == :DISABLE
      return 0 unless target
      
      score = 0
      
      # Need to know their last move
      return 0 unless target.lastMoveUsed
      
      # Behind Sub is safer
      if attacker.effects[PBEffects::Substitute] && attacker.effects[PBEffects::Substitute] > 0
        score += 25
      end
      
      # Check what move we'd disable
      last_move = GameData::Move.try_get(target.lastMoveUsed)
      return 0 unless last_move
      
      # Disable their only SE move against us
      type_mod = Effectiveness.calculate(last_move.type, attacker.types[0], attacker.types[1])
      if Effectiveness.super_effective?(type_mod)
        score += 40  # Disable their best move vs us
      end
      
      # Disable high power move
      if last_move.power >= 100
        score += 30
      end
      
      # Count their attacking moves
      attacking_moves = target.moves.count { |m| m && m.damagingMove? }
      if attacking_moves <= 2
        score += 25  # Limiting their options significantly
      end
      
      score
    end
    
    # Sub + Baton Pass
    def self.evaluate_sub_pass(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 70
      return 0 unless move.id == :BATONPASS
      
      score = 0
      
      # Check if we have a Sub to pass
      if attacker.effects[PBEffects::Substitute] && attacker.effects[PBEffects::Substitute] > 0
        score += 45
        
        # Extra value if we also have stat boosts
        total_boosts = 0
        attacker.stages.each { |stat, stage| total_boosts += stage if stage > 0 }
        
        score += total_boosts * 10
      end
      
      # Check if we have recipients who want the Sub
      party = battle.pbParty(attacker.index)
      sweeper_waiting = party.any? do |pkmn|
        next false unless pkmn && !pkmn.fainted? && pkmn != attacker.pokemon
        # Frail sweepers love receiving Subs
        pkmn.hp > 0 && (pkmn.attack >= 120 || pkmn.spatk >= 120)
      end
      
      if sweeper_waiting
        score += 20
      end
      
      score
    end
    
    #===========================================================================
    # Substitute HP Management
    #===========================================================================
    
    # Track HP quarters for Sub usage
    def self.can_make_sub?(battler)
      return false unless battler
      battler.hp > battler.totalhp / 4
    end
    
    def self.subs_remaining(battler)
      return 0 unless battler
      (battler.hp / (battler.totalhp / 4)).floor
    end
    
    # Calculate if we can make Sub + survive
    def self.safe_to_sub?(battle, battler, skill_level = 100)
      return false unless can_make_sub?(battler)
      return true if skill_level < 60
      
      hp_after_sub = battler.hp - (battler.totalhp / 4)
      
      # Check if we can survive a hit after making Sub
      opponents = battle.allOtherSideBattlers(battler.index).select { |b| b && !b.fainted? }
      
      max_incoming = 0
      opponents.each do |opp|
        opp.moves.each do |move|
          next unless move && move.damagingMove?
          damage = estimate_move_damage(opp, battler, move)
          max_incoming = damage if damage > max_incoming
        end
      end
      
      hp_after_sub > max_incoming
    end
    
    #===========================================================================
    # Private Helpers
    #===========================================================================
    private
    
    def self.get_stab_types(battler)
      types = []
      types << battler.types[0] if battler.types[0]
      types << battler.types[1] if battler.types[1]
      types.compact.uniq
    end
    
    def self.estimate_move_damage(attacker, target, move)
      return 0 unless move && move.damagingMove?
      
      power = move.power
      return 0 if power == 0
      
      if move.physicalMove?
        atk = attacker.attack
        dfn = target.defense
      else
        atk = attacker.spatk
        dfn = target.spdef
      end
      
      damage = ((2 * attacker.level / 5 + 2) * power * atk / dfn / 50 + 2)
      
      # STAB
      if attacker.pbHasType?(move.type)
        damage *= 1.5
      end
      
      # Type effectiveness
      type_mod = Effectiveness.calculate(move.type, target.types[0], target.types[1])
      damage *= type_mod / Effectiveness::NORMAL_EFFECTIVE
      
      damage.to_i
    end
  end
end

# API Methods
module AdvancedAI
  def self.evaluate_substitute(battle, attacker, move, skill_level = 100)
    SubstituteLogic.evaluate_substitute(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_sub_breaking(battle, attacker, move, target, skill_level = 100)
    SubstituteLogic.evaluate_sub_breaking(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_focus_punch(battle, attacker, move, skill_level = 100)
    SubstituteLogic.evaluate_focus_punch(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_leech_seed_stall(battle, attacker, move, target, skill_level = 100)
    SubstituteLogic.evaluate_leech_seed_stall(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_sub_pass(battle, attacker, move, skill_level = 100)
    SubstituteLogic.evaluate_sub_pass(battle, attacker, move, skill_level)
  end
  
  def self.can_make_sub?(battler)
    SubstituteLogic.can_make_sub?(battler)
  end
  
  def self.safe_to_sub?(battle, battler, skill_level = 100)
    SubstituteLogic.safe_to_sub?(battle, battler, skill_level)
  end
end

AdvancedAI.log("Substitute Logic System loaded", "Sub")
AdvancedAI.log("  - Sub timing optimization", "Sub")
AdvancedAI.log("  - Sub + Focus Punch combo", "Sub")
AdvancedAI.log("  - Sub + Leech Seed stall", "Sub")
AdvancedAI.log("  - Sub + Disable/Encore", "Sub")
AdvancedAI.log("  - Sub + Baton Pass", "Sub")
AdvancedAI.log("  - Sub breaking strategies", "Sub")
AdvancedAI.log("  - Sound move / Infiltrator awareness", "Sub")

### FILE: Weather_Terrain_Wars.rb ###
#===============================================================================
# Advanced AI System - Weather & Terrain Wars
# Strategic weather/terrain manipulation and counter-play
#===============================================================================

class Battle::AI
  # ============================================================================
  # WEATHER WARS
  # ============================================================================
  
  alias weather_wars_pbRegisterMove pbRegisterMove
  def pbRegisterMove(user, move)
    score = weather_wars_pbRegisterMove(user, move)
    
    return score unless user && move
    
    # Weather-setting moves
    if move_sets_weather?(move)
      score += evaluate_weather_setting(user, move)
    end
    
    # Terrain-setting moves
    if move_sets_terrain?(move)
      score += evaluate_terrain_setting(user, move)
    end
    
    return score
  end
  
  # ============================================================================
  # WEATHER SETTING EVALUATION
  # ============================================================================
  
  def move_sets_weather?(move)
    weather_moves = {
      :SUNNYDAY    => :Sun,
      :RAINDANCE   => :Rain,
      :SANDSTORM   => :Sandstorm,
      :HAIL        => :Hail,
      :SNOWSCAPE   => :Snow,
    }
    return weather_moves.key?(move.id)
  end
  
  def evaluate_weather_setting(user, move)
    score = 0
    
    weather_map = {
      :SUNNYDAY  => :Sun,
      :RAINDANCE => :Rain,
      :SANDSTORM => :Sandstorm,
      :HAIL      => :Hail,
      :SNOWSCAPE => :Snow,
    }
    
    new_weather = weather_map[move.id]
    current_weather = @battle.field.weather
    
    # Don't set weather that's already active
    if current_weather == new_weather
      AdvancedAI.log("  #{move.name}: -80 (already active)", "Weather")
      return -80
    end
    
    # COUNTER-WEATHER: Remove opponent's beneficial weather
    if weather_benefits_opponent?(current_weather)
      score += 50
      AdvancedAI.log("  #{move.name}: +50 (counter opponent weather)", "Weather")
    end
    
    # OFFENSIVE WEATHER: Boost our attacks
    our_benefit = calculate_weather_benefit(user, new_weather)
    if our_benefit > 0
      score += our_benefit
      AdvancedAI.log("  #{move.name}: +#{our_benefit} (benefits us)", "Weather")
    elsif our_benefit < 0
      score += our_benefit  # Penalty
      AdvancedAI.log("  #{move.name}: #{our_benefit} (hurts us!)", "Weather")
    end
    
    # DEFENSIVE WEATHER: Hurt opponent
    opponent_penalty = calculate_opponent_weather_penalty(new_weather)
    if opponent_penalty > 0
      score += opponent_penalty
      AdvancedAI.log("  #{move.name}: +#{opponent_penalty} (hurts opponent)", "Weather")
    end
    
    # ABILITY SYNERGY
    if weather_activates_ability?(user, new_weather)
      score += 40
      AdvancedAI.log("  #{move.name}: +40 (activates ability)", "Weather")
    end
    
    return score
  end
  
  def weather_benefits_opponent?(weather)
    return false if weather == :None
    
    @battle.allOtherSideBattlers(0).each do |battler|
      next unless battler && !battler.fainted?
      
      # Check if opponent has weather-boosting ability
      weather_abilities = {
        :Sun       => [:SOLARPOWER, :CHLOROPHYLL, :FLOWERGIFT],
        :Rain      => [:SWIFTSWIM, :RAINDISH, :DRYSKIN],
        :Sandstorm => [:SANDFORCE, :SANDRUSH, :SANDVEIL],
        :Hail      => [:ICEBODY, :SNOWCLOAK, :SLUSHRUSH],
        :Snow      => [:SLUSHRUSH, :ICEBODY],
      }
      
      if weather_abilities[weather]&.include?(battler.ability_id)
        return true
      end
      
      # Check if opponent has weather-boosted moves
      battler.moves.each do |m|
        next unless m
        
        case weather
        when :Sun
          return true if [:FIRE].include?(m.type)
        when :Rain
          return true if [:WATER].include?(m.type)
        when :Sandstorm
          return true if [:ROCK, :GROUND, :STEEL].include?(battler.pbTypes(true).first)
        end
      end
    end
    
    return false
  end
  
  def calculate_weather_benefit(user, weather)
    benefit = 0
    
    case weather
    when :Sun
      # Fire moves 1.5x, Water moves 0.5x
      fire_moves = user.moves.count { |m| m && m.type == :FIRE }
      water_moves = user.moves.count { |m| m && m.type == :WATER }
      
      benefit += fire_moves * 20
      benefit -= water_moves * 15
      
      # Chlorophyll, Solar Power
      if [:CHLOROPHYLL, :SOLARPOWER].include?(user.battler.ability_id)
        benefit += 30
      end
      
    when :Rain
      # Water moves 1.5x, Fire moves 0.5x
      water_moves = user.moves.count { |m| m && m.type == :WATER }
      fire_moves = user.moves.count { |m| m && m.type == :FIRE }
      
      benefit += water_moves * 20
      benefit -= fire_moves * 15
      
      # Swift Swim, Rain Dish
      if [:SWIFTSWIM, :RAINDISH].include?(user.battler.ability_id)
        benefit += 30
      end
      
    when :Sandstorm
      # Rock types get SpDef boost
      if user.battler.pbTypes(true).include?(:ROCK)
        benefit += 25
      end
      
      # Sand Rush, Sand Force
      if [:SANDRUSH, :SANDFORCE].include?(user.battler.ability_id)
        benefit += 30
      end
      
      # Damage to non-immunetypes (not us)
      unless [:ROCK, :GROUND, :STEEL].include?(user.battler.pbTypes(true).first)
        benefit -= 10  # Hurts us
      end
      
    when :Snow, :Hail
      # Ice types get Def boost (Snow only)
      if weather == :Snow && user.battler.pbTypes(true).include?(:ICE)
        benefit += 25
      end
      
      # Slush Rush
      if user.battler.ability_id == :SLUSHRUSH
        benefit += 30
      end
      
      # Hail damage (not Snow)
      if weather == :Hail && !user.battler.pbTypes(true).include?(:ICE)
        benefit -= 10
      end
    end
    
    return benefit
  end
  
  def calculate_opponent_weather_penalty(weather)
    penalty = 0
    
    @battle.allOtherSideBattlers(0).each do |battler|
      next unless battler && !battler.fainted?
      
      case weather
      when :Sun
        # Hurt Water types
        water_moves = battler.moves.count { |m| m && m.type == :WATER }
        penalty += water_moves * 10
        
      when :Rain
        # Hurt Fire types
        fire_moves = battler.moves.count { |m| m && m.type == :FIRE }
        penalty += fire_moves * 10
        
      when :Sandstorm
        # Chip damage to non-immune
        unless [:ROCK, :GROUND, :STEEL].include?(battler.pbTypes(true).first)
          penalty += 15
        end
        
      when :Hail
        # Chip damage to non-Ice
        unless battler.pbTypes(true).include?(:ICE)
          penalty += 15
        end
      end
    end
    
    return penalty
  end
  
  def weather_activates_ability?(user, weather)
    ability_id = user.battler.ability_id
    
    activations = {
      :Sun       => [:CHLOROPHYLL, :SOLARPOWER, :FLOWERGIFT],
      :Rain      => [:SWIFTSWIM, :RAINDISH, :DRYSKIN],
      :Sandstorm => [:SANDRUSH, :SANDFORCE, :SANDVEIL],
      :Hail      => [:SLUSHRUSH, :ICEBODY, :SNOWCLOAK],
      :Snow      => [:SLUSHRUSH, :ICEBODY],
    }
    
    return activations[weather]&.include?(ability_id) || false
  end
  
  # ============================================================================
  # TERRAIN WARS
  # ============================================================================
  
  def move_sets_terrain?(move)
    terrain_moves = {
      :ELECTRICTERRAIN => :Electric,
      :GRASSYTERRAIN   => :Grassy,
      :MISTYTERRAIN    => :Misty,
      :PSYCHICTERRAIN  => :Psychic,
    }
    return terrain_moves.key?(move.id)
  end
  
  def evaluate_terrain_setting(user, move)
    score = 0
    
    terrain_map = {
      :ELECTRICTERRAIN => :Electric,
      :GRASSYTERRAIN   => :Grassy,
      :MISTYTERRAIN    => :Misty,
      :PSYCHICTERRAIN  => :Psychic,
    }
    
    new_terrain = terrain_map[move.id]
    current_terrain = @battle.field.terrain
    
    # Don't set terrain that's already active
    if current_terrain == new_terrain
      AdvancedAI.log("  #{move.name}: -80 (already active)", "Terrain")
      return -80
    end
    
    # COUNTER-TERRAIN: Remove opponent's beneficial terrain
    if terrain_benefits_opponent?(current_terrain)
      score += 45
      AdvancedAI.log("  #{move.name}: +45 (counter opponent terrain)", "Terrain")
    end
    
    # TERRAIN BENEFITS
    case new_terrain
    when :Electric
      # Electric moves 1.3x power (grounded)
      electric_moves = user.moves.count { |m| m && m.type == :ELECTRIC }
      score += electric_moves * 25
      
      # Prevents sleep
      score += 15
      
    when :Grassy
      # Grass moves 1.3x, heals grounded
      grass_moves = user.moves.count { |m| m && m.type == :GRASS }
      score += grass_moves * 20
      
      # Passive healing
      score += 20
      
    when :Misty
      # Halves Dragon moves
      dragon_moves_opponent = 0
      @battle.allOtherSideBattlers(user.index).each do |opp|
        next unless opp
        dragon_moves_opponent += opp.moves.count { |m| m && m.type == :DRAGON }
      end
      score += dragon_moves_opponent * 25
      
      # Prevents status (grounded)
      score += 20
      
    when :Psychic
      # Psychic moves 1.3x, blocks priority
      psychic_moves = user.moves.count { |m| m && m.type == :PSYCHIC }
      score += psychic_moves * 25
      
      # Blocks priority moves
      score += 30  # Very valuable
    end
    
    # ABILITY SYNERGY
    if terrain_activates_ability?(user, new_terrain)
      score += 35
      AdvancedAI.log("  #{move.name}: +35 (activates ability)", "Terrain")
    end
    
    return score
  end
  
  def terrain_benefits_opponent?(terrain)
    return false if terrain == :None
    
    @battle.allOtherSideBattlers(0).each do |battler|
      next unless battler && !battler.fainted?
      
      case terrain
      when :Electric
        return true if battler.moves.any? { |m| m && m.type == :ELECTRIC }
      when :Grassy
        return true if battler.moves.any? { |m| m && m.type == :GRASS }
      when :Psychic
        return true if battler.moves.any? { |m| m && m.type == :PSYCHIC }
      when :Misty
        # Hurts Dragon users
        return true if battler.moves.any? { |m| m && m.type == :DRAGON }
      end
    end
    
    return false
  end
  
  def terrain_activates_ability?(user, terrain)
    ability_id = user.battler.ability_id
    
    activations = {
      :Electric => [:SURGESURFER],
      :Grassy   => [:GRASSPELT],
      :Psychic  => [],  # No specific ability activations
      :Misty    => [],
    }
    
    return activations[terrain]&.include?(ability_id) || false
  end
end

AdvancedAI.log("Weather & Terrain Wars loaded", "Core")
AdvancedAI.log("  - Counter-weather strategy", "Weather")
AdvancedAI.log("  - Counter-terrain strategy", "Terrain")
AdvancedAI.log("  - Ability synergy detection", "Weather")

### FILE: Advanced_Items.rb ###
#===============================================================================
# Advanced AI System - Advanced Item Intelligence
# Handles Pinch Berries, Eject mechanics, Air Balloon, and situational items
#===============================================================================

module AdvancedAI
  # Pinch Berry activation thresholds
  PINCH_BERRIES = {
    :SITRUSBERRY  => 0.50,  # Heals when ≤50% HP
    :ORANBERRY    => 0.50,  # Heals 10 HP
    :FIGYBERRY    => 0.25,  # Heals 1/3 HP at 25%
    :WIKIBERRY    => 0.25,  #
    :MAGOBERRY    => 0.25,  #
    :AGUAVBERRY   => 0.25,  #
    :IAPAPABERRY  => 0.25,  #
    :LIECHIBERRY  => 0.25,  # +1 Atk
    :PETAYABERRY  => 0.25,  # +1 SpAtk
    :SALACBERRY   => 0.25,  # +1 Speed
    :GANLONBERRY  => 0.25,  # +1 Def
    :APICOTBERRY  => 0.25,  # +1 SpDef
    :STARFBERRY   => 0.25,  # +2 random stat
    :CUSTAPBERRY  => 0.25,  # Priority
  }
  
  # Type resist berries
  TYPE_RESIST_BERRIES = {
    :OCCABERRY    => :FIRE,
    :PASSHOBERRY  => :WATER,
    :WACANBERRY   => :ELECTRIC,
    :RINDOBERRY   => :GRASS,
    :YACHEBERRY   => :ICE,
    :CHOPLEBERRY  => :FIGHTING,
    :KEBIABERRY   => :POISON,
    :SHUCABERRY   => :GROUND,
    :COBABERRY    => :FLYING,
    :PAYAPABERRY  => :PSYCHIC,
    :TANGABERRY   => :BUG,
    :CHARTIBERRY  => :ROCK,
    :KASIBBERRY   => :GHOST,
    :HABANBERRY   => :DRAGON,
    :COLBURBERRY  => :DARK,
    :BABIRIBERRY  => :STEEL,
    :CHILANBERRY  => :NORMAL,
    :ROSELIBERRY  => :FAIRY,
  }
end

class Battle::AI
  # ============================================================================
  # PINCH BERRY AWARENESS
  # ============================================================================
  
  alias advanced_items_pbRegisterMove pbRegisterMove
  def pbRegisterMove(user, move)
    score = advanced_items_pbRegisterMove(user, move)
    
    return score unless user && move
    
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted? && target.item
      
      # PINCH BERRIES: Damage threshold awareness
      if AdvancedAI::PINCH_BERRIES.key?(target.item_id)
        score += evaluate_pinch_berry(user, move, target)
      end
      
      # TYPE RESIST BERRIES: Resist once then consumed
      if AdvancedAI::TYPE_RESIST_BERRIES.key?(target.item_id)
        score += evaluate_resist_berry(user, move, target)
      end
      
      # EJECT BUTTON / RED CARD
      if [:EJECTBUTTON, :REDCARD].include?(target.item_id)
        score += evaluate_eject_mechanics(user, move, target)
      end
      
      # AIR BALLOON
      if target.item_id == :AIRBALLOON
        score += evaluate_air_balloon(user, move, target)
      end
      
      # WEAKNESS POLICY
      if target.item_id == :WEAKNESSPOLICY && move.damagingMove?
        score += evaluate_weakness_policy(user, move, target)
      end
      
      # EJECT PACK
      if target.item_id == :EJECTPACK
        score += evaluate_eject_pack(user, move, target)
      end
      
      # ROCKY HELMET / IRON BARBS
      if target.item_id == :ROCKYHELMET || target.ability_id == :IRONBARBS
        score += evaluate_contact_damage(user, move, target)
      end
    end
    
    return score
  end
  
  # ============================================================================
  # PINCH BERRY EVALUATION
  # ============================================================================
  
  def evaluate_pinch_berry(user, move, target)
    return 0 unless move.damagingMove?
    
    score = 0
    berry_id = target.item_id
    activation_threshold = AdvancedAI::PINCH_BERRIES[berry_id]
    
    hp_percent = target.hp.to_f / target.totalhp
    rough_damage = CombatUtilities.estimate_damage(user.battler, move, target, as_percent: true)
    hp_after = hp_percent - rough_damage
    
    # Check if damage will trigger berry
    will_trigger = (hp_percent > activation_threshold && hp_after <= activation_threshold)
    
    if will_trigger
      case berry_id
      when :SITRUSBERRY, :FIGYBERRY, :WIKIBERRY, :MAGOBERRY, :AGUAVBERRY, :IAPAPABERRY
        # Healing berry - try to KO instead
        if rough_damage < hp_percent
          score -= 20  # Don't chip them into berry range
          AdvancedAI.log("  #{berry_id}: -20 (triggers heal)", "Items")
          
          # Unless we can KO through the heal
          heal_amount = (berry_id == :SITRUSBERRY) ? 0.25 : 0.33
          if rough_damage >= hp_percent + heal_amount
            score += 30  # KO through heal
            AdvancedAI.log("  But KOs through heal: +30", "Items")
          end
        end
        
      when :LIECHIBERRY, :PETAYABERRY, :SALACBERRY, :GANLONBERRY, :APICOTBERRY, :STARFBERRY
        # Stat boost berry - DON'T trigger unless KO
        if rough_damage >= hp_percent
          score += 20  # KO before activation
          AdvancedAI.log("  #{berry_id}: +20 (KO before boost)", "Items")
        else
          score -= 35  # Don't give them free +1
          AdvancedAI.log("  #{berry_id}: -35 (triggers stat boost!)", "Items")
        end
        
      when :CUSTAPBERRY
        # Priority berry - less scary
        score -= 10
        AdvancedAI.log("  Custap Berry: -10 (grants priority)", "Items")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # TYPE RESIST BERRY EVALUATION
  # ============================================================================
  
  def evaluate_resist_berry(user, move, target)
    return 0 unless move.damagingMove?
    
    score = 0
    berry_id = target.item_id
    resisted_type = AdvancedAI::TYPE_RESIST_BERRIES[berry_id]
    
    # Check if our move matches the berry type
    if move.type == resisted_type
      type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
      
      if Effectiveness.super_effective?(type_mod)
        # Berry will halve damage
        score -= 25
        AdvancedAI.log("  #{berry_id}: -25 (halves SE damage)", "Items")
        
        # Check if we'd still KO
        rough_damage = CombatUtilities.estimate_damage(user.battler, move, target, as_percent: true)
        halved_damage = rough_damage * 0.5
        
        if halved_damage >= target.hp.to_f / target.totalhp
          score += 40  # Still KO
          AdvancedAI.log("  But still KOs: +40", "Items")
        end
      end
    end
    
    return score
  end
  
  # ============================================================================
  # EJECT BUTTON / RED CARD EVALUATION
  # ============================================================================
  
  def evaluate_eject_mechanics(user, move, target)
    return 0 unless move.damagingMove?
    
    score = 0
    item_id = target.item_id
    
    # Eject Button: Target switches out when hit
    # Red Card: User switches out when hitting
    
    if item_id == :EJECTBUTTON
      # They get a free switch - check if bad for us
      hp_percent = target.hp.to_f / target.totalhp
      
      if hp_percent < 0.4
        # Good - they're weak, force them out before recovery
        score += 15
        AdvancedAI.log("  Eject Button (weak target): +15 (forces out)", "Items")
      else
        # Bad - they get a free pivot
        score -= 20
        AdvancedAI.log("  Eject Button: -20 (free switch)", "Items")
      end
      
    elsif item_id == :REDCARD
      # We get forced out - generally bad
      score -= 30
      AdvancedAI.log("  Red Card: -30 (forces us out)", "Items")
      
      # Unless we want to switch anyway
      if user.hp < user.totalhp * 0.3
        score += 25  # Fine, we wanted out
        AdvancedAI.log("  But low HP: +25 (wanted to switch)", "Items")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # AIR BALLOON EVALUATION
  # ============================================================================
  
  def evaluate_air_balloon(user, move, target)
    return 0 unless move.damagingMove?
    
    score = 0
    
    # Air Balloon: Ground immunity until hit
    if move.type == :GROUND
      # Our Ground move does nothing
      score -= 80
      AdvancedAI.log("  Air Balloon: -80 (Ground immunity)", "Items")
    else
      # We can pop the balloon
      score += 15
      AdvancedAI.log("  Air Balloon: +15 (pop it!)", "Items")
      
      # Bonus if we have Ground coverage next turn
      if user.moves.any? { |m| m && m.type == :GROUND }
        score += 10
        AdvancedAI.log("  Have Ground move: +10 (follow-up)", "Items")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # WEAKNESS POLICY EVALUATION
  # ============================================================================
  
  def evaluate_weakness_policy(user, move, target)
    return 0 unless move.damagingMove?
    
    score = 0
    type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
    
    if Effectiveness.super_effective?(type_mod)
      rough_damage = CombatUtilities.estimate_damage(user.battler, move, target, as_percent: true)
      
      if rough_damage >= target.hp.to_f / target.totalhp
        # KO before trigger
        score += 30
        AdvancedAI.log("  Weakness Policy: +30 (KO before trigger)", "Items")
      else
        # Triggers +2/+2 - BAD
        score -= 50
        AdvancedAI.log("  Weakness Policy: -50 (triggers +2/+2!)", "Items")
        
        # CRITICAL if they're a sweeper
        if target.attack > 100 || target.spatk > 100
          score -= 30
          AdvancedAI.log("  High offense: -30 (becomes unstoppable)", "Items")
        end
      end
    end
    
    return score
  end
  
  # ============================================================================
  # EJECT PACK EVALUATION
  # ============================================================================
  
  def evaluate_eject_pack(user, move, target)
    return 0 unless move.statusMove?
    
    score = 0
    
    # Eject Pack: Switches out when stats are lowered
    # Check if move lowers stats
    stat_drop_moves = [:LOWER_TARGET_ATK_1, :LOWER_TARGET_DEF_1, :LOWER_TARGET_SPATK_1,
                      :LOWER_TARGET_SPDEF_1, :LOWER_TARGET_SPEED_1]
    
    if stat_drop_moves.include?(move.function_code.to_sym)
      # They escape stat drops for free
      score -= 35
      AdvancedAI.log("  Eject Pack: -35 (escapes stat drop)", "Items")
      
      # Unless we wanted them gone anyway
      if target.stages.values.sum >= 2
        score += 40  # Reset their boosts
        AdvancedAI.log("  But removes boosts: +40", "Items")
      end
    end
    
    return score
  end
  
  # ============================================================================
  # ROCKY HELMET / IRON BARBS EVALUATION
  # ============================================================================
  
  def evaluate_contact_damage(user, move, target)
    return 0 unless move.damagingMove?
    return 0 unless move.contactMove?  # Only contact moves trigger
    
    score = 0
    
    # 1/6 max HP damage to user
    recoil_damage = user.totalhp / 6.0
    user_hp_percent = user.hp.to_f / user.totalhp
    
    if user_hp_percent < 0.3
      # Low HP - avoid contact
      score -= 25
      AdvancedAI.log("  Rocky Helmet (low HP): -25 (avoid contact)", "Items")
    elsif user_hp_percent < 0.5
      score -= 15
      AdvancedAI.log("  Rocky Helmet: -15 (contact damage)", "Items")
    else
      score -= 5
      AdvancedAI.log("  Rocky Helmet: -5 (minor chip)", "Items")
    end
    
    # Unless it KOs the target
    rough_damage = CombatUtilities.estimate_damage(user.battler, move, target, as_percent: true)
    if rough_damage >= target.hp.to_f / target.totalhp
      score += 20  # Worth it for the KO
      AdvancedAI.log("  But KOs: +20 (worth it)", "Items")
    end
    
    return score
  end
end

AdvancedAI.log("Advanced Item Intelligence loaded", "Core")
AdvancedAI.log("  - Pinch Berry awareness (Sitrus, Liechi, etc.)", "Items")
AdvancedAI.log("  - Type Resist Berries", "Items")
AdvancedAI.log("  - Eject mechanics (Button, Red Card, Pack)", "Items")
AdvancedAI.log("  - Air Balloon strategy", "Items")
AdvancedAI.log("  - Contact damage (Rocky Helmet, Iron Barbs)", "Items")

### FILE: Item_Intelligence.rb ###
#===============================================================================
# [015] Item Intelligence - 693+ Item Analysis
#===============================================================================
# Intelligent Item Recognition and Usage
#
# Categories:
# - Choice Items (Choice Band, Choice Specs, Choice Scarf)
# - Life Orb & Damage Boost Items
# - Assault Vest & Defensive Items
# - Recovery Items (Leftovers, Black Sludge, etc.)
# - Type-Boosting Items (Charcoal, Mystic Water, etc.)
# - Status Items (Flame Orb, Toxic Orb, etc.)
# - Terrain/Weather Extenders
# - Z-Crystals & Mega Stones (DBK Integration)
#===============================================================================

module AdvancedAI
  module ItemIntelligence
    
    #===========================================================================
    # Choice Item Detection (locked into one move)
    #===========================================================================
    CHOICE_ITEMS = {
      :CHOICEBAND   => { stat: :attack, multiplier: 1.5 },
      :CHOICESPECS  => { stat: :spatk, multiplier: 1.5 },
      :CHOICESCARF  => { stat: :speed, multiplier: 1.5 },
    }
    
    #===========================================================================
    # Damage Boost Items
    #===========================================================================
    DAMAGE_BOOST_ITEMS = {
      # Life Orb (1.3x damage, 10% recoil)
      :LIFEORB      => { multiplier: 1.3, recoil: 0.1 },
      
      # Expert Belt (1.2x SE damage)
      :EXPERTBELT   => { multiplier: 1.2, condition: :super_effective },
      
      # Muscle Band / Wise Glasses
      :MUSCLEBAND   => { multiplier: 1.1, category: :physical },
      :WISEGLASSES  => { multiplier: 1.1, category: :special },
      
      # Metronome (stacks per repeated move)
      :METRONOME    => { multiplier: 1.2, stacks: true, max: 2.0 },
      
      # Punching Glove (1.1x punching moves, no contact)
      :PUNCHINGGLOVE => { multiplier: 1.1, moves: :punching, no_contact: true },
      
      # Loaded Dice (multi-hit = 4-5 hits)
      :LOADEDDICE   => { multihit: true, min: 4 },
    }
    
    #===========================================================================
    # Type-Boosting Items (1.2x type damage)
    #===========================================================================
    TYPE_BOOST_ITEMS = {
      :CHARCOAL       => :FIRE,
      :MYSTICWATER    => :WATER,
      :MIRACLESEED    => :GRASS,
      :MAGNET         => :ELECTRIC,
      :NEVERMELTICE   => :ICE,
      :BLACKBELT      => :FIGHTING,
      :POISONBARB     => :POISON,
      :SOFTSAND       => :GROUND,
      :SHARPBEAK      => :FLYING,
      :TWISTEDSPOON   => :PSYCHIC,
      :SILVERPOWDER   => :BUG,
      :HARDSTONE      => :ROCK,
      :SPELLTAG       => :GHOST,
      :DRAGONFANG     => :DRAGON,
      :BLACKGLASSES   => :DARK,
      :METALCOAT      => :STEEL,
      :SILKSCARF      => :NORMAL,
      :PIXIEPLATE     => :FAIRY,
    }
    
    #===========================================================================
    # Plates & Type-Memories (1.2x + Arceus/Silvally form change)
    #===========================================================================
    PLATE_ITEMS = [
      :FLAMEPLATE, :SPLASHPLATE, :MEADOWPLATE, :ZAPPLATE,
      :ICICLEPLATE, :FISTPLATE, :TOXICPLATE, :EARTHPLATE,
      :SKYPLATE, :MINDPLATE, :INSECTPLATE, :STONEPLATE,
      :SPOOKYPLATE, :DRACOPLATE, :DREADPLATE, :IRONPLATE,
      :PIXIEPLATE,
    ]
    
    MEMORY_ITEMS = [
      :BURNINGMEMORY, :WATERMEMORY, :GRASSYMEMORY, :ELECTRICMEMORY,
      :ICYMEMORY, :FIGHTINGMEMORY, :POISONMEMORY, :GROUNDMEMORY,
      :FLYINGMEMORY, :PSYCHICMEMORY, :BUGMEMORY, :ROCKMEMORY,
      :GHOSTMEMORY, :DRAGONMEMORY, :DARKMEMORY, :STEELMEMORY,
      :FAIRYMEMORY,
    ]
    
    #===========================================================================
    # Defensive Items
    #===========================================================================
    DEFENSIVE_ITEMS = {
      # Assault Vest (1.5x SpDef, no status moves)
      :ASSAULTVEST  => { stat: :spdef, multiplier: 1.5, no_status: true },
      
      # Eviolite (1.5x Def/SpDef for NFE Pokemon)
      :EVIOLITE     => { stat: :both, multiplier: 1.5, nfe_only: true },
      
      # Rocky Helmet (1/6 damage on contact)
      :ROCKYHELMET  => { recoil: 0.167, contact: true },
      
      # Focus Sash (survive 1 hit at full HP)
      :FOCUSSASH    => { survive: true, full_hp: true },
      
      # Focus Band (10% chance to survive at 1 HP)
      :FOCUSBAND    => { survive: true, chance: 0.1 },
      
      # Weakness Policy (+2 Atk/SpAtk when hit SE)
      :WEAKNESSPOLICY => { trigger: :super_effective, boost: 2 },
      
      # Air Balloon (Ground immunity until hit)
      :AIRBALLOON   => { immunity: :GROUND, until_hit: true },
      
      # Heavy-Duty Boots (ignore entry hazards)
      :HEAVYDUTYBOOTS => { hazard_immunity: true },
    }
    
    #===========================================================================
    # Recovery Items
    #===========================================================================
    RECOVERY_ITEMS = {
      :LEFTOVERS    => { heal: 0.0625, per_turn: true },
      :BLACKSLUDGE  => { heal: 0.0625, per_turn: true, poison_only: true },
      :SHELLBELL    => { heal: 0.125, on_damage: true },
      :SITRUSBERRY  => { heal: 0.25, trigger: :low_hp },
      :ORANBERRY    => { heal: 10, trigger: :low_hp },
    }
    
    #===========================================================================
    # Status Orbs (Guts/Flame Orb synergy)
    #===========================================================================
    STATUS_ORBS = {
      :FLAMEORB     => { status: :burn, turn: 1 },
      :TOXICORB     => { status: :toxic, turn: 1 },
    }
    
    #===========================================================================
    # Terrain/Weather Extenders
    #===========================================================================
    EXTENDER_ITEMS = {
      :HEATROCK     => { weather: :sun, turns: 3 },
      :DAMPROCK     => { weather: :rain, turns: 3 },
      :SMOOTHROCK   => { weather: :sandstorm, turns: 3 },
      :ICYROCK      => { weather: :hail, turns: 3 },
      :TERRAINEXTENDER => { terrain: :any, turns: 3 },
    }
    
    #===========================================================================
    # Item Detection Methods
    #===========================================================================
    
    def self.choice_item?(item_id)
      return false if !item_id
      item_id = item_id.to_sym if item_id.is_a?(String)
      return CHOICE_ITEMS.key?(item_id)
    end
    
    def self.damage_boost_item?(item_id)
      return false if !item_id
      item_id = item_id.to_sym if item_id.is_a?(String)
      return DAMAGE_BOOST_ITEMS.key?(item_id)
    end
    
    def self.type_boost_item?(item_id)
      return false if !item_id
      item_id = item_id.to_sym if item_id.is_a?(String)
      return TYPE_BOOST_ITEMS.key?(item_id) || PLATE_ITEMS.include?(item_id) || MEMORY_ITEMS.include?(item_id)
    end
    
    def self.defensive_item?(item_id)
      return false if !item_id
      item_id = item_id.to_sym if item_id.is_a?(String)
      return DEFENSIVE_ITEMS.key?(item_id)
    end
    
    def self.recovery_item?(item_id)
      return false if !item_id
      item_id = item_id.to_sym if item_id.is_a?(String)
      return RECOVERY_ITEMS.key?(item_id)
    end
    
    # Calculates Item Damage Multiplier
    def self.calculate_item_multiplier(battler, move)
      return 1.0 if !battler || !move
      item = battler.item_id
      return 1.0 if !item
      
      multiplier = 1.0
      
      # Choice Items
      if CHOICE_ITEMS.key?(item)
        data = CHOICE_ITEMS[item]
        if (data[:stat] == :attack && move.physicalMove?) ||
           (data[:stat] == :spatk && move.specialMove?) ||
           (data[:stat] == :speed)
          multiplier *= data[:multiplier]
        end
      end
      
      # Life Orb
      if item == :LIFEORB
        multiplier *= 1.3
      end
      
      # Expert Belt (SE only)
      if item == :EXPERTBELT
        # Needs target - handle in battle context
      end
      
      # Type-Boost Items
      if TYPE_BOOST_ITEMS.key?(item)
        multiplier *= 1.2 if move.type == TYPE_BOOST_ITEMS[item]
      end
      
      # Muscle Band / Wise Glasses
      if item == :MUSCLEBAND && move.physicalMove?
        multiplier *= 1.1
      elsif item == :WISEGLASSES && move.specialMove?
        multiplier *= 1.1
      end
      
      return multiplier
    end
    
    # Checks if Pokemon is Choice-locked
    def self.choice_locked?(battler)
      return false if !battler
      return false if !battler.item_id
      return false if !choice_item?(battler.item_id)
      
      # Check if already used a move
      return battler.effects[PBEffects::ChoiceBand] if defined?(PBEffects::ChoiceBand)
      return false
    end
    
    # Checks if Assault Vest blocks Status Moves
    def self.blocks_status_moves?(battler)
      return false if !battler
      return battler.item_id == :ASSAULTVEST
    end
    
    # Threat Modifier for Item
    def self.get_item_threat_modifier(battler)
      return 0.0 if !battler
      item = battler.item_id
      return 0.0 if !item
      
      modifier = 0.0
      
      # Choice Items = +1.0 threat (locked but powerful)
      modifier += 1.0 if choice_item?(item)
      
      # Life Orb = +0.8 threat
      modifier += 0.8 if item == :LIFEORB
      
      # Assault Vest = -0.5 threat (defensive)
      modifier -= 0.5 if item == :ASSAULTVEST
      
      # Weakness Policy = +0.5 threat (can be dangerous)
      modifier += 0.5 if item == :WEAKNESSPOLICY
      
      # Focus Sash = -0.3 threat (survives 1 hit)
      modifier -= 0.3 if item == :FOCUSSASH
      
      # Heavy-Duty Boots = -0.2 threat (ignores hazards)
      modifier -= 0.2 if item == :HEAVYDUTYBOOTS
      
      return modifier
    end
    
    #===========================================================================
    # Item Recommendations
    #===========================================================================
    
    # Recommends best item for Pokemon Role
    def self.recommend_item_for_role(pokemon, role)
      return nil if !pokemon || !role
      
      case role
      when :sweeper
        # Hoher Atk/SpAtk → Life Orb oder Choice
        if pokemon.speed >= 100
          return :CHOICESCARF  # Outspeed everything
        elsif pokemon.attack >= pokemon.spatk
          return :CHOICEBAND   # Physical sweeper
        else
          return :CHOICESPECS  # Special sweeper
        end
        
      when :wall
        # Hohe Def/SpDef → Recovery
        return :LEFTOVERS
        
      when :tank
        # Hohe HP + Atk → Assault Vest or Life Orb
        return :ASSAULTVEST
        
      when :support
        # Status moves → Light Clay or Terrain Extender
        return :LIGHTCLAY
        
      when :wallbreaker
        # Extreme offense → Life Orb
        return :LIFEORB
        
      when :pivot
        # U-turn/Volt Switch → Heavy-Duty Boots
        return :HEAVYDUTYBOOTS
        
      when :lead
        # Hazards → Focus Sash
        return :FOCUSSASH
      end
      
      return nil
    end

    #===========================================================================
    # #18: Additional Item Awareness
    #===========================================================================

    # Utility Umbrella: ignores weather effects on moves/abilities
    def self.has_utility_umbrella?(battler)
      return false unless battler
      item = battler.respond_to?(:item_id) ? battler.item_id : nil
      item == :UTILITYUMBRELLA
    end

    # Type Gems: consume for 1.3x type damage (Gen 5+ = 1.3x, not 1.5x)
    TYPE_GEMS = {
      :NORMALGEM   => :NORMAL,   :FIREGEM    => :FIRE,    :WATERGEM   => :WATER,
      :ELECTRICGEM => :ELECTRIC, :GRASSGEM   => :GRASS,   :ICEGEM     => :ICE,
      :FIGHTINGGEM => :FIGHTING, :POISONGEM  => :POISON,  :GROUNDGEM  => :GROUND,
      :FLYINGGEM   => :FLYING,   :PSYCHICGEM => :PSYCHIC, :BUGGEM     => :BUG,
      :ROCKGEM     => :ROCK,     :GHOSTGEM   => :GHOST,   :DRAGONGEM  => :DRAGON,
      :DARKGEM     => :DARK,     :STEELGEM   => :STEEL,   :FAIRYGEM   => :FAIRY,
    }

    def self.has_type_gem?(battler, move_type = nil)
      return false unless battler
      item = battler.respond_to?(:item_id) ? battler.item_id : nil
      return false unless item && TYPE_GEMS.key?(item)
      return true unless move_type
      TYPE_GEMS[item] == move_type
    end

    # Sticky Barb: damages holder, transfers on contact
    def self.has_sticky_barb?(battler)
      return false unless battler
      item = battler.respond_to?(:item_id) ? battler.item_id : nil
      item == :STICKYBARB
    end

    # Mental Herb: cures Taunt/Encore/Disable/Torment once
    def self.has_mental_herb?(battler)
      return false unless battler
      item = battler.respond_to?(:item_id) ? battler.item_id : nil
      item == :MENTALHERB
    end

    # Weather extender evaluation: does holder extend weather?
    def self.extends_weather?(battler, weather_type = nil)
      return false unless battler
      item = battler.respond_to?(:item_id) ? battler.item_id : nil
      return false unless item && EXTENDER_ITEMS.key?(item)
      return true unless weather_type
      ext = EXTENDER_ITEMS[item]
      ext[:weather].to_s.downcase == weather_type.to_s.downcase
    end

    # Calculate gem bonus for move scoring
    def self.gem_damage_bonus(battler, move)
      return 0 unless battler && move && move.damagingMove?
      return 0 unless has_type_gem?(battler, move.type)
      # Gem gives 1.3x, translated to ~ +15 score points
      15
    end

    # Score penalty for attacking a Mental Herb holder with Taunt/Encore
    def self.mental_herb_penalty(target, move)
      return 0 unless target && move
      return 0 unless [:TAUNT, :ENCORE, :DISABLE, :TORMENT].include?(move.id)
      return 0 unless has_mental_herb?(target)
      -25  # They'll cure it immediately
    end

    # Score adjustment for Utility Umbrella (weather moves less effective)
    def self.utility_umbrella_penalty(target, move)
      return 0 unless target && move
      return 0 unless has_utility_umbrella?(target)
      # If our move relies on weather (Thunder/Hurricane in Rain, Solar Beam in Sun)
      weather_boosted = [:THUNDER, :HURRICANE, :SOLARBEAM, :SOLARBLADE, :WEATHERBALL, :BLIZZARD]
      return -20 if weather_boosted.include?(move.id)
      0
    end
    
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.choice_item?(item_id)
    ItemIntelligence.choice_item?(item_id)
  end
  
  def self.choice_locked?(battler)
    ItemIntelligence.choice_locked?(battler)
  end
  
  def self.blocks_status_moves?(battler)
    ItemIntelligence.blocks_status_moves?(battler)
  end
  
  def self.calculate_item_multiplier(battler, move)
    ItemIntelligence.calculate_item_multiplier(battler, move)
  end
  
  def self.get_item_threat_modifier(battler)
    ItemIntelligence.get_item_threat_modifier(battler)
  end
  
  def self.recommend_item_for_role(pokemon, role)
    ItemIntelligence.recommend_item_for_role(pokemon, role)
  end

  def self.has_utility_umbrella?(battler)
    ItemIntelligence.has_utility_umbrella?(battler)
  end

  def self.has_type_gem?(battler, move_type = nil)
    ItemIntelligence.has_type_gem?(battler, move_type)
  end

  def self.has_sticky_barb?(battler)
    ItemIntelligence.has_sticky_barb?(battler)
  end

  def self.has_mental_herb?(battler)
    ItemIntelligence.has_mental_herb?(battler)
  end

  def self.gem_damage_bonus(battler, move)
    ItemIntelligence.gem_damage_bonus(battler, move)
  end

  def self.mental_herb_penalty(target, move)
    ItemIntelligence.mental_herb_penalty(target, move)
  end

  def self.utility_umbrella_penalty(target, move)
    ItemIntelligence.utility_umbrella_penalty(target, move)
  end
end

#===============================================================================
# Integration in Battle::AI - Wires item intelligence into scoring pipeline
#===============================================================================
class Battle::AI
  def apply_item_intelligence(score, move, user, target)
    return score unless move && user
    
    # Factor in our item's effect on move damage
    if move.damagingMove?
      real_user = user.respond_to?(:battler) ? user.battler : user
      multiplier = AdvancedAI.calculate_item_multiplier(real_user, move)
      if multiplier > 1.0
        # Boost score proportionally (e.g., Life Orb 1.3x → +15 points)
        bonus = ((multiplier - 1.0) * 50).to_i
        score += bonus
      end
    end
    
    # If choice-locked, penalize non-locked moves (they'll fail)
    if target
      real_user = user.respond_to?(:battler) ? user.battler : user
      if AdvancedAI.choice_locked?(real_user)
        last = real_user.lastMoveUsed rescue nil
        if last && move.id != last
          score -= 100  # Can't use this move while choice-locked
        end
      end
      
      # If target blocks status, penalize status moves
      real_target = target.respond_to?(:battler) ? target.battler : target
      if move.category == :Status && AdvancedAI.blocks_status_moves?(real_target)
        score -= 30
      end
    end

    #--- #18: Advanced Item Awareness ---
    real_user = user.respond_to?(:battler) ? user.battler : user

    # Gem damage bonus
    score += AdvancedAI.gem_damage_bonus(real_user, move)

    if target
      real_target = target.respond_to?(:battler) ? target.battler : target

      # Utility Umbrella on target: penalize weather-dependent moves
      score += AdvancedAI.utility_umbrella_penalty(real_target, move)

      # Mental Herb on target: penalize Taunt/Encore/Disable/Torment
      score += AdvancedAI.mental_herb_penalty(real_target, move)

      # Sticky Barb on target: penalize contact moves (barb transfers to us)
      if move.respond_to?(:contactMove?) && move.contactMove? && AdvancedAI.has_sticky_barb?(real_target)
        score -= 10  # Risk inheriting Sticky Barb
      end
    end

    # Weather extender: boost weather-setting moves if we hold extender
    if move.respond_to?(:id)
      weather_moves = {
        :RAINDANCE  => "rain",  :SUNNYDAY    => "sun",
        :SANDSTORM  => "sand",  :HAIL        => "hail",
        :SNOWSCAPE  => "hail",
      }
      wtype = weather_moves[move.id]
      if wtype && ItemIntelligence.extends_weather?(real_user, wtype)
        score += 10  # 8 turns instead of 5 is significant
      end
    end

    #--- Power Herb: instantly execute charge moves ---
    user_item = real_user.respond_to?(:item_id) ? real_user.item_id : nil
    charge_moves = [:SOLARBEAM, :SOLARBLADE, :METEORBEAM, :PHANTOMFORCE,
                    :SHADOWFORCE, :SKULLBASH, :SKYATTACK, :FLY, :DIG, :DIVE,
                    :BOUNCE, :GEOMANCY, :FREEZESHOCK, :ICEBURN, :RAZORWIND, :ELECTROSHOT]
    if user_item == :POWERHERB && charge_moves.include?(move.id)
      bonus = 35
      bonus += 15 if move.id == :METEORBEAM  # Also raises SpAtk
      bonus += 25 if move.id == :GEOMANCY    # +1 SpAtk/SpDef/Speed
      score += bonus
    end

    #--- White Herb: negate self-stat-drops ---
    stat_drop_moves = [:SHELLSMASH, :CLOSECOMBAT, :SUPERPOWER, :OVERHEAT,
                       :DRACOMETEOR, :LEAFSTORM, :FLEURCANNON, :PSYCHOBOOST, :VCREATE]
    if user_item == :WHITEHERB && stat_drop_moves.include?(move.id)
      bonus = move.id == :SHELLSMASH ? 35 : 15
      score += bonus
    end

    #--- Booster Energy: Paradox ability activation ---
    user_ability = real_user.respond_to?(:ability_id) ? real_user.ability_id : nil
    if user_item == :BOOSTERENERGY && [:PROTOSYNTHESIS, :QUARKDRIVE].include?(user_ability)
      # Stat already boosted — favor moves that match the boosted offensive stat
      if move.damagingMove?
        atk = real_user.respond_to?(:attack) ? real_user.attack : 0
        spa = real_user.respond_to?(:spatk) ? real_user.spatk : 0
        if atk > spa
          score += 10 if move.physicalMove?
        else
          score += 10 if move.specialMove?
        end
      end
    end

    return score
  end
end

### FILE: Learning_System.rb ###
#===============================================================================
# Advanced AI System - Learning System
# Pattern Recognition and Adaptive Behavior
#===============================================================================

module AdvancedAI
  module LearningSystem
    # Battle pattern data stored per opponent
    @opponent_patterns = {}
    
    # Reset learning data (called at battle start)
    def self.reset_learning_data(battle)
      @current_battle = battle
      @opponent_patterns = {}
      @turn_history = []
    end
    
    #===========================================================================
    # PATTERN TRACKING
    #===========================================================================
    
    # Record opponent action this turn
    def self.record_action(battler, action_type, action_data = nil)
      return unless battler
      return unless AdvancedAI.tier_feature(100, :learn_patterns)  # Only if enabled
      
      opponent_id = get_opponent_id(battler)
      @opponent_patterns[opponent_id] ||= {
        :actions => [],
        :switches => [],
        :protect_pattern => [],
        :move_preferences => Hash.new(0),
        :hp_thresholds => {},
        :switch_triggers => []
      }
      
      pattern = @opponent_patterns[opponent_id]
      
      case action_type
      when :move
        # Record move usage
        move_id = action_data
        pattern[:move_preferences][move_id] += 1
        pattern[:actions] << {:turn => @current_battle.turnCount, :type => :move, :move => move_id}
        
      when :switch
        # Record switch
        hp_percent = (battler.hp.to_f / battler.totalhp * 100).round
        pattern[:switches] << {:turn => @current_battle.turnCount, :hp_percent => hp_percent}
        pattern[:actions] << {:turn => @current_battle.turnCount, :type => :switch}
        
      when :protect
        # Track Protect usage pattern
        pattern[:protect_pattern] << @current_battle.turnCount
        
      when :hp_threshold
        # Record action at specific HP threshold
        hp_percent = action_data
        pattern[:hp_thresholds][hp_percent] ||= []
        pattern[:hp_thresholds][hp_percent] << action_type
      end
    end
    
    #===========================================================================
    # PATTERN ANALYSIS
    #===========================================================================
    
    # Predict if opponent will use Protect this turn
    def self.predict_protect_usage(battler, skill_level = 100)
      return 0.0 unless skill_level >= 85
      return 0.0 unless AdvancedAI.tier_feature(skill_level, :learn_patterns)
      
      opponent_id = get_opponent_id(battler)
      pattern = @opponent_patterns[opponent_id]
      return 0.0 unless pattern
      
      protect_history = pattern[:protect_pattern]
      return 0.0 if protect_history.empty?
      
      current_turn = @current_battle.turnCount
      
      # Check for alternating pattern (Protect every other turn)
      if protect_history.length >= 2
        intervals = protect_history.each_cons(2).map { |a, b| b - a }
        avg_interval = intervals.sum.to_f / intervals.length
        
        last_protect = protect_history.last
        turns_since = current_turn - last_protect
        
        # If avg interval is ~2 turns and it's been 2 turns since last Protect
        if avg_interval.between?(1.5, 2.5) && turns_since >= avg_interval.round
          return 0.8  # 80% chance they'll Protect
        end
      end
      
      # Check for Turn 1 Protect tendency
      turn1_protects = protect_history.count { |t| t == 1 }
      if turn1_protects >= 2 && current_turn == 1
        return 0.7  # 70% chance of Turn 1 Protect
      end
      
      # General frequency analysis
      total_turns = current_turn
      protect_frequency = protect_history.length.to_f / total_turns
      
      # If they Protect more than 30% of turns
      return protect_frequency if protect_frequency > 0.3
      
      0.0
    end
    
    # Predict if opponent will switch
    def self.predict_switch(battler, skill_level = 100)
      return 0.0 unless skill_level >= 85
      return 0.0 unless AdvancedAI.tier_feature(skill_level, :learn_patterns)
      
      opponent_id = get_opponent_id(battler)
      pattern = @opponent_patterns[opponent_id]
      return 0.0 unless pattern
      
      switch_history = pattern[:switches]
      return 0.0 if switch_history.empty?
      
      # Check current HP against historical switch thresholds
      current_hp_percent = (battler.hp.to_f / battler.totalhp * 100).round
      
      # Find switches at similar HP levels
      similar_hp_switches = switch_history.select do |s|
        (s[:hp_percent] - current_hp_percent).abs < 15  # Within 15% HP
      end
      
      if similar_hp_switches.length >= 2
        return 0.75  # They often switch at this HP range
      end
      
      # Check if they switched last time they were threatened
      # (More complex - requires threat tracking)
      
      0.0
    end
    
    # Get opponent's most used move
    def self.get_preferred_move(battler)
      opponent_id = get_opponent_id(battler)
      pattern = @opponent_patterns[opponent_id]
      return nil unless pattern
      
      move_prefs = pattern[:move_preferences]
      return nil if move_prefs.empty?
      
      # Return most frequently used move
      move_prefs.max_by { |move_id, count| count }&.first
    end
    
    # Check if opponent has predictable behavior
    def self.is_predictable?(battler)
      opponent_id = get_opponent_id(battler)
      pattern = @opponent_patterns[opponent_id]
      return false unless pattern
      
      actions = pattern[:actions]
      return false if actions.length < 5  # Need enough data
      
      # Check for repeated sequences
      last_5_actions = actions.last(5).map { |a| a[:type] }
      
      # If same action 4+ times in last 5 turns = very predictable
      most_common = last_5_actions.group_by(&:itself).values.max_by(&:size)&.size || 0
      return true if most_common >= 4
      
      false
    end
    
    #===========================================================================
    # ADAPTIVE SCORING
    #===========================================================================
    
    # Adjust move score based on learned patterns
    def self.adaptive_move_score(battle, user, move, target, base_score, skill_level = 100)
      return base_score unless skill_level >= 85
      return base_score unless AdvancedAI.tier_feature(skill_level, :learn_patterns)
      return base_score unless target
      
      bonus = 0
      
      # If opponent likely to Protect, avoid attacking
      protect_chance = predict_protect_usage(target, skill_level)
      if protect_chance > 0.5
        if move.damagingMove?
          bonus -= 30  # Don't waste attack on Protect
        elsif [:TOXIC, :WILLOWISP, :THUNDERWAVE].include?(move.id)
          bonus += 25  # Status moves work through Protect prediction
        end
      end
      
      # If opponent likely to switch, use setup/hazards
      switch_chance = predict_switch(target, skill_level)
      if switch_chance > 0.5
        if [:STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB].include?(move.id)
          bonus += 35  # Free hazard setup
        elsif is_setup_move?(move.id)
          bonus += 30  # Free setup turn
        elsif move.damagingMove? && move.power >= 90
          bonus -= 10  # Don't waste strong move on switch
        end
      end
      
      # If opponent is predictable, exploit it
      if is_predictable?(target)
        preferred_move = get_preferred_move(target)
        if preferred_move
          # Check if our move counters their preferred move
          # (Would need move matchup logic here)
          bonus += 10  # Small bonus for predictable opponent
        end
      end
      
      base_score + bonus
    end
    
    #===========================================================================
    # HELPER METHODS
    #===========================================================================
    
    private
    
    def self.get_opponent_id(battler)
      # Generate unique ID for opponent (species + index)
      "#{battler.species}_#{battler.index}"
    end
    
    def self.is_setup_move?(move_id)
      setup_moves = [
        :SWORDSDANCE, :DRAGONDANCE, :NASTYPLOT, :CALMMIND, :QUIVERDANCE,
        :BULKUP, :CURSE, :AGILITY, :ROCKPOLISH, :SHELLSMASH, :GEOMANCY
      ]
      setup_moves.include?(move_id)
    end
  end
end

# API Methods
module AdvancedAI
  def self.reset_learning_data(battle)
    LearningSystem.reset_learning_data(battle)
  end
  
  def self.record_action(battler, action_type, action_data = nil)
    LearningSystem.record_action(battler, action_type, action_data)
  end
  
  def self.predict_protect_usage(battler, skill_level = 100)
    LearningSystem.predict_protect_usage(battler, skill_level)
  end
  
  def self.predict_switch(battler, skill_level = 100)
    LearningSystem.predict_switch(battler, skill_level)
  end
  
  def self.adaptive_move_score(battle, user, move, target, base_score, skill_level = 100)
    LearningSystem.adaptive_move_score(battle, user, move, target, base_score, skill_level)
  end
  
  def self.is_predictable?(battler)
    LearningSystem.is_predictable?(battler)
  end
end

AdvancedAI.log("Learning System loaded", "Learn")
AdvancedAI.log("  - Pattern Recognition (Protect, Switch)", "Learn")
AdvancedAI.log("  - Move Preference Tracking", "Learn")
AdvancedAI.log("  - HP Threshold Analysis", "Learn")
AdvancedAI.log("  - Adaptive Move Scoring", "Learn")
AdvancedAI.log("  - Predictability Detection", "Learn")

### FILE: Prediction_System.rb ###
#===============================================================================
# [016] Prediction System - Switch & Move Prediction
#===============================================================================
# Prediction of opponent actions based on Move Memory and Patterns
#
# Features:
# - Switch Prediction (When will opponent switch?)
# - Move Prediction (Which move is coming?)
# - Pattern Recognition (Recognizes player patterns)
# - Double Switch Detection (Predict + Counter)
#===============================================================================

module AdvancedAI
  module PredictionSystem
    
    #===========================================================================
    # Switch Prediction
    #===========================================================================
    
    # Calculates probability that opponent switches (0-100%)
    def self.predict_switch_chance(battle, opponent)
      return 0 if !battle || !opponent
      
      chance = 0
      
      # 1. Type Disadvantage (+30%)
      user = battle.battlers[(opponent.index + 2) % 4]  # Opposite battler
      if user
        memory = AdvancedAI.get_memory(battle, user)
        if memory && memory[:moves]
          memory[:moves].each do |move_id|
            move = GameData::Move.try_get(move_id)
            next if !move
            
            effectiveness = Effectiveness.calculate(move.type, *opponent.pbTypes(true))
            if Effectiveness.super_effective?(effectiveness)
              chance += 30
              break
            end
          end
        end
      end
      
      # 2. Low HP (+25%)
      if opponent.hp < opponent.totalhp * 0.3
        chance += 25
      elsif opponent.hp < opponent.totalhp * 0.5
        chance += 15
      end
      
      # 3. Stat Drops (-2 or worse = +20%)
      if opponent.stages[:ATTACK] <= -2 || opponent.stages[:SPECIAL_ATTACK] <= -2
        chance += 20
      end
      
      if opponent.stages[:SPEED] <= -2
        chance += 15
      end
      
      # 4. Status Problems (+15%)
      if opponent.status == :BURN || opponent.status == :POISON || opponent.status == :TOXIC
        chance += 15
      end
      
      if opponent.status == :PARALYSIS
        chance += 10
      end
      
      # 5. No effective moves left (+20%)
      if opponent.moves.all? { |m| m && m.pp == 0 }
        chance += 50  # Struggle forced
      end
      
      # 6. Recently switched? (-30%)
      # (Player rarely switches back immediately)
      if opponent.turnCount <= 1
        chance -= 30
      end
      
      # Cap at 0-95%
      chance = [[chance, 95].min, 0].max
      
      return chance
    end
    
    # Returns most likely Switch Target
    def self.predict_switch_target(battle, opponent)
      return nil if !battle || !opponent
      
      # Find best counters in team
      party = battle.pbParty(opponent.index % 2)
      return nil if !party
      
      best_counter = nil
      best_score = 0
      
      user = battle.battlers[(opponent.index + 2) % 4]
      return nil if !user
      
      party.each_with_index do |pokemon, i|
        next if !pokemon || pokemon.fainted? || pokemon.egg?
        next if pokemon == opponent.pokemon  # Not current Pokemon
        
        score = 0
        
        # Type Matchup
        user.moves.each do |move|
          next if !move
          effectiveness = Effectiveness.calculate(move.type, *pokemon.types)
          
          if Effectiveness.not_very_effective?(effectiveness) || Effectiveness.ineffective?(effectiveness)
            score += 30
          elsif Effectiveness.super_effective?(effectiveness)
            score -= 20
          end
        end
        
        # Pokemon is uninjured? (+20)
        score += 20 if pokemon.hp == pokemon.totalhp
        
        # Pokemon is Wall/Tank? (+15)
        roles = AdvancedAI.detect_roles(pokemon)
        score += 15 if roles.include?(:wall) || roles.include?(:tank)
        
        if score > best_score
          best_score = score
          best_counter = pokemon
        end
      end
      
      return best_counter
    end
    
    #===========================================================================
    # Move Prediction
    #===========================================================================
    
    # Calculates most likely Move (based on Memory)
    def self.predict_next_move(battle, opponent)
      return nil if !battle || !opponent
      
      memory = AdvancedAI.get_memory(battle, opponent)
      return nil if !memory || !memory[:move_frequency]
      
      # Find most used Move
      most_used = nil
      highest_count = 0
      
      memory[:move_frequency].each do |move_id, count|
        if count > highest_count
          highest_count = count
          most_used = move_id
        end
      end
      
      # But: Last Move Repeat is unlikely
      if memory[:last_move] && most_used == memory[:last_move]
        # Find second most frequent
        second_most = nil
        second_count = 0
        
        memory[:move_frequency].each do |move_id, count|
          next if move_id == most_used
          if count > second_count
            second_count = count
            second_most = move_id
          end
        end
        
        most_used = second_most if second_most
      end
      
      return most_used
    end
    
    # Rates Move based on Prediction
    def self.score_prediction_bonus(battle, user, target, move, predicted_move)
      return 0 if !battle || !user || !target || !move || !predicted_move
      
      bonus = 0
      predicted_move_data = GameData::Move.try_get(predicted_move)
      return 0 if !predicted_move_data
      
      # 1. Protect against strong Attack (+40)
      if AdvancedAI.protect_move?(move.id)
        if predicted_move_data.power >= 80
          bonus += 40
        end
        
        # Extra Bonus against Setup
        if AdvancedAI.setup_move?(predicted_move)
          bonus += 20  # Block setup with Protect
        end
      end
      
      # 2. Resistance against predicted Move (+25)
      if move.category != :Status
        effectiveness = Effectiveness.calculate(predicted_move_data.type, user.type1, user.type2)
        if Effectiveness.not_very_effective?(effectiveness) || Effectiveness.ineffective?(effectiveness)
          bonus += 25
        end
      end
      
      # 3. Counter-Move (+35)
      # E.g. Opponent uses Physical Move → Burn
      if move.id == :WILLOWISP && predicted_move_data.physicalMove?
        bonus += 35
      end
      
      # Opponent uses Status Move → Taunt
      if move.id == :TAUNT && predicted_move_data.category == :Status
        bonus += 35
      end
      
      # 4. Switch on predicted OHKO (+50)
      if predicted_move_data.power >= 100
        damage = calculate_predicted_damage(target, user, predicted_move_data)
        if damage >= user.hp
          # Use Pivot move or Protect
          bonus += 50 if AdvancedAI.pivot_move?(move.id)
          bonus += 45 if AdvancedAI.protect_move?(move.id)
        end
      end
      
      return bonus
    end
    
    #===========================================================================
    # Pattern Recognition
    #===========================================================================
    
    # Recognizes Player Patterns
    @battle_patterns = {}
    
    def self.track_pattern(battle, trainer_name, action)
      return if !battle || !trainer_name || !action
      
      @battle_patterns[trainer_name] ||= []
      @battle_patterns[trainer_name] << {
        turn: battle.turnCount,
        action: action
      }
      
      # Keep only last 20 actions
      @battle_patterns[trainer_name] = @battle_patterns[trainer_name].last(20)
    end
    
    # Checks if Player shows Pattern
    def self.detect_pattern(trainer_name, pattern_type)
      return false if !trainer_name || !@battle_patterns[trainer_name]
      
      patterns = @battle_patterns[trainer_name]
      return false if patterns.size < 3
      
      case pattern_type
      when :always_setup_turn1
        # Checks if player always setups turn 1
        turn1_actions = patterns.select { |p| p[:turn] == 1 }
        return false if turn1_actions.empty?
        
        setup_count = turn1_actions.count { |p| p[:action] == :setup }
        return setup_count >= turn1_actions.size * 0.8
        
      when :switches_on_disadvantage
        # Checks if player switches on disadvantage
        disadvantage_switches = patterns.count { |p| p[:action] == :switch_on_disadvantage }
        return disadvantage_switches >= 3
        
      when :always_attack
        # Checks if player almost never uses status
        attack_count = patterns.count { |p| p[:action] == :attack }
        return attack_count >= patterns.size * 0.9
      end
      
      return false
    end
    
    #===========================================================================
    # Double Switch Detection
    #===========================================================================
    
    # Calculates if double switch makes sense
    def self.should_double_switch?(battle, user, predicted_switch)
      return false if !battle || !user || !predicted_switch
      
      # Double Switch: AI switches to Pokemon that counters predicted_switch
      
      # Find best counter for predicted_switch
      party = battle.pbParty(user.index % 2)
      return false if !party
      
      best_counter = nil
      best_score = 0
      
      party.each do |pokemon|
        next if !pokemon || pokemon.fainted? || pokemon.egg?
        next if pokemon == user.pokemon
        
        score = 0
        
        # Type Advantage
        pokemon.moves.each do |move|
          next if !move
          effectiveness = Effectiveness.calculate(move.type, *predicted_switch.types)
          score += 40 if Effectiveness.super_effective?(effectiveness)
        end
        
        # Resists predicted_switch moves?
        predicted_switch.moves.each do |move|
          next if !move
          effectiveness = Effectiveness.calculate(move.type, *pokemon.types)
          score += 20 if Effectiveness.not_very_effective?(effectiveness)
          score += 30 if Effectiveness.ineffective?(effectiveness)
        end
        
        if score > best_score
          best_score = score
          best_counter = pokemon
        end
      end
      
      # Double switch if Score > 60
      return best_score >= 60
    end
    
    #===========================================================================
    # Helper Methods
    #===========================================================================
    
    def self.calculate_predicted_damage(attacker, defender, move)
      return 0 if !attacker || !defender || !move
      
      attack = move.physicalMove? ? attacker.attack : attacker.spatk
      defense = move.physicalMove? ? defender.defense : defender.spdef
      
      effectiveness = Effectiveness.calculate(move.type, defender.type1, defender.type2)
      # Effectiveness.calculate already returns the multiplier directly
      multiplier = effectiveness.to_f / Effectiveness::NORMAL_EFFECTIVE_MULTIPLIER.to_f
      
      damage = ((2 * attacker.level / 5 + 2) * move.power * attack / defense / 50 + 2) * multiplier
      return damage.to_i
    end
    
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.predict_switch_chance(battle, opponent)
    PredictionSystem.predict_switch_chance(battle, opponent)
  end
  
  def self.predict_switch_target(battle, opponent)
    PredictionSystem.predict_switch_target(battle, opponent)
  end
  
  def self.predict_next_move(battle, opponent)
    PredictionSystem.predict_next_move(battle, opponent)
  end
  
  def self.score_prediction_bonus(battle, user, target, move, predicted_move)
    PredictionSystem.score_prediction_bonus(battle, user, target, move, predicted_move)
  end
  
  def self.track_pattern(battle, trainer_name, action)
    PredictionSystem.track_pattern(battle, trainer_name, action)
  end
  
  def self.detect_pattern(trainer_name, pattern_type)
    PredictionSystem.detect_pattern(trainer_name, pattern_type)
  end
  
  def self.should_double_switch?(battle, user, predicted_switch)
    PredictionSystem.should_double_switch?(battle, user, predicted_switch)
  end
end

#===============================================================================
# Integration in Battle::AI - Wires prediction logic into scoring pipeline
#===============================================================================
class Battle::AI
  def apply_prediction_logic(score, move, user, target)
    return score unless move && target
    skill = @trainer&.skill || 100
    
    # Predict opponent's next move
    predicted_move = AdvancedAI.predict_next_move(@battle, target)
    if predicted_move
      bonus = AdvancedAI.score_prediction_bonus(@battle, user, target, move, predicted_move)
      score += bonus if bonus && bonus > 0
    end
    
    # If opponent likely to switch, boost pursuit/pivot moves
    switch_chance = AdvancedAI.predict_switch_chance(@battle, target)
    if switch_chance && switch_chance > 0.5
      # Pivot moves are great when opponent is about to switch
      score += 15 if AdvancedAI.pivot_move?(move.id)
      # Pursuit-like trapping
      score += 20 if move.id == :PURSUIT
    end
    
    return score
  end
end

### FILE: Role_Detection.rb ###
#===============================================================================
# Advanced AI System - Role Detection
# Detects 7 Pokemon Roles: Sweeper, Wall, Tank, Support, Wallbreaker, Pivot, Lead
#===============================================================================

module AdvancedAI
  module RoleDetection
    # Pokemon Roles
    ROLES = {
      :sweeper     => "Fast offensive Pokemon (Speed 100+, Atk/SpAtk 100+)",
      :wall        => "Defensive Pokemon (HP/Def/SpDef 100+, Speed <70)",
      :stall       => "Defensive Pokemon with stall moveset (Toxic/Protect/Recovery)",
      :tank        => "Bulky offensive (HP 90+, Atk/SpAtk 100+)",
      :support     => "Support moves (Screens, Hazards, Status)",
      :wallbreaker => "High power breaker (Atk/SpAtk 120+)",
      :pivot       => "U-turn, Volt Switch, Flip Turn user",
      :lead        => "Hazard setter, Fast Taunt user"
    }
    
    # Detects primary and secondary role
    def self.detect_roles(battler)
      return [:balanced, nil] unless battler
      
      roles = []
      
      # Analyze stats
      stats = {
        hp: battler.totalhp,
        attack: battler.attack,
        defense: battler.defense,
        spatk: battler.spatk,
        spdef: battler.spdef,
        speed: battler.speed
      }
      
      # === SWEEPER ===
      if stats[:speed] >= 100 && (stats[:attack] >= 100 || stats[:spatk] >= 100)
        roles << :sweeper
      end
      
      # === WALL ===
      defensive_total = stats[:hp] + stats[:defense] + stats[:spdef]
      if defensive_total >= 300 && stats[:speed] < 70
        roles << :wall
      end
      
      # === STALL ===
      # Stall is a Wall with stall-specific moveset (Toxic/Protect/Recovery combos)
      if AdvancedAI::MoveCategories.has_stall_moveset?(battler)
        # Prioritize :stall over :wall if they have the right moves
        if roles.include?(:wall)
          roles.delete(:wall)
          roles.unshift(:stall)  # Stall becomes primary role
        else
          # Can be a stall mon even without pure wall stats (e.g., Toxapex)
          roles << :stall
        end
      end
      
      # === TANK ===
      if stats[:hp] >= 90 && (stats[:attack] >= 100 || stats[:spatk] >= 100) && stats[:speed] < 90
        roles << :tank
      end
      
      # === WALLBREAKER ===
      if stats[:attack] >= 120 || stats[:spatk] >= 120
        roles << :wallbreaker
      end
      
      # === SUPPORT ===
      if has_support_moves?(battler)
        roles << :support
      end
      
      # === PIVOT ===
      if has_pivot_moves?(battler)
        roles << :pivot
      end
      
      # === LEAD ===
      if has_lead_moves?(battler)
        roles << :lead
      end
      
      # Fallback
      roles << :balanced if roles.empty?
      
      [roles.first, roles[1]]
    end
    
    # Checks if Pokemon has role
    def self.has_role?(battler, role)
      primary, secondary = detect_roles(battler)
      primary == role || secondary == role
    end
    
    # Finds best Pokemon for role
    def self.best_for_role(battle, side_index, role)
      party = battle.pbParty(side_index)
      
      candidates = party.select do |pkmn|
        next false if !pkmn || pkmn.fainted? || pkmn.egg?
        next false if battle.pbFindBattler(pkmn.index, side_index)
        has_role?(pkmn, role)
      end
      
      return nil if candidates.empty?
      
      # Rate candidates
      best = candidates.max_by { |pkmn| rate_role_effectiveness(pkmn, role) }
      party.index(best)
    end
    
    # Recommends role for situation
    def self.recommend_role_for_situation(battle, fainted_index, opponent, skill_level = 100)
      return nil unless skill_level >= 55
      return nil unless opponent
      
      # Analyze opponent role
      opp_role, _ = detect_roles(opponent)
      
      # Counter-Pick: each role has a natural counter
      case opp_role
      when :sweeper
        return :wall           # Wall stops Sweeper
      when :wall, :stall
        return :wallbreaker    # Wallbreaker breaks Wall/Stall
      when :wallbreaker
        return :sweeper        # Outspeed Wallbreaker
      when :support
        return :lead           # Lead (Taunt/Hazards) shuts down Support
      when :tank
        return :wallbreaker    # Break through Tank's bulk
      when :pivot
        return :tank           # Tank facetanks pivots and doesn't mind chip
      when :lead
        return :lead           # Mirror lead: Taunt their hazards
      else
        return :sweeper        # Default: bring offense
      end
    end
    
    private
    
    # Support Moves Check
    def self.has_support_moves?(battler)
      return false unless battler.moves
      
      support_moves = [
        :REFLECT, :LIGHTSCREEN, :AURORAVEIL,
        :STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB,
        :HEALBELL, :AROMATHERAPY, :WISH,
        :TAILWIND, :TRICKROOM,
        :WILLOWISP, :TOXIC, :THUNDERWAVE, :TAUNT
      ]
      
      battler.moves.any? { |m| m && support_moves.include?(m.id) }
    end
    
    # Pivot Moves Check
    def self.has_pivot_moves?(battler)
      return false unless battler.moves
      
      pivot_moves = [:UTURN, :VOLTSWITCH, :FLIPTURN, :PARTINGSHOT, :TELEPORT, :BATONPASS]
      battler.moves.any? { |m| m && pivot_moves.include?(m.id) }
    end
    
    # Lead Moves Check
    def self.has_lead_moves?(battler)
      return false unless battler.moves
      
      lead_moves = [
        :STEALTHROCK, :SPIKES, :STICKYWEB,
        :TAUNT, :FAKEOUT, :QUICKGUARD
      ]
      
      has_lead_move = battler.moves.any? { |m| m && lead_moves.include?(m.id) }
      fast_taunt = battler.speed >= 90 && battler.moves.any? { |m| m && m.id == :TAUNT }
      
      has_lead_move || fast_taunt
    end
    
    # Rates Role Effectiveness
    def self.rate_role_effectiveness(pkmn, role)
      score = 50
      
      case role
      when :sweeper
        score += pkmn.speed / 2
        score += [pkmn.attack, pkmn.spatk].max / 2
      when :wall, :stall
        score += pkmn.totalhp / 3
        score += pkmn.defense / 3
        score += pkmn.spdef / 3
      when :wallbreaker
        score += [pkmn.attack, pkmn.spatk].max
      when :tank
        score += pkmn.totalhp / 2
        score += [pkmn.attack, pkmn.spatk].max / 2
      when :support
        score += 100 if has_support_moves?(pkmn)
        score += pkmn.totalhp / 4  # Bulk helps supports survive to do their job
      when :pivot
        score += 100 if has_pivot_moves?(pkmn)
        score += pkmn.speed / 3    # Speed matters for momentum
      when :lead
        score += 100 if has_lead_moves?(pkmn)
        score += pkmn.speed / 3    # Fast leads set up first
      when :balanced
        # Balanced mons are generalists — rate by overall stat total
        score += (pkmn.totalhp + pkmn.attack + pkmn.defense +
                  pkmn.spatk + pkmn.spdef + pkmn.speed) / 10
      end
      
      score
    end
  end
end

# API-Wrapper
module AdvancedAI
  def self.detect_roles(battler)
    RoleDetection.detect_roles(battler)
  end
  
  def self.has_role?(battler, role)
    RoleDetection.has_role?(battler, role)
  end
  
  def self.best_for_role(battle, side_index, role)
    RoleDetection.best_for_role(battle, side_index, role)
  end
  
  def self.recommend_role_for_situation(battle, fainted_index, opponent, skill_level = 100)
    RoleDetection.recommend_role_for_situation(battle, fainted_index, opponent, skill_level)
  end
end

# Integration in Switch Intelligence — Role Counter-Pick Bonus
# Used by find_best_switch_advanced to boost candidates that counter the opponent's role.
class Battle::AI
  # Returns a score bonus (0-30) for how well a bench Pokemon counters the opponent
  def role_counter_pick_bonus(pkmn, user, skill_level)
    return 0 unless skill_level >= 55
    
    opponent = @battle.allOtherSideBattlers(get_battler_index(user)).find { |b| b && !b.fainted? }
    return 0 unless opponent
    
    recommended_role = AdvancedAI.recommend_role_for_situation(@battle, user.index, opponent, skill_level)
    return 0 unless recommended_role
    
    # Check if this bench Pokemon fills the recommended role
    pkmn_role, pkmn_secondary = AdvancedAI.detect_roles(pkmn)
    
    bonus = 0
    if pkmn_role == recommended_role
      bonus += 25  # Perfect counter-pick
    elsif pkmn_secondary == recommended_role
      bonus += 15  # Secondary role matches
    end
    
    AdvancedAI.log("Role counter-pick: #{pkmn.name} (#{pkmn_role}) vs recommended #{recommended_role} → +#{bonus}", "Role") if bonus > 0
    
    return bonus
  end
end

AdvancedAI.log("Role Detection System loaded (9 roles)", "Role")

### FILE: Setup_Recognition.rb ###
#===============================================================================
# [019] Setup Recognition - 5 Evaluation Systems
#===============================================================================
# Recognizes Setup Moves and evaluates Counter Strategies
#
# Systems:
# 1. Setup Detection (Swords Dance, Nasty Plot, etc.)
# 2. Setup Threat Assessment (how dangerous is Setup?)
# 3. Counter Priority (Haze, Roar, Encore, etc.)
# 4. Optimal Counter Timing (when to counter?)
# 5. Setup Chain Detection (Baton Pass chains)
#===============================================================================

module AdvancedAI
  module SetupRecognition
    
    #===========================================================================
    # Setup Counter Moves
    #===========================================================================
    SETUP_COUNTERS = {
      # Phazing (forced switch)
      :ROAR         => { type: :phaze, priority: -6, bypasses_sub: true },
      :WHIRLWIND    => { type: :phaze, priority: -6, bypasses_sub: true },
      :DRAGONTAIL   => { type: :phaze, priority: -6, damage: true },
      :CIRCLETHROW  => { type: :phaze, priority: -6, damage: true },
      
      # Stat Reset
      :HAZE         => { type: :reset, affects: :all },
      :CLEARSMOG    => { type: :reset, affects: :target, damage: true },
      
      # Disruption
      :ENCORE       => { type: :lock, duration: 3 },
      :TAUNT        => { type: :block, duration: 3, status_only: true },
      :DISABLE      => { type: :block, duration: 4, last_move: true },
      :TORMENT      => { type: :lock, no_repeat: true },
      
      # Stat Copying
      :PSYCHUP      => { type: :copy, positive_only: true },
      :SPECTRALTHIEF => { type: :steal, damage: true },
      
      # Punishment (stronger vs boosted)
      :PUNISHMENT   => { type: :punish, max_power: 200 },
      :STOREDPOWER  => { type: :reward, max_power: 860 },
    }
    
    #===========================================================================
    # Setup Detection
    #===========================================================================
    
    # Detects if Battler has setup (stat boosts)
    def self.has_setup?(battler)
      return false if !battler
      
      # Check for positive stat stages
      [:ATTACK, :DEFENSE, :SPECIAL_ATTACK, :SPECIAL_DEFENSE, 
       :SPEED, :ACCURACY, :EVASION].each do |stat|
        return true if battler.stages[stat] > 0
      end
      
      return false
    end
    
    # Counts Setup Stages
    def self.count_setup_stages(battler)
      return 0 if !battler
      
      total = 0
      [:ATTACK, :DEFENSE, :SPECIAL_ATTACK, :SPECIAL_DEFENSE, 
       :SPEED, :ACCURACY, :EVASION].each do |stat|
        total += battler.stages[stat] if battler.stages[stat] > 0
      end
      
      return total
    end
    
    # Checks if Pokemon recently used setup move
    def self.recently_setup?(battle, battler)
      return false if !battle || !battler
      return false if !AdvancedAI.feature_enabled?(:setup, battle.pbSideSize(0))
      
      # Check Move Memory
      memory = AdvancedAI.get_memory(battle, battler)
      return false if !memory
      
      last_move = memory[:last_move]
      return false if !last_move
      
      return AdvancedAI.setup_move?(last_move)
    end
    
    #===========================================================================
    # Setup Threat Assessment
    #===========================================================================
    
    # Evaluates Setup Threat (0-10 Scale)
    def self.assess_setup_threat(battle, attacker, defender)
      return 0.0 if !battle || !attacker || !defender
      
      threat = 0.0
      
      # 1. Number of Setup Stages (+0.5 per Stage)
      stages = count_setup_stages(attacker)
      threat += stages * 0.5
      
      # 2. Type of Boosts
      if attacker.stages[:ATTACK] >= 2 || attacker.stages[:SPECIAL_ATTACK] >= 2
        threat += 2.0  # Offensive threat
      end
      
      if attacker.stages[:SPEED] >= 2
        threat += 1.5  # Speed threat (hard to stop)
      end
      
      if attacker.stages[:EVASION] >= 1
        threat += 2.0  # Evasion = very annoying
      end
      
      # 3. Pokemon Quality
      # High Base Stat = more dangerous with Boosts
      if attacker.attack >= 120 || attacker.spatk >= 120
        threat += 1.0
      end
      
      if attacker.speed >= 100
        threat += 1.0
      end
      
      # 4. Coverage Moves
      known_moves = AdvancedAI.get_memory(battle, attacker)
      if known_moves && known_moves[:moves]
        coverage_count = 0
        known_moves[:moves].each do |move_id|
          move = GameData::Move.try_get(move_id)
          next if !move || move.category == :Status
          coverage_count += 1
        end
        
        threat += coverage_count * 0.3  # More Coverage = more dangerous
      end
      
      # 5. Sweep Potential
      # Can defender survive?
      if defender.hp < defender.totalhp * 0.5
        threat += 1.5  # Defender weak = higher danger
      end
      
      # Team has no counters left?
      remaining_pokemon = battle.pbAbleNonActiveCount(defender.index)
      if remaining_pokemon <= 1
        threat += 2.0  # Last Pokemon = critical
      end
      
      # Cap at 10.0
      threat = [threat, 10.0].min
      
      return threat
    end
    
    #===========================================================================
    # Counter Priority System
    #===========================================================================
    
    # Finds best Setup Counter Move
    def self.find_best_counter(battle, user, target)
      return nil if !battle || !user || !target
      
      best_move = nil
      best_score = 0
      
      user.moves.each do |move|
        next if !move || move.pp <= 0
        move_id = move.id
        
        # Phazing Moves (Roar, Whirlwind)
        if [:ROAR, :WHIRLWIND, :DRAGONTAIL, :CIRCLETHROW].include?(move_id)
          score = 100
          
          # Less effective against Soundproof
          score -= 50 if target.hasActiveAbility?(:SOUNDPROOF) && [:ROAR].include?(move_id)
          
          # Less effective against Suction Cups
          score -= 80 if target.hasActiveAbility?(:SUCTIONCUPS)
          
          # More points if many boosts
          score += count_setup_stages(target) * 10
          
          if score > best_score
            best_score = score
            best_move = move_id
          end
        end
        
        # Haze (reset all stats)
        if move_id == :HAZE
          score = 90
          score += count_setup_stages(target) * 10
          
          if score > best_score
            best_score = score
            best_move = move_id
          end
        end
        
        # Clear Smog (reset + damage)
        if move_id == :CLEARSMOG
          score = 85
          score += count_setup_stages(target) * 10
          
          # Type effectiveness
          effectiveness = Effectiveness.calculate(move.type, target.type1, target.type2)
          score += 20 if Effectiveness.super_effective?(effectiveness)
          score -= 20 if Effectiveness.not_very_effective?(effectiveness)
          
          if score > best_score
            best_score = score
            best_move = move_id
          end
        end
        
        # Encore (lock into last move)
        if move_id == :ENCORE
          score = 80
          
          # Very good if target used setup move
          if recently_setup?(battle, target)
            score += 40
          end
          
          if score > best_score
            best_score = score
            best_move = move_id
          end
        end
        
        # Taunt (prevent status moves)
        if move_id == :TAUNT
          score = 70
          
          # Good against Support Pokemon
          roles = AdvancedAI.detect_roles(target)
          score += 30 if roles.include?(:support)
          
          if score > best_score
            best_score = score
            best_move = move_id
          end
        end
      end
      
      return best_move
    end
    
    #===========================================================================
    # Optimal Counter Timing
    #===========================================================================
    
    # Determines if we should counter NOW
    def self.should_counter_now?(battle, user, target, skill_level)
      return false if !battle || !user || !target
      
      # Setup threat
      threat = assess_setup_threat(battle, target, user)
      
      # Thresholds based on skill
      threshold = case skill_level
      when 100 then 4.0   # Master: Counter early
      when 90  then 5.0   # Expert
      when 80  then 6.0   # Advanced
      when 70  then 7.0   # Skilled
      else 8.0            # Core: Only if extreme danger
      end
      
      # Counter if threat > threshold
      return threat >= threshold
    end
    
    #===========================================================================
    # Baton Pass Chain Detection
    #===========================================================================
    
    # Checks if Team uses Baton Pass chain
    def self.baton_pass_chain?(battle, side_index)
      return false if !battle
      
      baton_pass_count = 0
      setup_move_count = 0
      
      battle.pbParty(side_index).each do |pokemon|
        next if !pokemon || pokemon.egg?
        
        pokemon.moves.each do |move|
          baton_pass_count += 1 if move.id == :BATONPASS
          setup_move_count += 1 if AdvancedAI.setup_move?(move.id)
        end
      end
      
      # Chain if at least 2 Pokemon have Baton Pass
      # AND at least 3 Setup Moves in Team
      return baton_pass_count >= 2 && setup_move_count >= 3
    end
    
    # Priority against Baton Pass chains
    def self.baton_chain_priority(battle, user)
      return 0 if !battle || !user
      
      # Check if Opponent Team uses Baton Pass
      opponent_side = (user.index % 2 == 0) ? 1 : 0
      return 0 if !baton_pass_chain?(battle, opponent_side)
      
      # Higher Priority for Phaze Moves
      priority_boost = 0
      user.moves.each do |move|
        next if !move
        
        if [:ROAR, :WHIRLWIND, :HAZE, :CLEARSMOG].include?(move.id)
          priority_boost += 30
        end
        
        if [:TAUNT, :ENCORE].include?(move.id)
          priority_boost += 20
        end
      end
      
      return priority_boost
    end
    
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.has_setup?(battler)
    SetupRecognition.has_setup?(battler)
  end
  
  def self.count_setup_stages(battler)
    SetupRecognition.count_setup_stages(battler)
  end
  
  def self.assess_setup_threat(battle, attacker, defender)
    SetupRecognition.assess_setup_threat(battle, attacker, defender)
  end
  
  def self.find_best_setup_counter(battle, user, target)
    SetupRecognition.find_best_counter(battle, user, target)
  end
  
  def self.should_counter_setup_now?(battle, user, target, skill_level)
    SetupRecognition.should_counter_now?(battle, user, target, skill_level)
  end
  
  def self.baton_pass_chain?(battle, side_index)
    SetupRecognition.baton_pass_chain?(battle, side_index)
  end
end

#===============================================================================
# Integration in Battle::AI - Wires setup evaluation into scoring pipeline
#===============================================================================
class Battle::AI
  def apply_setup_evaluation(score, move, user, target)
    return score unless move
    skill = @trainer&.skill || 100
    
    real_user = user.respond_to?(:battler) ? user.battler : user
    
    # If opponent has setup boosts, prioritize counter-measures
    if target
      real_target = target.respond_to?(:battler) ? target.battler : target
      threat = AdvancedAI.assess_setup_threat(@battle, real_target, real_user)
      
      if threat >= 5.0
        # High threat: boost phaze moves (Roar, Whirlwind, Dragon Tail)
        phaze_moves = [:ROAR, :WHIRLWIND, :DRAGONTAIL, :CIRCLETHROW, :HAZE, :CLEARSMOG]
        if phaze_moves.include?(move.id)
          score += (threat * 5).to_i  # Up to +50 for Haze/phaze vs boosted foe
        end
        
        # Priority moves are great against boosted sweepers
        if move.priority > 0 && move.damagingMove?
          score += (threat * 3).to_i  # Up to +30
        end
      end
      
      # Should we counter setup right now?
      if AdvancedAI.should_counter_setup_now?(@battle, real_user, real_target, skill)
        counter_move = AdvancedAI.find_best_setup_counter(@battle, real_user, real_target)
        if counter_move && move.id == counter_move
          score += 25  # Boost the recommended counter move
        end
      end
    end
    
    # Our own setup: boost setup moves if safe
    if AdvancedAI.setup_move?(move.id) && target
      real_target = target.respond_to?(:battler) ? target.battler : target
      # Don't set up if opponent is already boosted and threatening
      opponent_threat = AdvancedAI.assess_setup_threat(@battle, real_target, real_user)
      if opponent_threat >= 6.0
        score -= 20  # Don't set up when opponent is already boosted
      end
    end
    
    return score
  end
end

### FILE: Strategic_Awareness.rb ###
#===============================================================================
# Advanced AI System - Strategic Awareness
# Features: Opponent Archetype Recognition, Opponent Win Condition Counter-Play,
# Dynamic Win Condition Shifting, Type Coverage Gap Mapping,
# Collective Health Tracking, Opponent Threat Persistence,
# Proactive Sacking, Defensive Core Recognition
#===============================================================================

module AdvancedAI
  module StrategicAwareness
    #===========================================================================
    # Battle State — persists across turns within a single battle
    #===========================================================================
    @battle_states = {}

    def self.get_state(battle)
      @battle_states[battle.object_id] ||= {
        previous_win_condition: nil,
        win_condition_history:  [],
        eliminated_threats:     [],
        remaining_threats:      [],
        opponent_archetype:     nil,
        archetype_confidence:   0,
        health_trajectory:      [],     # [{turn, our_pct, opp_pct}]
        coverage_gaps:          [],
        critical_pokemon:       [],     # Pokemon that must be preserved
      }
    end

    def self.cleanup(battle)
      @battle_states.delete(battle.object_id) if battle
    end

    #===========================================================================
    # 1. OPPONENT TEAM ARCHETYPE RECOGNITION
    #===========================================================================
    ARCHETYPE_DEFINITIONS = {
      hyper_offense: {
        min_fast_attackers: 4,     # ≥100 speed AND ≥100 attack/spatk
        max_walls: 1,
        hazard_setters: 1,
        description: "All-out attack, minimal defensive backbone"
      },
      balance: {
        min_fast_attackers: 2,
        min_walls: 1,
        min_pivots: 1,
        description: "Mix of offense and defense with pivoting"
      },
      stall: {
        min_walls: 3,
        min_recovery_users: 3,
        max_fast_attackers: 1,
        description: "Passive damage, recovery, and walling"
      },
      rain: { weather: :Rain, description: "Rain-boosted sweepers" },
      sun:  { weather: :Sun,  description: "Sun-boosted sweepers" },
      sand: { weather: :Sandstorm, description: "Sand + Rock/Ground/Steel bulk" },
      hail: { weather: :Hail, description: "Hail/Snow + Aurora Veil" },
      trick_room: {
        min_slow_pokemon: 3,     # ≤50 speed
        has_tr_setter: true,
        description: "Slow Pokemon + Trick Room reversals"
      },
      volt_turn: {
        min_pivots: 3,
        description: "U-turn / Volt Switch / Flip Turn cycling"
      }
    }

    # Rain/Sun/Sand/Hail weather setter abilities
    WEATHER_ABILITIES = {
      :DRIZZLE => :Rain, :PRIMORDIALSEA => :Rain,
      :DROUGHT => :Sun,  :DESOLATELAND => :Sun,
      :SANDSTREAM => :Sandstorm, :SANDSPIT => :Sandstorm,
      :SNOWWARNING => :Hail, :ORICHALCUMPULSE => :Sun,
    }

    RAIN_ABUSERS  = [:SWIFTSWIM, :RAINDISH, :DRYSKIN, :HYDRATION]
    SUN_ABUSERS   = [:CHLOROPHYLL, :SOLARPOWER, :LEAFGUARD, :FLOWERGIFT, :HARVEST]
    SAND_ABUSERS  = [:SANDRUSH, :SANDFORCE, :SANDVEIL]
    HAIL_ABUSERS  = [:SLUSHRUSH, :ICEBODY, :SNOWCLOAK, :ICEFACE]

    PIVOT_MOVES = [:UTURN, :VOLTSWITCH, :FLIPTURN, :PARTINGSHOT, :TELEPORT, :BATONPASS]
    TR_MOVES    = [:TRICKROOM]

    def self.identify_opponent_archetype(battle, user_index)
      state = get_state(battle)
      return state[:opponent_archetype] if state[:opponent_archetype] && state[:archetype_confidence] >= 80

      opp_pokemon = []
      # Gather all known opponent Pokemon (active + revealed in team preview/prior switches)
      battle.allOtherSideBattlers(user_index).each do |b|
        opp_pokemon << b if b && !b.fainted?
      end
      # Also check party for fainted but revealed mons
      opp_party = battle.pbParty(user_index.even? ? 1 : 0) rescue []
      opp_party.each do |pkmn|
        next if !pkmn || pkmn.egg?
        opp_pokemon << pkmn unless opp_pokemon.any? { |p|
          (p.respond_to?(:pokemon) ? p.pokemon : p) == pkmn
        }
      end

      return :unknown if opp_pokemon.empty?

      # Classify each Pokemon
      fast_attackers = 0
      walls = 0
      recovery_users = 0
      pivots = 0
      slow_pokemon = 0
      weather_setters = {}
      weather_abusers = {}
      has_tr_setter = false

      opp_pokemon.each do |mon|
        spd = get_stat(mon, :speed)
        atk = [get_stat(mon, :attack), get_stat(mon, :spatk)].max
        dfn = [get_stat(mon, :defense), get_stat(mon, :spdef)].max
        hp  = get_stat(mon, :hp)

        fast_attackers += 1 if spd >= 95 && atk >= 95
        walls += 1 if dfn >= 90 && hp >= 80 && atk < 90
        slow_pokemon += 1 if spd <= 55

        # Check ability
        ability_id = get_ability(mon)
        if WEATHER_ABILITIES[ability_id]
          w = WEATHER_ABILITIES[ability_id]
          weather_setters[w] = (weather_setters[w] || 0) + 1
        end
        RAIN_ABUSERS.each  { |a| weather_abusers[:Rain] = (weather_abusers[:Rain] || 0) + 1 if ability_id == a }
        SUN_ABUSERS.each   { |a| weather_abusers[:Sun]  = (weather_abusers[:Sun]  || 0) + 1 if ability_id == a }
        SAND_ABUSERS.each  { |a| weather_abusers[:Sandstorm] = (weather_abusers[:Sandstorm] || 0) + 1 if ability_id == a }
        HAIL_ABUSERS.each  { |a| weather_abusers[:Hail] = (weather_abusers[:Hail] || 0) + 1 if ability_id == a }

        # Check moves for pivots / TR / recovery
        moves = get_known_moves(battle, mon)
        moves.each do |mid|
          pivots += 1 if PIVOT_MOVES.include?(mid)
          has_tr_setter = true if TR_MOVES.include?(mid)
          if AdvancedAI.healing_move?(mid)
            recovery_users += 1
          end
        end if moves
      end

      # Score each archetype
      scores = {}

      # Weather teams
      [:Rain, :Sun, :Sandstorm, :Hail].each do |w|
        key = { Rain: :rain, Sun: :sun, Sandstorm: :sand, Hail: :hail }[w]
        if weather_setters[w] && weather_setters[w] >= 1
          scores[key] = 50 + (weather_abusers[w] || 0) * 20
        end
      end

      # Trick Room
      if has_tr_setter && slow_pokemon >= 3
        scores[:trick_room] = 60 + slow_pokemon * 10
      end

      # Volt-Turn
      scores[:volt_turn] = pivots * 25 if pivots >= 3

      # Stall
      if walls >= 3 && recovery_users >= 2
        scores[:stall] = 40 + walls * 15 + recovery_users * 10
      end

      # Hyper Offense
      if fast_attackers >= 4 && walls <= 1
        scores[:hyper_offense] = 40 + fast_attackers * 15
      end

      # Balance (default-ish)
      if fast_attackers >= 2 && walls >= 1
        scores[:balance] = 30 + fast_attackers * 8 + walls * 8 + pivots * 5
      end

      if scores.empty?
        archetype = :balance
        confidence = 30
      else
        archetype = scores.max_by { |_, v| v }.first
        confidence = [scores.values.max, 100].min
      end

      state[:opponent_archetype] = archetype
      state[:archetype_confidence] = confidence
      AdvancedAI.log("[Strategy] Opponent archetype: #{archetype} (#{confidence}%)", "Strategy")
      archetype
    end

    #===========================================================================
    # 2. OPPONENT WIN CONDITION COUNTER-PLAY
    #===========================================================================
    def self.opponent_win_condition_counter(battle, user, move, target)
      return 0 unless target
      archetype = identify_opponent_archetype(battle, user.index) rescue :balance
      bonus = 0

      case archetype
      when :stall
        # Counter stall: Taunt their healers, setup to overpower, Knock Off
        if move.id == :TAUNT
          bonus += 30  # Shut down recovery/status
        end
        if AdvancedAI.setup_move?(move.id)
          bonus += 15  # Setup to break through stall
        end
        if move.id == :KNOCKOFF
          bonus += 20  # Remove Leftovers/Black Sludge
        end
        # Don't play slow vs stall
        if AdvancedAI.stall_move?(move.id)
          bonus -= 20  # They're better at stalling than us
        end

      when :hyper_offense
        # Counter HO: priority, bulk, screens
        if move.priority > 0 && move.damagingMove?
          bonus += 20  # Priority stops their fast mons
        end
        if AdvancedAI.screen_move?(move.id)
          bonus += 15  # Screens blunt their offense
        end
        if AdvancedAI.healing_move?(move.id) && user.hp < user.totalhp * 0.5
          bonus -= 15  # Don't try to heal vs overwhelming offense
        end

      when :rain, :sun, :sand, :hail
        # Counter weather: change weather or use your own weather advantage
        weather_setting_moves = {
          rain: [:SUNNYDAY, :SANDSTORM, :SNOWSCAPE, :HAIL],
          sun:  [:RAINDANCE, :SANDSTORM, :SNOWSCAPE, :HAIL],
          sand: [:RAINDANCE, :SUNNYDAY, :SNOWSCAPE, :HAIL],
          hail: [:RAINDANCE, :SUNNYDAY, :SANDSTORM],
        }
        if weather_setting_moves[archetype]&.include?(move.id)
          bonus += 25  # Override their weather
        end

      when :trick_room
        # Counter TR: set up your own speed control, priority, Taunt the setter
        if move.id == :TAUNT
          bonus += 25  # Block Trick Room
        end
        if move.priority > 0 && move.damagingMove?
          bonus += 15  # Priority ignores speed under TR
        end
        # Our own Trick Room can undo theirs
        if move.id == :TRICKROOM
          bonus += 20
        end

      when :volt_turn
        # Counter pivot chains: trapping, Pursuit, prediction
        if move.id == :PURSUIT
          bonus += 30  # Punish switches
        end
        # Hazards punish constant switching
        if AdvancedAI.hazard_move?(move.id)
          bonus += 20
        end
      end

      bonus
    end

    #===========================================================================
    # 3. DYNAMIC WIN CONDITION SHIFTING
    #===========================================================================
    def self.update_win_condition(battle, user, current_win_con)
      state = get_state(battle)
      prev = state[:previous_win_condition]

      if current_win_con
        state[:win_condition_history] << {
          turn: battle.turnCount,
          type: current_win_con[:type],
          score: current_win_con[:score]
        }
      end

      shift_bonus = 0

      # Detect if our win condition changed (plan failed, adapt)
      if prev && current_win_con && prev != current_win_con[:type]
        AdvancedAI.log("[Strategy] Win condition shifted: #{prev} → #{current_win_con[:type]}", "Strategy")

        # Transitional bonuses to help the AI adapt
        case current_win_con[:type]
        when :attrition
          # Shifted to attrition — boost hazards and recovery
          shift_bonus = 10
        when :stall
          # Shifted to stall — play very conservatively
          shift_bonus = 15
        when :trade
          # Forced into trading — be aggressive
          shift_bonus = 5
        end
      end

      state[:previous_win_condition] = current_win_con ? current_win_con[:type] : nil
      shift_bonus
    end

    # Returns a bonus for moves that align with the shifted strategy
    def self.win_condition_shift_bonus(battle, user, move, current_win_con)
      state = get_state(battle)
      history = state[:win_condition_history]
      return 0 if history.length < 2

      prev_type = history[-2][:type] rescue nil
      curr_type = current_win_con ? current_win_con[:type] : nil
      return 0 unless prev_type && curr_type && prev_type != curr_type

      bonus = 0
      # Sweep attempt failed → adapt
      if prev_type == :sweep && curr_type != :sweep
        # Our sweeper died; pivot to attrition/trade
        bonus += 10 if AdvancedAI.hazard_move?(move.id)
        bonus += 10 if move.damagingMove? && move.power >= 80
      end

      # Attrition not working → go aggressive
      if prev_type == :attrition && [:trade, :sweep].include?(curr_type)
        bonus += 10 if move.damagingMove?
        bonus -= 10 if AdvancedAI.healing_move?(move.id)
      end

      # Stall failing → last resort aggression
      if prev_type == :stall && curr_type != :stall
        bonus += 15 if move.damagingMove?
        bonus -= 15 if AdvancedAI.stall_move?(move.id)
      end

      bonus
    end

    #===========================================================================
    # 4. TYPE COVERAGE GAP MAPPING
    #===========================================================================
    ALL_TYPES = [:NORMAL, :FIRE, :WATER, :ELECTRIC, :GRASS, :ICE,
                 :FIGHTING, :POISON, :GROUND, :FLYING, :PSYCHIC, :BUG,
                 :ROCK, :GHOST, :DRAGON, :DARK, :STEEL, :FAIRY]

    # Returns types our team can't effectively handle
    def self.identify_coverage_gaps(battle, user_index)
      state = get_state(battle)
      return state[:coverage_gaps] unless state[:coverage_gaps].empty?

      our_party = battle.pbParty(user_index.even? ? 0 : 1) rescue []
      return [] if our_party.empty?

      # For each type, check if at least one teammate resists AND can threaten
      gaps = []
      ALL_TYPES.each do |atk_type|
        can_handle = false

        our_party.each do |pkmn|
          next if !pkmn || pkmn.fainted? || pkmn.egg?

          types = get_pokemon_types(pkmn)
          # Check if this Pokemon resists/is immune to this type
          eff = type_effectiveness_against(atk_type, types)
          resists = eff < 1.0

          # Check if this Pokemon can threaten back (has SE coverage)
          has_coverage = false
          pkmn.moves.each do |m|
            next if !m || m.pp <= 0
            move_data = GameData::Move.try_get(m.id)
            next if !move_data || move_data.power == 0
            # Does this move hit the attacking type's common Pokemon?
            has_coverage = true  # Simplified: can attack back
            break
          end if pkmn.moves

          if resists && has_coverage
            can_handle = true
            break
          end
        end

        gaps << atk_type unless can_handle
      end

      state[:coverage_gaps] = gaps
      if gaps.any?
        AdvancedAI.log("[Strategy] Coverage gaps: #{gaps.join(', ')}", "Strategy")
      end
      gaps
    end

    # Identifies Pokemon that are the SOLE answer to an opponent threat
    def self.identify_critical_pokemon(battle, user_index)
      state = get_state(battle)
      return state[:critical_pokemon] unless state[:critical_pokemon].empty?

      our_party = battle.pbParty(user_index.even? ? 0 : 1) rescue []
      opp_pokemon = []
      battle.allOtherSideBattlers(user_index).each do |b|
        opp_pokemon << b if b && !b.fainted?
      end

      critical = []

      opp_pokemon.each do |opp|
        opp_types = get_pokemon_types(opp)
        # Find which of our Pokemon can handle this opponent
        handlers = []
        our_party.each do |pkmn|
          next if !pkmn || pkmn.fainted? || pkmn.egg?
          my_types = get_pokemon_types(pkmn)
          # Can resist their STAB and hit back?
          resists_stab = opp_types.all? { |t| type_effectiveness_against(t, my_types) <= 1.0 }
          handlers << pkmn if resists_stab
        end

        # If only ONE handler → that Pokemon is critical
        if handlers.length == 1
          critical << handlers.first unless critical.include?(handlers.first)
          AdvancedAI.log("[Strategy] #{handlers.first.name} is sole answer to #{get_name(opp)}", "Strategy")
        end
      end

      state[:critical_pokemon] = critical
      critical
    end

    # Bonus for preserving critical Pokemon (penalty for risky plays on them)
    def self.preservation_bonus(battle, user, move, target)
      critical = identify_critical_pokemon(battle, user.index)
      return 0 if critical.empty?

      user_pkmn = user.respond_to?(:pokemon) ? user.pokemon : user
      is_critical = critical.any? { |p| p == user_pkmn }
      return 0 unless is_critical

      bonus = 0
      # Critical Pokemon should avoid risky plays
      if move.respond_to?(:recoilMove?) && move.recoilMove?
        bonus -= 15  # Avoid recoil on critical mon
      end
      if [:EXPLOSION, :SELFDESTRUCT, :MISTYEXPLOSION, :FINALGAMBIT, :HEALINGWISH, :LUNARDANCE, :MEMENTO].include?(move.id)
        bonus -= 50  # Never sacrifice the sole answer
      end
      # Conservative play: boost healing
      if AdvancedAI.healing_move?(move.id) && user.hp < user.totalhp * 0.6
        bonus += 15
      end
      bonus
    end

    #===========================================================================
    # 5. COLLECTIVE HEALTH TRACKING
    #===========================================================================
    def self.track_health(battle, user_index)
      state = get_state(battle)

      our_total = 0; our_max = 0
      opp_total = 0; opp_max = 0

      our_party = battle.pbParty(user_index.even? ? 0 : 1) rescue []
      opp_party = battle.pbParty(user_index.even? ? 1 : 0) rescue []

      our_party.each do |p|
        next if !p || p.egg?
        our_max += p.totalhp
        our_total += [p.hp, 0].max
      end

      opp_party.each do |p|
        next if !p || p.egg?
        opp_max += p.totalhp
        opp_total += [p.hp, 0].max
      end

      our_pct = our_max > 0 ? (our_total.to_f / our_max * 100).round : 0
      opp_pct = opp_max > 0 ? (opp_total.to_f / opp_max * 100).round : 0

      state[:health_trajectory] << {
        turn: battle.turnCount,
        our_pct: our_pct,
        opp_pct: opp_pct
      }

      { our_pct: our_pct, opp_pct: opp_pct, advantage: our_pct - opp_pct }
    end

    # Returns a strategic bonus based on resource advantage
    def self.health_advantage_bonus(battle, user, move)
      health = track_health(battle, user.index)
      advantage = health[:advantage]  # positive = we're ahead

      bonus = 0
      if advantage > 30
        # Winning big: play safe, don't take risks
        bonus -= 10 if move.respond_to?(:recoilMove?) && move.recoilMove?
        bonus += 10 if AdvancedAI.healing_move?(move.id)
        bonus -= 15 if [:EXPLOSION, :SELFDESTRUCT].include?(move.id)
      elsif advantage < -30
        # Losing big: be aggressive, take risks
        bonus += 10 if move.damagingMove? && move.power >= 80
        bonus -= 10 if AdvancedAI.healing_move?(move.id) && move.id != :WISH
        bonus += 15 if AdvancedAI.setup_move?(move.id)  # Hail Mary setup
      end
      # Neutral: no adjustment
      bonus
    end

    #===========================================================================
    # 6. OPPONENT THREAT PERSISTENCE
    #===========================================================================
    def self.update_threats(battle, user_index)
      state = get_state(battle)
      current_threats = []

      battle.allOtherSideBattlers(user_index).each do |opp|
        next if !opp || opp.fainted?
        threat_level = AdvancedAI.assess_threat(battle, opp, nil, 100) rescue 5.0
        current_threats << { pokemon: get_name(opp), level: threat_level, alive: true }
      end

      # Check for newly eliminated threats
      prev_names = state[:remaining_threats].map { |t| t[:pokemon] }
      curr_names = current_threats.map { |t| t[:pokemon] }

      eliminated = prev_names - curr_names
      eliminated.each do |name|
        old_entry = state[:remaining_threats].find { |t| t[:pokemon] == name }
        if old_entry
          state[:eliminated_threats] << old_entry.merge(alive: false, turn_eliminated: battle.turnCount)
          AdvancedAI.log("[Strategy] Threat eliminated: #{name} (was #{old_entry[:level].round(1)} threat)", "Strategy")
        end
      end

      state[:remaining_threats] = current_threats

      # Return summary
      {
        remaining: current_threats,
        eliminated: state[:eliminated_threats],
        biggest_threat: current_threats.max_by { |t| t[:level] },
        threats_cleared: state[:eliminated_threats].length
      }
    end

    # Mode shift: if opponent's biggest threat is gone, we can play looser
    def self.threat_persistence_bonus(battle, user, move)
      state = get_state(battle)
      eliminated = state[:eliminated_threats] || []
      return 0 if eliminated.empty?

      # If we eliminated a high-threat mon, be more aggressive
      high_threats_killed = eliminated.count { |t| t[:level] >= 7.0 }
      bonus = 0
      if high_threats_killed >= 1
        bonus += 5 if move.damagingMove?  # Play more aggressively
        bonus += 5 if AdvancedAI.setup_move?(move.id)  # Safer to setup
      end
      bonus
    end

    #===========================================================================
    # 7. PROACTIVE SACKING
    #===========================================================================
    def self.should_sack?(battle, user, target)
      return false unless user && target

      # Conditions for a strategic sack:
      # 1. Current mon is low value (wall that can't wall this threat)
      # 2. A high-value teammate needs a free switch
      # 3. Current mon is going to die this turn anyway

      user_hp_pct = user.hp.to_f / user.totalhp
      user_roles = AdvancedAI.detect_roles(user) rescue [:balanced]

      # If we're going to die anyway, check if dying gets a good switch
      likely_dies = false
      incoming = estimate_max_incoming(battle, user, target)
      likely_dies = true if incoming >= user.hp

      if likely_dies
        # Check if a teammate benefits from free switch
        party = battle.pbParty(user.index)
        party.each do |pkmn|
          next if !pkmn || pkmn.fainted? || pkmn.egg?
          next if pkmn == (user.respond_to?(:pokemon) ? user.pokemon : user)
          pkmn_roles = AdvancedAI.detect_roles(pkmn) rescue [:balanced]
          # Sweeper/wallbreaker wanting a free switch = sack is good
          if (pkmn_roles.include?(:sweeper) || pkmn_roles.include?(:wallbreaker)) && pkmn.hp > pkmn.totalhp * 0.7
            return true
          end
        end
      end

      # Sack a low-value mon to get sweeper in
      if user_roles.include?(:wall) || user_roles.include?(:support)
        if user_hp_pct < 0.25  # Low HP wall = expendable
          party = battle.pbParty(user.index)
          party.each do |pkmn|
            next if !pkmn || pkmn.fainted? || pkmn.egg?
            next if pkmn == (user.respond_to?(:pokemon) ? user.pokemon : user)
            pkmn_roles = AdvancedAI.detect_roles(pkmn) rescue [:balanced]
            if pkmn_roles.include?(:sweeper) && pkmn.hp > pkmn.totalhp * 0.8
              return true
            end
          end
        end
      end

      false
    end

    # If sacking, boost the most damaging move (go down swinging)
    def self.sack_bonus(battle, user, move, target)
      return 0 unless should_sack?(battle, user, target)
      bonus = 0
      if move.damagingMove?
        bonus += 20  # Get value before dying
        bonus += 20 if move.power >= 100  # Heavy hit
      end
      # Pivot out instead of dying for free
      if AdvancedAI.pivot_move?(move.id)
        bonus += 40  # Pivot to the sweeper safely
      end
      bonus
    end

    #===========================================================================
    # 8. DEFENSIVE CORE RECOGNITION
    #===========================================================================
    CLASSIC_CORES = {
      fwg: { types: [:FIRE, :WATER, :GRASS], name: "Fire/Water/Grass" },
      steel_fairy_dragon: { types: [:STEEL, :FAIRY, :DRAGON], name: "Steel/Fairy/Dragon" },
      dark_fairy_fighting: { types: [:DARK, :FAIRY, :FIGHTING], name: "Dark/Fairy/Fighting" },
      ground_steel_flying: { types: [:GROUND, :STEEL, :FLYING], name: "Ground/Steel/Flying" },
      ghost_dark_fighting: { types: [:GHOST, :DARK, :FIGHTING], name: "Ghost/Dark/Fighting" },
    }

    def self.identify_defensive_cores(battle, side_index)
      party = battle.pbParty(side_index.even? ? 0 : 1) rescue []
      return [] if party.length < 3

      team_types = []
      party.each do |pkmn|
        next if !pkmn || pkmn.fainted? || pkmn.egg?
        types = get_pokemon_types(pkmn)
        team_types.concat(types)
      end
      team_types.uniq!

      found_cores = []
      CLASSIC_CORES.each do |key, core_data|
        if (core_data[:types] - team_types).empty?
          found_cores << core_data[:name]
        end
      end

      # Log detected cores
      found_cores.each do |core_name|
        AdvancedAI.log("[Strategy] Defensive core detected: #{core_name}", "Strategy")
      end

      found_cores
    end

    # If opponent has a defensive core, adjust targeting
    def self.core_breaking_bonus(battle, user, move, target)
      opp_cores = identify_defensive_cores(battle, user.index.even? ? 1 : 0) rescue []
      return 0 if opp_cores.empty?

      bonus = 0
      # Wallbreaking moves are more valuable against defensive cores
      if move.damagingMove? && move.power >= 90
        bonus += 10  # High-power moves break cores
      end
      if move.id == :KNOCKOFF
        bonus += 10  # Item removal weakens defensive Pokemon
      end
      if move.id == :TAUNT
        bonus += 10  # Stop recovery
      end
      if bonus > 0
        move_name = move.respond_to?(:name) ? move.name : move.id.to_s
        AdvancedAI.log("[Strategy] Core-breaking move bonus: +#{bonus} for #{move_name}", "Strategy")
      end
      bonus
    end

    #===========================================================================
    # COMBINED STRATEGIC SCORE — called from scoring pipeline
    #===========================================================================
    def self.strategic_score(battle, user, move, target, skill = 100)
      return 0 unless skill >= 65
      total = 0

      begin
        # 1. Counter opponent archetype
        total += opponent_win_condition_counter(battle, user, move, target)

        # 2. Win condition shifting
        win_con = AdvancedAI.identify_win_condition(battle, user, skill) rescue nil
        total += update_win_condition(battle, user, win_con)
        total += win_condition_shift_bonus(battle, user, move, win_con)

        # 3. Preservation (coverage gaps)
        total += preservation_bonus(battle, user, move, target)

        # 4. Health advantage
        total += health_advantage_bonus(battle, user, move)

        # 5. Threat persistence
        update_threats(battle, user.index)
        total += threat_persistence_bonus(battle, user, move)

        # 6. Sacking
        total += sack_bonus(battle, user, move, target) if target

        # 7. Core breaking
        total += core_breaking_bonus(battle, user, move, target) if target
      rescue => e
        AdvancedAI.log("[Strategy] Error: #{e.message}", "Strategy")
      end

      total
    end

    #===========================================================================
    # HELPERS
    #===========================================================================
    private

    def self.get_stat(mon, stat)
      case stat
      when :hp      then mon.respond_to?(:totalhp) ? mon.totalhp : (mon.respond_to?(:hp) ? mon.hp : 80)
      when :attack  then mon.respond_to?(:attack)  ? mon.attack  : 80
      when :defense then mon.respond_to?(:defense) ? mon.defense : 80
      when :spatk   then mon.respond_to?(:spatk)   ? mon.spatk   : 80
      when :spdef   then mon.respond_to?(:spdef)   ? mon.spdef   : 80
      when :speed   then mon.respond_to?(:speed)   ? mon.speed   : 80
      else 80
      end
    end

    def self.get_ability(mon)
      if mon.respond_to?(:ability_id)
        mon.ability_id
      elsif mon.respond_to?(:ability)
        mon.ability.is_a?(Symbol) ? mon.ability : (mon.ability.id rescue nil)
      else
        nil
      end
    end

    def self.get_pokemon_types(mon)
      if mon.respond_to?(:pbTypes)
        mon.pbTypes
      elsif mon.respond_to?(:types)
        mon.types
      elsif mon.respond_to?(:type1)
        types = [mon.type1]
        types << mon.type2 if mon.respond_to?(:type2) && mon.type2 && mon.type2 != mon.type1
        types
      else
        [:NORMAL]
      end
    end

    def self.get_name(mon)
      if mon.respond_to?(:name)
        mon.name
      elsif mon.respond_to?(:pokemon)
        mon.pokemon.name rescue "???"
      else
        "???"
      end
    end

    def self.get_known_moves(battle, mon)
      # Try move memory first
      memory = AdvancedAI.get_memory(battle, mon) rescue nil
      if memory && memory[:moves] && !memory[:moves].empty?
        return memory[:moves]
      end
      # Fall back to actual moves (for AI's own Pokemon, or party mons)
      if mon.respond_to?(:moves) && mon.moves
        return mon.moves.map { |m| m.id rescue nil }.compact
      end
      []
    end

    def self.type_effectiveness_against(atk_type, defender_types)
      mult = 1.0
      defender_types.each do |def_type|
        eff = Effectiveness.calculate_one(atk_type, def_type) rescue 1.0
        mult *= eff
      end
      mult
    end

    def self.estimate_max_incoming(battle, user, target)
      return 0 unless target
      max_dmg = 0
      # Estimate from target's known moves
      moves = get_known_moves(battle, target)
      moves.each do |mid|
        move_data = GameData::Move.try_get(mid)
        next if !move_data || move_data.power == 0
        # Very rough estimation
        types = get_pokemon_types(user)
        eff = type_effectiveness_against(move_data.type, types)
        base = move_data.power * eff
        atk_stat = move_data.physicalMove? ? get_stat(target, :attack) : get_stat(target, :spatk)
        def_stat = move_data.physicalMove? ? get_stat(user, :defense) : get_stat(user, :spdef)
        rough = (base * atk_stat.to_f / [def_stat, 1].max * 0.5).to_i
        max_dmg = rough if rough > max_dmg
      end if moves
      max_dmg
    end
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.identify_opponent_archetype(battle, user_index)
    StrategicAwareness.identify_opponent_archetype(battle, user_index)
  end

  def self.identify_coverage_gaps(battle, user_index)
    StrategicAwareness.identify_coverage_gaps(battle, user_index)
  end

  def self.identify_critical_pokemon(battle, user_index)
    StrategicAwareness.identify_critical_pokemon(battle, user_index)
  end

  def self.track_health(battle, user_index)
    StrategicAwareness.track_health(battle, user_index)
  end

  def self.update_threats(battle, user_index)
    StrategicAwareness.update_threats(battle, user_index)
  end

  def self.should_sack?(battle, user, target)
    StrategicAwareness.should_sack?(battle, user, target)
  end

  def self.strategic_score(battle, user, move, target, skill = 100)
    StrategicAwareness.strategic_score(battle, user, move, target, skill)
  end

  def self.identify_defensive_cores(battle, side_index)
    StrategicAwareness.identify_defensive_cores(battle, side_index)
  end
end

#===============================================================================
# Integration in Battle::AI — Wires strategic awareness into scoring pipeline
#===============================================================================
class Battle::AI
  def apply_strategic_awareness(score, move, user, target, skill = 100)
    return score unless move && user
    begin
      real_user = user.respond_to?(:battler) ? user.battler : user
      real_target = target ? (target.respond_to?(:battler) ? target.battler : target) : nil
      bonus = AdvancedAI.strategic_score(@battle, real_user, move, real_target, skill)
      score += bonus if bonus && bonus != 0
    rescue => e
      AdvancedAI.log("[Strategy] Pipeline error: #{e.message}", "Strategy")
    end
    return score
  end
end

# Cleanup hook
class Battle
  alias aai_strategy_cleanup_pbEndOfBattle pbEndOfBattle
  def pbEndOfBattle
    AdvancedAI::StrategicAwareness.cleanup(self)
    aai_strategy_cleanup_pbEndOfBattle
  end
end

AdvancedAI.log("Strategic Awareness System loaded", "Strategy")
AdvancedAI.log("  - Opponent team archetype recognition", "Strategy")
AdvancedAI.log("  - Opponent win condition counter-play", "Strategy")
AdvancedAI.log("  - Dynamic win condition shifting", "Strategy")
AdvancedAI.log("  - Type coverage gap mapping", "Strategy")
AdvancedAI.log("  - Collective health tracking", "Strategy")
AdvancedAI.log("  - Opponent threat persistence", "Strategy")
AdvancedAI.log("  - Proactive sacking logic", "Strategy")
AdvancedAI.log("  - Defensive core recognition", "Strategy")

### FILE: Switch_Intelligence.rb ###
#===============================================================================
# Advanced AI System - Switch Intelligence
# Intelligent Switching Decisions with Type Matchup and Momentum Control
#===============================================================================

class Battle::AI
  #=============================================================================
  # SWITCH ANALYZER - Evaluates switch opportunities
  #=============================================================================
  
  # Helper method to safely get battler index from either Battler or Integer
  def get_battler_index(battler_or_index)
    return battler_or_index.to_i if battler_or_index.is_a?(Integer)
    return battler_or_index.index if battler_or_index.respond_to?(:index)
    battler_or_index.to_i
  end
  
  # Initialize caches
  def initialize_switch_caches
    @type_effectiveness_cache ||= {}
    @setup_move_cache ||= {}
  end
  
  # Analyzes if AI should switch (advanced version)
  def should_switch_advanced?(user, skill = 100)
    return false unless user && !user.fainted?
    return false if user.trappedInBattle?
    return false unless AdvancedAI.feature_enabled?(:core, skill)
    
    # Initialize caches
    initialize_switch_caches
    
    # Initialize switch analysis cache
    @switch_analyzer[user.index] ||= {}
    cache = @switch_analyzer[user.index]
    
    # Calculate Switch Score
    switch_score = calculate_switch_score(user, skill)
    
    # Cache result
    cache[:last_score] = switch_score
    cache[:last_turn] = @battle.turnCount
    
    AdvancedAI.log("Switch score for #{user.pbThis}: #{switch_score}", "Switch")
    
    # Thresholds based on skill
    tier = AdvancedAI.get_ai_tier(skill)
    threshold = AdvancedAI::SWITCH_THRESHOLDS[tier] || 50
    
    return switch_score >= threshold
  end
  
  private # All methods below are private helper methods
  
  # Calculates Switch Score (0-100+)
  def calculate_switch_score(user, skill)
    echoln "  ┌─────────────────────────────────────┐"
    echoln "  │ SWITCH SCORE CALCULATION            │"
    echoln "  └─────────────────────────────────────┘"
    score = 0
    
    # 1. TYPE MATCHUP ANALYSIS (0-40 Points)
    type_score = evaluate_type_disadvantage(user, skill)
    score += type_score
    echoln("  [1/8] Type Disadvantage: +#{type_score}") if type_score > 0
    
    # 2. HP & STATUS ANALYSIS (0-30 Points)
    survival_score = evaluate_survival_concerns(user, skill)
    score += survival_score
    echoln("  [2/8] Survival Concerns: +#{survival_score}") if survival_score > 0
    
    # 3. STAT STAGE ANALYSIS (0-25 Points)
    stat_score = evaluate_stat_stages(user, skill)
    score += stat_score
    echoln("  [3/8] Stat Stage Loss: +#{stat_score}") if stat_score > 0
    
    # 4. BETTER OPTION AVAILABLE (0-35 Points)
    better_score = evaluate_better_options(user, skill)
    score += better_score
    echoln("  [4/8] Better Options: +#{better_score}") if better_score > 0
    
    # 5. MOMENTUM CONTROL (0-20 Points)
    if AdvancedAI.get_setting(:momentum_control) > 0
      momentum_score = evaluate_momentum(user, skill)
      score += momentum_score
      echoln("  [5/8] Momentum Control: +#{momentum_score}") if momentum_score > 0
    end
    
    # 6. PREDICTION BONUS (0-15 Points)
    if skill >= 85
      prediction_score = evaluate_prediction_advantage(user, skill)
      score += prediction_score
      echoln("  [6/8] Prediction: +#{prediction_score}") if prediction_score > 0
    end
    
    # 7. PENALTY: Losing Momentum (-20 Points)
    if user_has_advantage?(user)
      score -= 20
      echoln("  [7/12] Has Advantage (malus): -20")
    end
    
    # 8. BONUS: Pivot Move Available (+25 Points)
    # Prefer using pivot moves (U-turn, Volt Switch, etc.) over hard switches
    pivot_bonus = evaluate_pivot_move_option(user, skill)
    if pivot_bonus > 0
      score -= pivot_bonus  # REDUCE switch score if pivot available (prefer pivot over switch!)
      echoln("  [8/12] Pivot Move Available (reduces hard switch need): -#{pivot_bonus}")
    end
    
    # 9. PENALTY: Wasting Setup (-30 Points)
    if user.stages.values.any? { |stage| stage > 0 }
      total_boosts = user.stages.values.sum
      malus = [total_boosts * 10, 30].min
      score -= malus
      echoln("  [9/12] Wasting Setup +#{total_boosts} (malus): -#{malus}")
    end
    
    # 10. PENALTY: Switching too soon (-40 Points)
    if user.turnCount < 2
      score -= 40
      echoln("  [10/12] Just Switched In (malus): -40")
    end
    
    # 11. PENALTY: No better option (-15 Points)
    # If better_score is 0, it means either no switches exist OR the best switch isn't significantly better
    if better_score <= 0
      score -= 15
      echoln("  [11/12] No Better Option (malus): -15")
    end
    
    # 12. PENALTY: Can KO Opponent (-60 Points)
    if can_ko_opponent?(user)
      score -= 60
      echoln("  [12/12] Can Secure KO (malus): -60")
    end
    
    # 13. PENALTY: Stall Gameplan Active (-25 to -50 Points)
    # Stall mons should NOT switch when their passive damage is ticking
    if AdvancedAI.has_stall_moveset?(user)
      stall_penalty = 0
      @battle.allOtherSideBattlers(user.index).each do |target|
        next unless target && !target.fainted?
        leech_seed_val = (target.effects[PBEffects::LeechSeed] rescue -1)
        stall_penalty += 15 if target.poisoned?
        stall_penalty += 20 if target.status == :POISON && target.statusCount > 0  # Toxic
        stall_penalty += 10 if target.burned?
        stall_penalty += 15 if leech_seed_val.is_a?(Numeric) && leech_seed_val >= 0
      end
      if stall_penalty > 0
        stall_penalty = [stall_penalty, 50].min
        score -= stall_penalty
        echoln("  [13/13] Stall Gameplan Active (malus): -#{stall_penalty}")
      end
      
      # Additional: stall mons with recovery at decent HP should stay
      hp_percent = user.hp.to_f / user.totalhp
      has_recovery = user.moves.any? do |m|
        next false unless m
        AdvancedAI.healing_move?(m.id)
      end
      if has_recovery && hp_percent > 0.35
        score -= 20
        echoln("  [13/13] Stall Mon w/Recovery (malus): -20")
      end
    end
    
    echoln "  ─────────────────────────────────────"
    echoln "  TOTAL SWITCH SCORE: #{score}"
    
    # Show Threshold
    tier = AdvancedAI.get_ai_tier(skill)
    threshold = AdvancedAI::SWITCH_THRESHOLDS[tier] || 50
    echoln "  Threshold (#{tier}): #{threshold}"
    echoln "  Decision: #{score >= threshold ? 'SWITCH' : 'STAY'}"
    
    # === USER-FRIENDLY SWITCH SUMMARY ===
    # Produces the [Switch] lines matching the showcase debug output
    if type_score > 0
      # Find which opponent type is threatening
      my_types = get_real_types(user)
      @battle.allOtherSideBattlers(user.index).each do |target|
        next unless target && !target.fainted?
        target.moves.each do |m|
          next unless m && m.damagingMove? && m.type
          type_mod = Effectiveness.calculate(m.type, *my_types)
          if Effectiveness.super_effective?(type_mod)
            echoln "[Switch] Type disadvantage detected: #{m.type} vs #{user.name}"
            break
          end
        end
      end
    end
    if survival_score > 0
      # Show estimated incoming damage
      @battle.allOtherSideBattlers(user.index).each do |target|
        next unless target && !target.fainted?
        max_dmg_pct = 0
        best_move_name = nil
        target.moves.each do |m|
          next unless m && m.damagingMove?
          dmg = estimate_incoming_damage_percent(user, m, target) rescue 0
          if dmg > max_dmg_pct
            max_dmg_pct = dmg
            best_move_name = m.name
          end
        end
        if max_dmg_pct > 0 && best_move_name
          echoln "[Switch] Survival concern: incoming #{best_move_name} ~#{(max_dmg_pct * 100).to_i}%% estimated damage"
        end
      end
    end
    
    return score
  end
  
  #=============================================================================
  # EVALUATION METHODS
  #=============================================================================
  
  # 1. Type Disadvantage Evaluation
  def evaluate_type_disadvantage(user, skill)
    score = 0
    
    # Use real types (ignoring Illusion) for defensive calculation
    my_types = get_real_types(user)
    
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      echoln("    → Analyzing vs #{target.name} [#{target.pbTypes(true).join('/')}]")
      
      # Offensive Threat (Opponent can hit User super effectively)
      target.moves.each do |move|
        next unless move
        next unless move.damagingMove?  # Skip status moves like Hypnosis
        next unless move.type # Fix ArgumentError
        type_mod = Effectiveness.calculate(move.type, *my_types)
        if Effectiveness.super_effective?(type_mod)
          score += 20  # Super effective move!
          echoln("      • #{move.name} [#{move.type}] → SUPER EFFECTIVE! (+20)")
        end
      end
      
      # Defensive Weakness (User cannot hit Opponent effectively)
      user_offensive = user.moves.map do |move|
        next 0 unless move
        next 0 unless move.type # Fix ArgumentError
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        Effectiveness.not_very_effective?(type_mod) ? 1.0 : 0.0
      end.count { |x| x > 0 }
      
      score += 10 if user_offensive >= 3  # Most moves not very effective
      
      # STAB Disadvantage
      target.moves.each do |move|
        next unless move
        next unless move.damagingMove?  # Skip status moves
        next unless move.type # Fix ArgumentError
        if target.pbHasType?(move.type)  # STAB
          type_mod = Effectiveness.calculate(move.type, *my_types)
          score += 15 if Effectiveness.super_effective?(type_mod)
        end
      end
    end
    
    return [score, 40].min  # Cap at 40
  end
  
  # 2. Survival Concerns
  def evaluate_survival_concerns(user, skill)
    score = 0
    hp_percent = user.hp.to_f / user.totalhp
    
    # Low HP
    if hp_percent < 0.25
      score += 30
    elsif hp_percent < 0.40
      score += 20
    elsif hp_percent < 0.55
      score += 10
    end
    
    # No Recovery Options
    has_recovery = user.moves.any? do |m|
      next false unless m
      move_data = GameData::Move.try_get(m.id)
      next false unless move_data
      move_data.function_code.start_with?("HealUser") || 
        ["Roost", "Synthesis", "MorningSun", "Moonlight", "Recover", "Softboiled", "Wish", "Rest"].include?(move_data.real_name)
    end
    score += 10 if !has_recovery && hp_percent < 0.5
    
    # Bad Status
    if user.status != :NONE
      case user.status
      when :POISON, :BURN
        score += 15
      when :TOXIC
        score += 20
      when :SLEEP, :FROZEN
        score += 10
      when :PARALYSIS
        score += 5
      end
    end
    
    # OHKO Danger
    my_types = get_real_types(user)
    
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      # Faster Opponent with high Attack
      if target.pbSpeed > user.pbSpeed
        target.moves.each do |move|
          next unless move && move.damagingMove?
          next unless move.type
          
          type_mod = Effectiveness.calculate(move.type, *my_types)
          
          # Rough Damage Estimate
          if Effectiveness.super_effective?(type_mod)
            # Use safer base damage retrieval for v21.1 compatibility
            base_dmg = move.power
            estimated_damage = (target.attack * base_dmg * 2.0) / [user.defense, 1].max
            score += 15 if estimated_damage >= user.hp
          end
        end
      end
    end
    
    return [score, 30].min
  end
  
  # 3. Stat Stage Analysis
  def evaluate_stat_stages(user, skill)
    score = 0
    
    # Negative Stat Stages
    negative_stages = user.stages.values.count { |stage| stage < 0 }
    score += negative_stages * 8
    
    # Critical Drops
    score += 10 if user.stages[:ATTACK] <= -2 && user.attack > user.spatk
    score += 10 if user.stages[:SPECIAL_ATTACK] <= -2 && user.spatk > user.attack
    score += 12 if user.stages[:SPEED] <= -2
    
    # Opponent with many Boosts
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      positive_stages = target.stages.values.count { |stage| stage > 0 }
      score += 5 if positive_stages >= 2
      score += 10 if positive_stages >= 4
    end
    
    return [score, 25].min
  end
  
  # 4. Better Available Options
  def evaluate_better_options(user, skill)
    score = 0
    
    party = @battle.pbParty(user.index)
    available_switches = party.select.with_index do |pkmn, i|
      pkmn && !pkmn.fainted? && !pkmn.egg? && !@battle.pbFindBattler(i, user.index)
    end
    
    # Handle ReserveLastPokemon
    # Robust trainer retrieval
    ai_trainer = @trainer
    if !ai_trainer
      # Try to get trainer from battler
      ai_trainer = @battle.pbGetOwnerFromBattlerIndex(user.index)
    end

    if AdvancedAI::RESPECT_RESERVE_LAST_POKEMON && ai_trainer && ai_trainer.has_skill_flag?("ReserveLastPokemon")
      reserved_idx = party.length - 1
      echoln "[AAI DEBUG] ReserveLastPokemon Active! Reserved Index: #{reserved_idx}"
      
      # Only filter if we have more than 1 option (never restrict the last available mon)
      if available_switches.length > 1
        available_switches.reject! do |pkmn| 
          is_reserved = (party.index(pkmn) == reserved_idx)
          echoln "[AAI DEBUG] Filtering #{pkmn.name} (Index #{party.index(pkmn)})? #{is_reserved}" if is_reserved
          is_reserved
        end
      end
    else
      echoln "[AAI DEBUG] ReserveLastPokemon skipped. Enabled: #{AdvancedAI::RESPECT_RESERVE_LAST_POKEMON}, Trainer Found: #{!!ai_trainer}"
      if ai_trainer
         echoln "[AAI DEBUG] Has Flag? #{ai_trainer.has_skill_flag?("ReserveLastPokemon")}"
      end
    end
    
    return 0 if available_switches.empty?
    
    # Find best alternative
    best_matchup_score = -100
    best_switch = nil
    
    available_switches.each do |switch_mon|
      matchup = evaluate_switch_matchup(switch_mon, user)
      if matchup > best_matchup_score
        best_matchup_score = matchup
        best_switch = switch_mon
      end
    end
    
    return 0 unless best_switch
    
    # Calculate current pokemon's matchup for comparison
    # Pass user.pokemon (real Pokemon object) to evaluate current type effectiveness IGNORING Illusion
    current_matchup_score = evaluate_switch_matchup(user.pokemon, user)
    
    # Calculate improvement
    improvement = best_matchup_score - current_matchup_score
    
    echoln("[AAI Switch] Current: #{current_matchup_score} vs Best: #{best_matchup_score} (Diff: #{improvement})")
    
    # Bonus only if SIGNIFICANT improvement
    if improvement > 25
      score += 35
      echoln("[AAI Switch] Best Option: #{best_switch.name} (Matchup +#{best_matchup_score}, Improvement +#{improvement})")
    elsif improvement > 15
      score += 25
      echoln("[AAI Switch] Good Option: #{best_switch.name} (Matchup +#{best_matchup_score}, Improvement +#{improvement})")
    elsif improvement > 5 && best_matchup_score > 40
      # Only switch for small improvement if the matchup is absolutely excellent (Score > 40)
      score += 15
      echoln("[AAI Switch] Solid Option: #{best_switch.name} (Matchup +#{best_matchup_score}, Improvement +#{improvement})")
    end
    
    return score
  end
  
  # 5. Momentum Control
  def evaluate_momentum(user, skill)
    score = 0
    
    # Force Momentum Shift if behind
    alive_user = @battle.pbParty(user.index).count { |p| p && !p.fainted? }
    alive_enemy = @battle.allOtherSideBattlers(user.index).count { |b| 
      b && !b.fainted? && @battle.pbParty(b.index).count { |p| p && !p.fainted? } > 0
    }
    
    if alive_user < alive_enemy
      score += 10  # Attempt Momentum Shift
    end
    
    # Predict Switch if opponent wants to setup
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      # Opponent has Setup Moves (check function codes)
      has_setup = target.moves.any? do |m|
        next false unless m && m.is_a?(Battle::Move) && m.statusMove?
        move_data = GameData::Move.try_get(m.id)
        next false unless move_data
        # Setup moves have function codes like RaiseUserAttack2, RaiseMultipleStats, etc.
        move_data.function_code.to_s.include?("RaiseUser") || move_data.function_code.to_s.include?("RaiseMulti")
      end
      score += 15 if has_setup && user_has_type_disadvantage?(user, target)
    end
    
    return [score, 20].min
  end
  
  # 6. Prediction Advantage (Skill 85+)
  def evaluate_prediction_advantage(user, skill)
    return 0 unless skill >= 85
    score = 0
    
    # If opponent likely switches, stay in
    # If opponent likely setups, switch out
    
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      # Analyze last moves
      if @move_memory[target.index]
        last_moves = @move_memory[target.index][:moves] || []
        
        # Pattern: Repeated Setup Moves
        setup_count = last_moves.count do |m|
          next false unless m
          move_data = GameData::Move.try_get(m)
          next false unless move_data
          move_data.function_code.to_s.include?("RaiseUser") || move_data.function_code.to_s.include?("RaiseMulti")
        end
        score += 10 if setup_count >= 2
        
        # Pattern: Predict Opponent Switch (if low HP)
        if target.hp < target.totalhp * 0.35
          score -= 15  # Stay in, opponent likely switches
        end
      end
    end
    
    return [score, 15].min
  end
  
  #=============================================================================
  # FIND BEST SWITCH OPTION
  #=============================================================================
  
  # Detailed Switch Candidate Evaluation
  def evaluate_switch_candidate_detailed(pkmn, current_user, skill)
    score = 50  # Base score
    
    # 1. TYPE MATCHUP (0-50 Points)
    score += evaluate_switch_matchup(pkmn, current_user)
    
    # 2. HP & STATUS (0-20 Points)
    hp_percent = pkmn.hp.to_f / pkmn.totalhp
    score += (hp_percent * 20).to_i
    score -= 20 if pkmn.status != :NONE
    
    # 3. SPEED (0-15 Points)
    # Note: pkmn is Pokemon (not Battler), need to calculate speed properly
    @battle.allOtherSideBattlers(get_battler_index(current_user)).each do |target|
      next unless target && !target.fainted?
      # Use base speed stat for Pokemon comparison (pkmn doesn't have pbSpeed)
      pkmn_speed = pkmn.speed
      target_speed = target.speed  # Use base speed for fair comparison
      score += 15 if pkmn_speed > target_speed
    end
    
    # 4. ROLE ANALYSIS (0-25 Points)
    role_bonus = evaluate_switch_role(pkmn, current_user, skill)
    score += role_bonus
    
    # 4b. ROLE COUNTER-PICK (0-25 Points)
    counter_bonus = role_counter_pick_bonus(pkmn, current_user, skill)
    score += counter_bonus
    
    # 5. ENTRY HAZARDS RESISTANCE (0-15 Points)
    if @battle.pbOwnedByPlayer?(get_battler_index(current_user))
      opponent_side = @battle.sides[1]
    else
      opponent_side = @battle.sides[0]
    end
    
    # Stealth Rock Resistance
    if opponent_side.effects[PBEffects::StealthRock]
      effectiveness = Effectiveness.calculate(:ROCK, *pkmn.types)
      if Effectiveness.ineffective?(effectiveness)
        score += 15
      elsif Effectiveness.not_very_effective?(effectiveness)
        score += 10
      elsif Effectiveness.super_effective?(effectiveness)
        score -= 15
      end
    end
    
    # Spikes
    if opponent_side.effects[PBEffects::Spikes] > 0
      # Safe ability check with nil guard
      has_levitate = false
      begin
        has_levitate = pkmn.hasAbility?(:LEVITATE) if pkmn.respond_to?(:hasAbility?)
      rescue
        has_levitate = false
      end
      score += 10 if pkmn.hasType?(:FLYING) || has_levitate
    end
    
    # 6. ABILITY SYNERGY (0-20 Points)
    # Use ability_id instead of ability to avoid Gen9 Pack recursion
    ability_id = nil
    begin
      ability_id = pkmn.ability_id if pkmn.respond_to?(:ability_id)
    rescue StandardError => e
      AdvancedAI.log("Error getting ability_id: #{e.message}", "Switch")
    end
    
    if ability_id
      # Intimidate on Switch-In
      score += 20 if ability_id == :INTIMIDATE
      
      # Weather/Terrain abilities
      score += 15 if [:DRIZZLE, :DROUGHT, :SANDSTREAM, :SNOWWARNING].include?(ability_id)
      
      # Defensive abilities
      score += 10 if [:REGENERATOR, :NATURALCURE, :IMMUNITY].include?(ability_id)
    end
    
    return score
  end
  
  # Matchup Evaluation for Switch
  def evaluate_switch_matchup(switch_mon, current_user)
    score = 0
    
    # Validate types
    # Validate types - normalize input to types array
    switch_types = []
    
    if switch_mon.is_a?(Battle::Battler)
       # Use real types helper if it's a battler (Illusion bypass)
       switch_types = get_real_types(switch_mon)
    elsif switch_mon.respond_to?(:types)
       # Pokemon object
       switch_types = switch_mon.types.compact
    end
    
    return 0 if switch_types.empty?
    
    @battle.allOtherSideBattlers(get_battler_index(current_user)).each do |target|
      next unless target && !target.fainted?
      
      # Offensive Type Advantage
      switch_mon_types = switch_types.uniq
      return 0 if switch_mon_types.empty?
      
      target_types = target.pbTypes(true).compact
      next if target_types.empty?
      
      switch_mon_types.each do |type|
        next unless type  # Skip nil
        effectiveness = Effectiveness.calculate(type, *target_types)
        if Effectiveness.super_effective?(effectiveness)
          score += 20
        elsif Effectiveness.not_very_effective?(effectiveness)
          score -= 10
        elsif Effectiveness.ineffective?(effectiveness)
          score -= 40  # STAB ineffective (Immunity)
        end
      end
      
      # Defensive Type Advantage
      target.moves.each do |move|
        next unless move && move.damagingMove?
        next unless move.type  # Skip nil types
        # Use duck-typing for switch_mon (could be Battler or Pokemon)
        switch_types = switch_mon.is_a?(Battle::Battler) ? 
          switch_mon.pbTypes(true).compact :
          switch_mon.types.compact
        next if switch_types.empty?
        effectiveness = Effectiveness.calculate(move.type, *switch_types)
        if Effectiveness.ineffective?(effectiveness)
          score += 40  # IMMUNITY is extremely valuable!
        elsif Effectiveness.not_very_effective?(effectiveness)
          score += 15  # Resistance is good
        elsif Effectiveness.super_effective?(effectiveness)
          score -= 25  # Weakness is bad
        end
      end
    end
    
    return score
  end
  
  # Role-based Switch Evaluation
  def evaluate_switch_role(pkmn, current_user, skill)
    return 0 unless skill >= 55
    score = 0
    
    # Determine roles using the full 9-role detection system
    current_role = determine_pokemon_role(current_user)
    switch_role = determine_pokemon_role_from_stats(pkmn)
    
    # Also check the opponent's role for smart counter-switching
    opponent = @battle.allOtherSideBattlers(get_battler_index(current_user)).find { |b| b && !b.fainted? }
    opponent_role = opponent ? determine_pokemon_role(opponent) : :balanced
    
    # === Complementary Role Preferences ===
    # Switch to something that covers the current mon's weaknesses
    case current_role
    when :sweeper
      score += 15 if [:wall, :stall, :tank].include?(switch_role)
    when :wall, :stall
      score += 15 if [:sweeper, :wallbreaker].include?(switch_role)
    when :tank
      score += 15 if [:wallbreaker, :sweeper].include?(switch_role)
    when :support
      score += 20 if [:sweeper, :wallbreaker].include?(switch_role)  # Support done → bring attacker
    when :wallbreaker
      score += 15 if [:wall, :stall, :tank].include?(switch_role)
    when :pivot
      score += 10 if [:sweeper, :wallbreaker, :tank].include?(switch_role)
    when :lead
      score += 15 if [:sweeper, :wallbreaker, :pivot].include?(switch_role)  # Lead done → bring offense
    end
    
    # === Counter-Pick the Opponent ===
    # Bring in something that beats what the opponent is doing
    case opponent_role
    when :sweeper
      score += 20 if [:wall, :stall].include?(switch_role)  # Wall the sweeper
    when :wall, :stall
      score += 20 if switch_role == :wallbreaker  # Break the wall
    when :wallbreaker
      score += 15 if switch_role == :sweeper  # Outspeed the breaker
    when :support
      score += 15 if [:sweeper, :lead].include?(switch_role)  # Pressure before setup completes
    when :tank
      score += 15 if switch_role == :wallbreaker  # Break bulky offense
    end
    
    return score
  end
  
  # Find best switch Pokemon (public for Core.rb integration)
  # forced_switch: true when terrible_moves triggered the switch (not voluntary)
  def find_best_switch_advanced(user, skill, forced_switch = false)
    echoln "  ┌─────────────────────────────────────┐"
    echoln "  │ FINDING BEST REPLACEMENT            │"
    echoln "  └─────────────────────────────────────┘"
    
    party = @battle.pbParty(user.index)
    available_switches = []
    
    reserved_idx = -1
    if AdvancedAI::RESPECT_RESERVE_LAST_POKEMON && @trainer && @trainer.has_skill_flag?("ReserveLastPokemon")
      reserved_idx = party.length - 1
    end
    
    party.each_with_index do |pkmn, i|
      next unless pkmn && !pkmn.fainted? && !pkmn.egg?
      next if @battle.pbFindBattler(i, user.index) # Already in battle
      next unless @battle.pbCanSwitchIn?(user.index, i)
      
      matchup_score = evaluate_switch_matchup_detailed(pkmn, user)
      available_switches.push([pkmn, matchup_score, i])
      
      echoln "  • #{pkmn.name}: Matchup = #{matchup_score}"
    end
    
    # Filter reserved Pokemon
    # 1. If we have multiple options, always save the Ace
    # 2. If we only have the Ace left:
    #    - If VOLUNTARY switch (user not fainted AND not forced), save the Ace
    #    - If FORCED switch (user fainted OR terrible_moves), we must use the Ace
    
    is_voluntary_switch = user && !user.fainted? && !forced_switch
    
    if reserved_idx >= 0
      should_filter = false
      
      if available_switches.length > 1
        should_filter = true
      elsif is_voluntary_switch && available_switches.length == 1
        # Strict Mode: Don't bring out Ace to save a dying mon
        should_filter = true
        echoln "  [AAI] ReserveLastPokemon: Blocking voluntary switch to Ace"
      end
      
      if should_filter
        available_switches.reject! { |item| item[2] == reserved_idx }
        if available_switches.empty?
          echoln "  [AAI] Reserved Pokemon at index #{reserved_idx} excluded (No other options)"
        else
          echoln "  [AAI] Reserved Pokemon at index #{reserved_idx} excluded from options"
        end
      end
    end
    
    if available_switches.empty?
      echoln "  >>> No valid switches available!"
      return nil
    end
    
    # Sort by matchup score (highest first)
    available_switches.sort_by! { |_, score, _| -score }
    best_pkmn, best_score, best_idx = available_switches.first
    
    echoln "  ─────────────────────────────────────"
    echoln "  ✅ BEST OPTION: #{best_pkmn.name}"
    echoln "  Matchup Score: #{best_score}"
    
    # === [Switch] BEST SWITCH SUMMARY ===
    echoln "[Switch] Best switch: #{best_pkmn.name} (Score: #{best_score})"
    
    # Sub-bullet: Type advantage vs opponents
    switch_types = best_pkmn.types.compact
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      target_types = target.pbTypes(true).compact rescue []
      next if target_types.empty?
      
      # Check for immunities and resistances
      switch_types.each do |st|
        next unless st
        eff = Effectiveness.calculate(st, *target_types) rescue nil
        next unless eff
        if Effectiveness.ineffective?(eff)
          echoln "  - Type advantage: #{target_types.first} immune (#{st})"
        end
      end
    end
    
    # Sub-bullet: Role synergy
    switch_roles = AdvancedAI.detect_roles(best_pkmn) rescue [:balanced]
    user_roles = AdvancedAI.detect_roles(user) rescue [:balanced]
    if switch_roles.any? && user_roles.any?
      echoln "  - Role synergy: #{user_roles.first} → #{switch_roles.first}"
    end
    
    # Sub-bullet: Entry hazard cost
    hazard_dmg = calculate_entry_hazard_damage(best_pkmn, user) rescue 0
    if hazard_dmg > 0
      hazard_source = []
      side = @battle.sides[user.index % 2]
      hazard_source << "Stealth Rock" if side.effects[PBEffects::StealthRock]
      hazard_source << "Spikes" if side.effects[PBEffects::Spikes] > 0
      hazard_source << "Toxic Spikes" if side.effects[PBEffects::ToxicSpikes] > 0
      hazard_source << "Sticky Web" if side.effects[PBEffects::StickyWeb]
      source_str = hazard_source.empty? ? "hazards" : hazard_source.join(", ")
      echoln "  - Entry hazard cost: #{(hazard_dmg * 100).round(0)}%% (#{source_str})"
    end
    
    # Return party index directly (Core.rb expects integer)
    return best_idx
  end
  
  private
  
  # Constants for damage calculation
  DAMAGE_RANDOM_MULTIPLIER = 0.925  # Average of random damage roll (85-100%)
  STAB_MULTIPLIER = 1.5
  BURN_PHYSICAL_MODIFIER = 0.5
  WEATHER_BOOST = 1.5
  WEATHER_NERF = 0.5
  
  # Calculate estimated incoming damage from a move
  # Returns damage as a percentage of switch_pkmn's total HP (0.0 to 1.0+)
  def calculate_incoming_damage(switch_pkmn, move, attacker)
    return 0.0 unless switch_pkmn && move && attacker
    return 0.0 unless move.damagingMove?
    return 0.0 unless move.power && move.power > 0
    
    # Get move type (handle Move objects vs data)
    move_type = move.pbCalcType(attacker) rescue move.type
    return 0.0 unless move_type
    
    # Get types for effectiveness calculation (switch_pkmn is party Pokemon)
    switch_types = switch_pkmn.types.compact
    return 0.0 if switch_types.empty?
    
    # === ABILITY CHECKS ===
    # Check defender abilities that grant immunities
    defender_ability = switch_pkmn.ability_id
    if defender_ability
      # Levitate makes Ground immune
      return 0.0 if defender_ability == :LEVITATE && move_type == :GROUND
      # Volt Absorb, Lightning Rod, Motor Drive - Electric immunity
      return 0.0 if [:VOLTABSORB, :LIGHTNINGROD, :MOTORDRIVE].include?(defender_ability) && move_type == :ELECTRIC
      # Water Absorb, Storm Drain, Dry Skin - Water immunity
      return 0.0 if [:WATERABSORB, :STORMDRAIN, :DRYSKIN].include?(defender_ability) && move_type == :WATER
      # Flash Fire - Fire immunity
      return 0.0 if defender_ability == :FLASHFIRE && move_type == :FIRE
      # Sap Sipper - Grass immunity
      return 0.0 if defender_ability == :SAPSIPPER && move_type == :GRASS
      # Thick Fat - Fire/Ice resistance
      # Wonder Guard - only super effective hits
    end
    
    # Type effectiveness (Effectiveness.calculate returns multiplier like 8=2x, 4=1x, 2=0.5x)
    effectiveness = Effectiveness.calculate(move_type, *switch_types)
    return 0.0 if Effectiveness.ineffective?(effectiveness)
    
    # Wonder Guard - only allows super effective moves
    if defender_ability == :WONDERGUARD
      return 0.0 unless Effectiveness.super_effective?(effectiveness)
    end
    
    # Convert Essentials effectiveness value to actual multiplier (divide by NORMAL_EFFECTIVE)
    effectiveness_multiplier = effectiveness.to_f / Effectiveness::NORMAL_EFFECTIVE_MULTIPLIER
    
    # Thick Fat halves Fire/Ice damage
    if defender_ability == :THICKFAT && [:FIRE, :ICE].include?(move_type)
      effectiveness_multiplier *= 0.5
    end
    
    # Filter reduces super effective damage
    if defender_ability == :FILTER && Effectiveness.super_effective?(effectiveness)
      effectiveness_multiplier *= 0.75
    end
    
    # Solid Rock reduces super effective damage
    if defender_ability == :SOLIDROCK && Effectiveness.super_effective?(effectiveness)
      effectiveness_multiplier *= 0.75
    end
    
    # === STAB CALCULATION ===
    stab = attacker.pbHasType?(move_type) ? STAB_MULTIPLIER : 1.0
    
    # Adaptability boosts STAB to 2.0
    attacker_ability = attacker.ability_id rescue nil
    if attacker_ability == :ADAPTABILITY && stab > 1.0
      stab = 2.0
    end
    
    # === STAT CALCULATION ===
    # Select correct offensive/defensive stats based on move category
    if move.physicalMove?
      atk_stat = attacker.attack
      def_stat = switch_pkmn.defense
      
      # === STAT STAGE MODIFIERS (Attacker) ===
      # Attacker is Battle::Battler, has stat stages
      atk_stage = attacker.stages[:ATTACK] || 0
      if atk_stage != 0
        stage_multiplier = [2.0, 2.0/1.5, 2.0/2.0, 2.0/2.5, 2.0/3.0, 2.0/3.5, 2.0/4.0,
                            1.0,
                            4.0/2.0, 3.5/2.0, 3.0/2.0, 2.5/2.0, 2.0/2.0, 1.5/2.0][atk_stage + 6]
        atk_stat = (atk_stat * stage_multiplier).floor
      end
      
      # Guts boosts Attack when statused (attacker is Battler, has status)
      if attacker_ability == :GUTS && attacker.status != :NONE
        atk_stat = (atk_stat * 1.5).floor
      end
      
      # Huge Power / Pure Power doubles Attack
      if [:HUGEPOWER, :PUREPOWER].include?(attacker_ability)
        atk_stat = (atk_stat * 2).floor
      end
      
    elsif move.specialMove?
      atk_stat = attacker.spatk
      def_stat = switch_pkmn.spdef
      
      # === STAT STAGE MODIFIERS (Attacker) ===
      spatk_stage = attacker.stages[:SPECIAL_ATTACK] || 0
      if spatk_stage != 0
        stage_multiplier = [2.0, 2.0/1.5, 2.0/2.0, 2.0/2.5, 2.0/3.0, 2.0/3.5, 2.0/4.0,
                            1.0,
                            4.0/2.0, 3.5/2.0, 3.0/2.0, 2.5/2.0, 2.0/2.0, 1.5/2.0][spatk_stage + 6]
        atk_stat = (atk_stat * stage_multiplier).floor
      end
      
      # Solar Power boosts Sp.Atk in sun
      if attacker_ability == :SOLARPOWER && @battle.pbWeather == :Sun
        atk_stat = (atk_stat * 1.5).floor
      end
      
    else
      return 0.0  # Status move or unknown category
    end
    
    # === DEFENDER STAT STAGES (switch_pkmn is party Pokemon, no stages yet) ===
    # Note: Can't apply defender stat stages for party Pokemon (not in battle yet)
    # This is intentional - we're predicting damage on switch-in before stat changes
    
    # Marvel Scale boosts Defense when statused (switch_pkmn is party Pokemon)
    if move.physicalMove? && defender_ability == :MARVELSCALE && switch_pkmn.status != :NONE
      def_stat = (def_stat * 1.5).floor
    end
    
    # === ITEM MODIFIERS ===
    # Attacker items
    attacker_item = attacker.item_id rescue nil
    if attacker_item
      # Choice Band boosts physical moves
      if move.physicalMove? && attacker_item == :CHOICEBAND
        atk_stat = (atk_stat * 1.5).floor
      end
      # Choice Specs boosts special moves
      if move.specialMove? && attacker_item == :CHOICESPECS
        atk_stat = (atk_stat * 1.5).floor
      end
      # Life Orb boosts all moves
      if [:LIFEORB].include?(attacker_item)
        atk_stat = (atk_stat * 1.3).floor
      end
    end
    
    # Defender items
    defender_item = switch_pkmn.item_id
    if defender_item
      # Assault Vest boosts Sp.Def
      if move.specialMove? && defender_item == :ASSAULTVEST
        def_stat = (def_stat * 1.5).floor
      end
      # Eviolite boosts both defenses for non-fully evolved
      if defender_item == :EVIOLITE && !switch_pkmn.species_data.get_evolutions(true).empty?
        def_stat = (def_stat * 1.5).floor
      end
    end
    
    # === WEATHER MODIFIERS ===
    weather = @battle.pbWeather rescue nil
    if weather
      # Sun boosts Fire, nerfs Water
      if weather == :Sun
        effectiveness_multiplier *= WEATHER_BOOST if move_type == :FIRE
        effectiveness_multiplier *= WEATHER_NERF if move_type == :WATER
      end
      # Rain boosts Water, nerfs Fire
      if weather == :Rain
        effectiveness_multiplier *= WEATHER_BOOST if move_type == :WATER
        effectiveness_multiplier *= WEATHER_NERF if move_type == :FIRE
      end
      # Sandstorm boosts Rock Sp.Def (already in stats for Battler, not party Pokemon)
    end
    
    # === TERRAIN MODIFIERS ===
    terrain = @battle.field.terrain rescue nil
    if terrain
      # Electric Terrain boosts Electric moves by 1.3x
      if terrain == :Electric && move_type == :ELECTRIC
        effectiveness_multiplier *= 1.3
      end
      # Grassy Terrain boosts Grass moves by 1.3x
      if terrain == :Grassy && move_type == :GRASS
        effectiveness_multiplier *= 1.3
      end
      # Psychic Terrain boosts Psychic moves by 1.3x
      if terrain == :Psychic && move_type == :PSYCHIC
        effectiveness_multiplier *= 1.3
      end
      # Misty Terrain reduces Dragon moves by 0.5x
      if terrain == :Misty && move_type == :DRAGON
        effectiveness_multiplier *= 0.5
      end
      
      # Grassy Terrain reduces Earthquake/Bulldoze/Magnitude damage
      if terrain == :Grassy && [:EARTHQUAKE, :BULLDOZE, :MAGNITUDE].include?(move.id)
        effectiveness_multiplier *= 0.5
      end
    end
    
    # === BURN MODIFIER ===
    # Burn halves physical damage (unless attacker has Guts which we already handled)
    if move.physicalMove? && attacker.status == :BURN && attacker_ability != :GUTS
      atk_stat = (atk_stat * BURN_PHYSICAL_MODIFIER).floor
    end
    
    # Prevent division by zero
    def_stat = [def_stat, 1].max
    
    # === DAMAGE FORMULA ===
    # Pokemon damage formula: ((2*Level/5 + 2) * Power * Atk/Def / 50 + 2) * Modifiers
    level = attacker.level
    base_damage = ((2.0 * level / 5 + 2) * move.power * atk_stat / def_stat / 50 + 2)
    
    # === MULTI-HIT MOVE ADJUSTMENT ===
    # Multi-hit moves hit multiple times (2-5 or fixed)
    if move.multiHitMove?
      # Skill Link: Always 5 hits
      if attacker_ability == :SKILLLINK
        base_damage *= 5
      # Loaded Dice: 4-5 hits (average 4.5)
      elsif attacker.hasActiveItem?(:LOADEDDICE)
        base_damage *= 4.5
      # Parental Bond: 2 hits (second is 25%)
      elsif attacker_ability == :PARENTALBOND
        base_damage *= 1.25
      # Population Bomb: 10 hits (each 20 BP = 200 total)
      elsif move.id == :POPULATIONBOMB
        if attacker_ability == :SKILLLINK
          base_damage = ((2.0 * level / 5 + 2) * 200 * atk_stat / def_stat / 50 + 2)  # 10 guaranteed hits
        else
          base_damage = ((2.0 * level / 5 + 2) * 140 * atk_stat / def_stat / 50 + 2)  # Average 7 hits
        end
      # Triple Kick: 3 hits (10, 20, 30 BP = 60 total)
      elsif move.id == :TRIPLEKICK
        base_damage = ((2.0 * level / 5 + 2) * 60 * atk_stat / def_stat / 50 + 2)
      # Triple Axel: 3 hits (20, 40, 60 BP = 120 total)
      elsif move.id == :TRIPLEAXEL
        base_damage = ((2.0 * level / 5 + 2) * 120 * atk_stat / def_stat / 50 + 2)
      # Standard multi-hit: 2-5 hits (average 3)
      else
        base_damage *= 3
      end
    end
    
    # === CRITICAL HIT ADJUSTMENT ===
    # Factor in crit rates for damage expectation
    if move.damagingMove?
      crit_stage = 0
      
      # High crit moves (Slash, Stone Edge, etc.)
      high_crit_moves = [:AEROBLAST, :AIRCUTTER, :ATTACKORDER, :BLAZEKICK, :CRABHAMMER,
                         :CROSSCHOP, :CROSSPOISON, :DRILLRUN, :KARATECHOP, :LEAFBLADE,
                         :NIGHTSLASH, :POISONTAIL, :PSYCHOCUT, :RAZORLEAF, :RAZORWIND,
                         :SHADOWCLAW, :SLASH, :SPACIALREND, :STONEEDGE]
      crit_stage += 1 if high_crit_moves.include?(move.id)
      
      # Always crit moves (Frost Breath, Storm Throw, etc.)
      always_crit_moves = [:FROSTBREATH, :STORMTHROW, :WICKEDBLOW, :SURGINGSTRIKES, :FLOWERTRICK]
      if always_crit_moves.include?(move.id)
        crit_stage = 99  # Guaranteed crit
      end
      
      # Super Luck ability
      crit_stage += 1 if attacker_ability == :SUPERLUCK
      
      # Focus Energy (if tracked)
      if attacker.effects[PBEffects::FocusEnergy] && attacker.effects[PBEffects::FocusEnergy] > 0
        crit_stage += 2
      end
      
      # Items (Scope Lens, Razor Claw)
      attacker_item_safe = (attacker.item_id rescue nil)
      if [:SCOPELENS, :RAZORCLAW].include?(attacker_item_safe)
        crit_stage += 1
      end
      
      # Calculate crit rate
      crit_rate = case crit_stage
                  when 0 then 0.0417  # 1/24 (4.17%)
                  when 1 then 0.125   # 1/8 (12.5%)
                  when 2 then 0.5     # 1/2 (50%)
                  else 1.0            # Always crit at stage 3+
                  end
      
      # Crit multiplier (1.5x damage, ignores defensive stat boosts)
      # Note: We can't model defensive drops here since we're predicting on party Pokemon
      # So we apply a conservative crit bonus as weighted average
      if crit_rate >= 1.0
        # Always crit: Apply full 1.5x multiplier
        base_damage *= 1.5
      elsif crit_rate > 0
        # Probabilistic crit: Apply weighted average
        # E.g., 50% crit rate = (0.5 * 1.5x) + (0.5 * 1.0x) = 1.25x average
        base_damage *= (1.0 + crit_rate * 0.5)
      end
      
      # Sniper ability boosts crit damage from 1.5x to 2.25x
      if attacker_ability == :SNIPER && crit_rate > 0
        # Adjust multiplier from 1.5x to 2.25x (additional 0.75x on crit portion)
        additional_sniper_mult = crit_rate * 0.75
        base_damage *= (1.0 + additional_sniper_mult)
      end
    end
    
    # Apply modifiers (STAB, Type Effectiveness, Random roll average)
    estimated_damage = base_damage * stab * effectiveness_multiplier * DAMAGE_RANDOM_MULTIPLIER
    
    # Return as percentage of switch_pkmn's HP
    damage_percent = estimated_damage / [switch_pkmn.totalhp, 1].max
    
    # Log damage calculation in debug mode
    if AdvancedAI::DEBUG_SWITCH_INTELLIGENCE
      PBDebug.log("[DAMAGE CALC] #{move.name} vs #{switch_pkmn.name}: #{(damage_percent * 100).round(1)}% " +
                  "(Base: #{base_damage.round(1)}, STAB: #{stab}x, Eff: #{effectiveness_multiplier}x)")
    end
    
    return damage_percent
  end
  
  # Detailed Matchup Evaluation for Switch Selection
  def evaluate_switch_matchup_detailed(switch_pkmn, current_user)
    score = 0
    
    # Validate switch_pkmn has types
    return 0 unless switch_pkmn
    switch_types = switch_pkmn.types.compact
    return 0 if switch_types.empty? || switch_types.any?(&:nil?)
    
    # === ENTRY HAZARD DAMAGE PENALTY ===
    hazard_damage = calculate_entry_hazard_damage(switch_pkmn, current_user)
    if hazard_damage > 0
      hazard_penalty = (hazard_damage * 100).to_i  # Scale: 50% hazard damage = -50 points
      score -= hazard_penalty
      echoln "[HAZARD] #{(hazard_damage * 100).round(1)}% HP on switch-in [-#{hazard_penalty}]"
      
      # Extra penalty if hazards would faint us immediately
      if hazard_damage >= 1.0
        score -= 100  # FATAL - would faint on switch-in!
        echoln "FATAL] Hazards would KO on switch-in! [-100]"
      elsif hazard_damage >= 0.50
        score -= 30   # Massive damage = very risky switch
        echoln "[CRITICAL] 50%+ hazard damage! [-30]"
      end
    end
    
    # Check if current user is "already doomed" (will faint next turn)
    # If so, we should minimize damage on switch-in rather than avoid all OHKOs
    current_is_doomed = false
    if current_user && current_user.respond_to?(:fainted?) && !current_user.fainted?
      @battle.allOtherSideBattlers(get_battler_index(current_user)).each do |target|
        next unless target && !target.fainted?
        # Doomed if: Low HP AND slower than opponent
        hp_percent = current_user.hp.to_f / current_user.totalhp
        if hp_percent < 0.30 && target.pbSpeed > current_user.pbSpeed
          current_is_doomed = true
          break
        end
      end
    end
    
    # Analyze against all opponents
    @battle.allOtherSideBattlers(get_battler_index(current_user)).each do |target|
      next unless target && !target.fainted?
      
      target_types = target.pbTypes(true).compact
      next if target_types.empty? || target_types.any?(&:nil?)
      
      # Defensive Matchup (Incoming Moves)
      target.moves.each do |move|
        next unless move && move.damagingMove?
        next unless move.type  # Skip if move has no type
        
        move_type = move.pbCalcType(target)  # target is already a Battle::Battler
        next unless move_type  # Skip if calculated type is nil
        
        # Additional safety: ensure all switch types are valid
        next if switch_types.any? { |t| t.nil? }
        
        eff = Effectiveness.calculate(move_type, *switch_types)
        
        # Calculate actual damage to properly assess safety
        damage_percent = calculate_incoming_damage(switch_pkmn, move, target)
        
        # Type effectiveness scoring (base scoring)
        if Effectiveness.ineffective?(eff)
          score += 40
        elsif Effectiveness.not_very_effective?(eff)
          score += 15
        elsif Effectiveness.super_effective?(eff)
          score -= 25
        end
        
        # Damage-based penalties (critical for survival)
        # If current user is already doomed, we want to MINIMIZE damage, not avoid all OHKOs
        if current_is_doomed
          # In "doomed" scenario: Pick the switch that takes LEAST damage
          # Convert damage to a penalty (higher damage = worse score)
          damage_penalty = (damage_percent * 50).to_i  # Scale: 100% damage = -50 points
          score -= damage_penalty
          echoln "    [DAMAGE] #{move.name} (~#{(damage_percent * 100).to_i}% HP) [-#{damage_penalty}]"
        else
          # Normal scenario: Penalize based on OHKO/2HKO thresholds
          if damage_percent >= 0.85
            # Likely OHKO - this is a FATAL switch!
            score -= 60
            echoln "    [OHKO RISK] #{move.name} (~#{(damage_percent * 100).to_i}% HP) [-60]"
          elsif damage_percent >= 0.45
            # Likely 2HKO - risky switch
            score -= 30
            echoln "    [2HKO RISK] #{move.name} (~#{(damage_percent * 100).to_i}% HP) [-30]"
          elsif damage_percent >= 0.30
            # Moderate damage - somewhat risky
            score -= 10
          end
        end
      end
      
      # Offensive Matchup (Outgoing Moves)
      switch_pkmn.moves.each do |move|
        next unless move && move.id
        move_data = GameData::Move.try_get(move.id)
        next unless move_data
        next if move_data.category == 2  # Skip status moves (0=Physical, 1=Special, 2=Status)
        next unless move_data.type  # Skip if move has no type
        
        # Additional safety: ensure all target types are valid
        next if target_types.any? { |t| t.nil? }
        
        eff = Effectiveness.calculate(move_data.type, *target_types)
        
        if Effectiveness.super_effective?(eff)
          score += 20
        elsif Effectiveness.ineffective?(eff)
          score -= 40  # Useless move
        end
      end
    end
    
    return score
  end

  #=============================================================================
  # HELPER METHODS
  #=============================================================================
  
  def user_has_advantage?(user)
    my_types = get_real_types(user)
    
    @battle.allOtherSideBattlers(user.index).all? do |target|
      next true unless target && !target.fainted?
      
      # Type advantage
      user.moves.any? do |move|
        next false unless move && move.damagingMove?
        next false unless move.type
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        Effectiveness.super_effective?(type_mod)
      end
    end
  end
  
  def user_has_type_disadvantage?(user, target)
    my_types = get_real_types(user)
    
    target.moves.any? do |move|
      next false unless move && move.damagingMove?
      next false unless move.type
      type_mod = Effectiveness.calculate(move.type, *my_types)
      Effectiveness.super_effective?(type_mod)
    end
  end
  
  def determine_pokemon_role(battler)
    # Use the full 9-role detection system from RoleDetection
    primary, _secondary = AdvancedAI.detect_roles(battler)
    return primary || :balanced
  end
  
  # Helper to get REAL types (ignoring Illusion)
  def get_real_types(battler)
    # If Illusion is active (effects[PBEffects::Illusion] is truthy/Pokemon object),
    # return the types of the underlying Pokemon
    if battler.effects[PBEffects::Illusion]
      illusion_species = battler.effects[PBEffects::Illusion].species
      return GameData::Species.get(illusion_species).types.clone
    end
    
    # Otherwise return current effective types (includes Soak etc)
    return battler.pbTypes(true)
  end
  
  def determine_pokemon_role_from_stats(pkmn)
    # Use the full 9-role detection system from RoleDetection
    primary, _secondary = AdvancedAI.detect_roles(pkmn)
    return primary || :balanced
  end
  
  # Check if current Pokemon can KO any opponent
  # Enhanced: Also considers if user can strike FIRST (speed/priority)
  def can_ko_opponent?(user)
    return false unless user && !user.fainted?
    
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      user.moves.each do |move|
        next unless move && move.damagingMove?
        next unless move.type
        
        # Check type effectiveness
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        next if Effectiveness.ineffective?(type_mod)  # Can't KO with immune move
        
        # STAB bonus
        stab = user.pbHasType?(move.type) ? 1.5 : 1.0
        
        # Choose attack stat based on move category
        if move.physicalMove?
          atk = user.attack
          def_stat = target.defense
        else
          atk = user.spatk
          def_stat = target.spdef
        end
        
        # Simplified damage formula (conservative estimate)
        # Real formula: ((2*Level/5 + 2) * Power * A/D / 50 + 2) * Modifiers
        # Simplified: (A * Power / D) * STAB * Effectiveness / 100
        base_damage = (atk * move.power) / [def_stat, 1].max
        effectiveness_multiplier = Effectiveness.super_effective?(type_mod) ? 2.0 : 
                                   Effectiveness.not_very_effective?(type_mod) ? 0.5 : 1.0
        estimated_damage = (base_damage * stab * effectiveness_multiplier) / 100
        
        # Can KO? Add small buffer for random damage rolls
        if estimated_damage >= target.hp * 0.85
          # Additional check: Can we strike FIRST?
          # This is critical when both Pokemon are in KO range
          move_priority = move.priority || 0
          
          # If we have priority advantage, we can KO first
          return true if move_priority > 0
          
          # If equal priority, check speed
          if move_priority == 0
            # We can KO first if we're faster
            return true if user.pbSpeed > target.pbSpeed
            
            # Even if slower, if opponent CAN'T KO us back, still worth staying
            # (This handles the "I can 2HKO them but they can't touch me" scenario)
            opponent_can_ko_us = target.moves.any? do |opp_move|
              next false unless opp_move && opp_move.damagingMove?
              opp_type_mod = Effectiveness.calculate(opp_move.type, *user.pbTypes(true)) rescue 1.0
              next false if Effectiveness.ineffective?(opp_type_mod)
              
              opp_stab = target.pbHasType?(opp_move.type) ? 1.5 : 1.0
              opp_atk = opp_move.physicalMove? ? target.attack : target.spatk
              our_def = opp_move.physicalMove? ? user.defense : user.spdef
              
              opp_damage = (opp_atk * opp_move.power) / [our_def, 1].max
              opp_eff_mult = Effectiveness.super_effective?(opp_type_mod) ? 2.0 :
                             Effectiveness.not_very_effective?(opp_type_mod) ? 0.5 : 1.0
              opp_estimated = (opp_damage * opp_stab * opp_eff_mult) / 100
              
              opp_estimated >= user.hp * 0.85
            end
            
            return true unless opponent_can_ko_us
          end
        end
      end
    end
    
    return false
  end
  
  #=============================================================================
  # SACRIFICE PLAY LOGIC - Intentional sacs for momentum
  #=============================================================================
  
  def evaluate_sacrifice_value(user, skill)
    return 0 unless skill >= 80
    score = 0
    
    # Is current mon "doomed"? (Will die this turn regardless)
    hp_percent = user.hp.to_f / user.totalhp
    is_doomed = false
    
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      # Check if opponent can OHKO us with priority or outspeeds us
      target.moves.each do |move|
        next unless move && move.damagingMove?
        
        # Rough damage estimate
        rough_damage = estimate_sac_damage_percent(user, move, target)
        
        if rough_damage >= hp_percent * 100
          if move.priority > 0 || target.pbSpeed > user.pbSpeed
            is_doomed = true
            break
          end
        end
      end
      break if is_doomed
    end
    
    return 0 unless is_doomed
    
    # Doomed mon has sacrifice value - what can we accomplish?
    sac_value = 0
    
    # 1. Can we get a free switch to a sweeper?
    party = @battle.pbParty(user.index)
    sweepers = party.select do |pkmn|
      next false unless pkmn && !pkmn.fainted? && !pkmn.egg?
      next false if @battle.pbFindBattler(party.index(pkmn), user.index)
      # Is it a setup sweeper?
      pkmn.moves.any? { |m| m && AdvancedAI.setup_move?(m.id) }
    end
    
    sac_value += 20 if sweepers.any?
    
    # 2. Can we burn opponent's Dynamax turn by dying?
    @battle.allOtherSideBattlers(user.index).each do |target|
      if target.respond_to?(:dynamax?) && target.dynamax?
        sac_value += 30  # They waste Dynamax damage on fodder
      end
      if target.respond_to?(:tera?) && target.tera?
        sac_value += 15  # Less valuable but still good
      end
    end
    
    # 3. Can we use Explosion/Self-Destruct/Final Gambit to trade?
    trade_moves = user.moves.select { |m| m && [:EXPLOSION, :SELFDESTRUCT, :FINALGAMBIT, :MISTYEXPLOSION].include?(m.id) }
    if trade_moves.any?
      sac_value += 25  # Can at least trade
    end
    
    # 4. Entry hazards - dying sets up rocks
    if user.moves.any? { |m| m && [:STEALTHROCK, :SPIKES, :TOXICSPIKES].include?(m.id) }
      opp_side = @battle.sides[(user.index + 1) % 2]
      unless opp_side.effects[PBEffects::StealthRock]
        sac_value += 15  # Can set rocks before dying
      end
    end
    
    sac_value
  end
  
  def estimate_sac_damage_percent(defender, move, attacker)
    return 0 unless move && move.power && move.power > 0
    
    atk = move.physicalMove? ? attacker.attack : attacker.spatk
    defense = move.physicalMove? ? defender.defense : defender.spdef
    defense = [defense, 1].max
    
    type_mod = Effectiveness.calculate(move.type, defender.types[0], defender.types[1])
    type_mult = type_mod.to_f / Effectiveness::NORMAL_EFFECTIVE.to_f
    stab = attacker.pbHasType?(move.type) ? 1.5 : 1.0
    
    damage = ((2 * attacker.level / 5.0 + 2) * move.power * atk / defense / 50 + 2)
    damage *= type_mult * stab
    
    (damage / defender.totalhp.to_f * 100).to_i
  end
  
  #=============================================================================
  # ENTRY HAZARD DAMAGE CALCULATION
  #=============================================================================
  
  # Calculate total damage from entry hazards on switch-in
  # Returns damage as percentage of total HP (0.0 to 1.0+)
  def calculate_entry_hazard_damage(switch_pkmn, current_user)
    return 0.0 unless switch_pkmn && current_user
    
    total_damage = 0.0
    # Handle current_user being either a Battler or an index integer
    user_index = get_battler_index(current_user)
    opponent_side = @battle.sides[(user_index + 1) % 2]
    our_side = @battle.sides[user_index % 2]
    
    # === STEALTH ROCK ===
    if our_side.effects[PBEffects::StealthRock]
      # Stealth Rock damage based on Rock-type effectiveness
      sr_effectiveness = Effectiveness.calculate(:ROCK, *switch_pkmn.types.compact)
      sr_multiplier = sr_effectiveness.to_f / Effectiveness::NORMAL_EFFECTIVE_MULTIPLIER
      
      # Base damage is 12.5% (1/8 of max HP)
      sr_damage = 0.125 * sr_multiplier
      total_damage += sr_damage
      
      if AdvancedAI::DEBUG_SWITCH_INTELLIGENCE
        PBDebug.log("[HAZARD] Stealth Rock: #{(sr_damage * 100).round(1)}% (#{sr_multiplier}x effective)")
      end
    end
    
    # === SPIKES ===
    spikes_layers = our_side.effects[PBEffects::Spikes]
    if spikes_layers && spikes_layers > 0
      # Spikes don't affect Flying types or Levitate
      grounded = !switch_pkmn.types.include?(:FLYING)
      grounded = grounded && switch_pkmn.ability_id != :LEVITATE
      
      if grounded
        # 1 layer = 12.5%, 2 layers = 16.67%, 3 layers = 25%
        spikes_damage = case spikes_layers
                        when 1 then 0.125   # 1/8
                        when 2 then 0.16667 # 1/6
                        else 0.25           # 1/4
                        end
        total_damage += spikes_damage
        
        if AdvancedAI::DEBUG_SWITCH_INTELLIGENCE
          PBDebug.log("[HAZARD] Spikes (#{spikes_layers} layers): #{(spikes_damage * 100).round(1)}%")
        end
      end
    end
    
    # === TOXIC SPIKES ===
    toxic_spikes_layers = our_side.effects[PBEffects::ToxicSpikes]
    if toxic_spikes_layers && toxic_spikes_layers > 0
      # Toxic Spikes don't affect Flying, Poison, or Steel types
      grounded = !switch_pkmn.types.include?(:FLYING)
      grounded = grounded && switch_pkmn.ability_id != :LEVITATE
      immune = switch_pkmn.types.include?(:POISON) || switch_pkmn.types.include?(:STEEL)
      
      if grounded && !immune
        # No immediate damage, but inflicts poison/bad poison
        # We should penalize this in a different way (status condition value)
        # For now, assign a moderate penalty value
        total_damage += 0.10  # 10% "value" for getting poisoned
        
        if AdvancedAI::DEBUG_SWITCH_INTELLIGENCE
          status_type = toxic_spikes_layers >= 2 ? "Badly Poisoned" : "Poisoned"
          PBDebug.log("[HAZARD] Toxic Spikes: #{status_type} on switch-in")
        end
      end
    end
    
    # === STICKY WEB ===
    if our_side.effects[PBEffects::StickyWeb]
      # Sticky Web lowers Speed by 1 stage (no immediate damage)
      # Flying types and Levitate are immune
      grounded = !switch_pkmn.types.include?(:FLYING)
      grounded = grounded && switch_pkmn.ability_id != :LEVITATE
      
      if grounded
        # Assign a penalty for speed drop (especially bad for fast Pokemon)
        # Speed-oriented Pokemon (high speed stat) should value this more
        speed_ratio = switch_pkmn.speed.to_f / 130.0  # Normalize to common max speed
        sticky_web_penalty = [0.05 * speed_ratio, 0.15].min  # 5-15% penalty
        total_damage += sticky_web_penalty
        
        if AdvancedAI::DEBUG_SWITCH_INTELLIGENCE
          PBDebug.log("[HAZARD] Sticky Web: Speed -1 stage (~#{(sticky_web_penalty * 100).round(1)}% penalty)")
        end
      end
    end
    
    # === HEAVY-DUTY BOOTS CHECK ===
    # If Pokemon has Heavy-Duty Boots, it ignores all entry hazards
    if switch_pkmn.item_id == :HEAVYDUTYBOOTS
      if AdvancedAI::DEBUG_SWITCH_INTELLIGENCE && total_damage > 0
        PBDebug.log("[ITEM] Heavy-Duty Boots: Hazard damage negated!")
      end
      return 0.0
    end
    
    # === MAGIC GUARD CHECK ===
    # Magic Guard prevents indirect damage
    if switch_pkmn.ability_id == :MAGICGUARD
      if AdvancedAI::DEBUG_SWITCH_INTELLIGENCE && total_damage > 0
        PBDebug.log("[ABILITY] Magic Guard: Hazard damage negated!")
      end
      # Still suffer from Sticky Web speed drop and Toxic Spikes status
      # Return only the non-damage hazard penalties
      non_damage_penalty = 0.0
      non_damage_penalty += 0.10 if toxic_spikes_layers && toxic_spikes_layers > 0  # Poison penalty
      if our_side.effects[PBEffects::StickyWeb]
        speed_ratio = switch_pkmn.speed.to_f / 130.0
        non_damage_penalty += [0.05 * speed_ratio, 0.15].min
      end
      return non_damage_penalty
    end
    
    total_damage
  end
  
  #=============================================================================
  # SETUP MOVE DETECTION
  #=============================================================================
  
  # Detect if opponent is setting up (stat boosts)
  def opponent_is_setting_up?(opponent)
    return false unless opponent
    
    # Check if opponent has positive stat stages
    positive_stages = opponent.stages.values.count { |stage| stage > 0 }
    return true if positive_stages >= 2  # +2 or more boosts = setup threat
    
    # Check if opponent used setup move last turn
    last_move = opponent.battler.lastMoveUsed rescue nil
    return true if last_move && AdvancedAI.setup_move?(last_move)
    
    false
  end
  
  # Setup move check - delegated to AdvancedAI.setup_move? (Move_Categories.rb)
  # Uses the comprehensive SETUP_MOVES hash instead of a local hardcoded list
  
  # Evaluate setup threat level
  def evaluate_setup_threat(opponent)
    return 0 unless opponent
    
    threat = 0
    
    # Count positive stat stages
    offensive_boosts = [opponent.stages[:ATTACK], opponent.stages[:SPECIAL_ATTACK]].max
    speed_boosts = opponent.stages[:SPEED]
    
    # High offensive boosts = big threat
    threat += offensive_boosts * 20 if offensive_boosts > 0
    threat += speed_boosts * 15 if speed_boosts > 0
    
    # Check if opponent has setup moves in their moveset
    opponent.moves.each do |move|
      next unless move
      if AdvancedAI.setup_move?(move.id)
        threat += 10  # Has setup potential
      end
    end
    
    threat
  end
  
  #=============================================================================
  # SPEED TIER AWARENESS
  #=============================================================================
  
  # Check if switch-in can outspeed opponent
  def can_outspeed?(switch_pkmn, opponent)
    return false unless switch_pkmn && opponent
    
    # Get base speeds (party Pokemon doesn't have pbSpeed, calculate manually)
    switch_speed = calculate_party_speed(switch_pkmn)
    opponent_speed = opponent.pbSpeed
    
    # Account for priority moves (always "outspeed")
    # This is checked elsewhere, but good to know
    
    switch_speed > opponent_speed
  end
  
  # Calculate speed for party Pokemon (not in battle yet)
  def calculate_party_speed(pkmn)
    return 0 unless pkmn
    
    # Basic stat calculation (no stages since not in battle)
    base_speed = pkmn.speed
    
    # Nature modifier
    nature = pkmn.nature_id
    if nature
      nature_data = GameData::Nature.get(nature)
      if nature_data.stat_changes[:SPEED] == 10
        base_speed = (base_speed * 1.1).floor
      elsif nature_data.stat_changes[:SPEED] == -10
        base_speed = (base_speed * 0.9).floor
      end
    end
    
    # Item modifiers
    if pkmn.item_id == :CHOICESCARF
      base_speed = (base_speed * 1.5).floor
    elsif pkmn.item_id == :IRONBALL
      base_speed = (base_speed * 0.5).floor
    end
    
    # Ability modifiers (basic ones)
    case pkmn.ability_id
    when :SWIFTSWIM
      base_speed = (base_speed * 2).floor if @battle.pbWeather == :Rain
    when :CHLOROPHYLL
      base_speed = (base_speed * 2).floor if @battle.pbWeather == :Sun
    when :SANDRUSH
      base_speed = (base_speed * 2).floor if @battle.pbWeather == :Sandstorm
    when :SLUSHRUSH
      base_speed = (base_speed * 2).floor if @battle.pbWeather == :Hail
    when :SPEEDBOOST
      # Can't account for this pre-switch
    end
    
    base_speed
  end
  
  # Evaluate speed advantage for switch decision
  def evaluate_speed_advantage(switch_pkmn, current_user)
    score = 0
    
    @battle.allOtherSideBattlers(get_battler_index(current_user)).each do |opponent|
      next unless opponent && !opponent.fainted?
      
      if can_outspeed?(switch_pkmn, opponent)
        score += 15  # Outspeeding is valuable
        
        # Extra value if we can OHKO while outspeeding
        switch_pkmn.moves.each do |move|
          next unless move && move.damagingMove?
          
          # Rough damage check (would need full calc for accuracy)
          move_type = move.type
          opp_types = opponent.pbTypes(true)
          effectiveness = Effectiveness.calculate(move_type, *opp_types)
          
          if Effectiveness.super_effective?(effectiveness)
            score += 10  # Can hit hard while faster
            break
          end
        end
      else
        # Slower = need to tank a hit
        score -= 5
      end
    end
    
    score
  end
  
  #=============================================================================
  # PIVOT MOVE EVALUATION
  #=============================================================================
  
  # Evaluate if pivot move is available and better than hard switch
  # Returns bonus to REDUCE switch score (prefer pivot over switch)
  def evaluate_pivot_move_option(user, skill)
    return 0 unless user && skill >= 50
    
    pivot_moves = [:UTURN, :VOLTSWITCH, :FLIPTURN, :PARTINGSHOT, :TELEPORT, 
                   :BATONPASS, :SHEDTAIL, :CHILLYRECEPTION]
    
    bonus = 0
    
    user.moves.each do |move|
      next unless move && pivot_moves.include?(move.id)
      
      # Base bonus for having a pivot move
      bonus += 25
      
      # Extra bonus if pivot move is damaging and super effective
      if [:UTURN, :VOLTSWITCH, :FLIPTURN].include?(move.id)
        @battle.allOtherSideBattlers(user.index).each do |target|
          next unless target && !target.fainted?
          
          move_type = GameData::Move.get(move.id).type
          effectiveness = Effectiveness.calculate(move_type, *target.pbTypes(true))
          
          if Effectiveness.super_effective?(effectiveness)
            bonus += 10  # Can deal damage + switch safely
            break
          end
        end
      end
      
      # Parting Shot is especially valuable (debuff + safe switch)
      bonus += 15 if move.id == :PARTINGSHOT
      
      # Only count first pivot move found
      break
    end
    
    bonus
  end
  
  #=============================================================================
  # RECOVERY MOVE TIMING
  #=============================================================================
  
  # Determine if recovery move should be used instead of attacking/switching
  # Called from Move_Scorer when evaluating recovery moves
  def should_use_recovery_move?(user, recovery_move, skill)
    return false unless user && recovery_move
    return false if skill < 50  # Low skill AI doesn't optimize recovery
    
    hp_percent = user.hp.to_f / user.totalhp
    
    # Don't heal if healthy (>75% HP)
    return false if hp_percent > 0.75
    
    # Always heal if critical (<25% HP) and not slower than opponent
    if hp_percent < 0.25
      @battle.allOtherSideBattlers(user.index).each do |opponent|
        next unless opponent && !opponent.fainted?
        
        # If opponent outspeeds us and can OHKO, don't waste turn healing
        if opponent.pbSpeed > user.pbSpeed
          opponent.moves.each do |move|
            next unless move && move.damagingMove?
            
            # Rough damage estimate
            damage_percent = estimate_incoming_damage_percent(user, move, opponent)
            return false if damage_percent >= hp_percent * 100  # Would die anyway
          end
        end
      end
      
      # Safe to heal - no immediate OHKO threat or we're faster
      return true
    end
    
    # Moderate HP (25-50%) - heal if opponent can 2HKO
    if hp_percent < 0.50
      can_2hko = false
      
      @battle.allOtherSideBattlers(user.index).each do |opponent|
        next unless opponent && !opponent.fainted?
        
        opponent.moves.each do |move|
          next unless move && move.damagingMove?
          
          damage_percent = estimate_incoming_damage_percent(user, move, opponent)
          if damage_percent >= 45  # Would be 2HKO'd
            can_2hko = true
            break
          end
        end
        break if can_2hko
      end
      
      return true if can_2hko  # Heal to avoid 2HKO range
    end
    
    # Moderate HP (50-75%) - heal if we're stalling (status damage, weather, etc.)
    if hp_percent < 0.75
      # Check if we're benefiting from stall tactics
      stall_benefits = 0
      
      # Toxic/Burn on opponent
      @battle.allOtherSideBattlers(user.index).each do |opponent|
        next unless opponent && !opponent.fainted?
        stall_benefits += 1 if [:BURN, :POISON].include?(opponent.status)
      end
      
      # Leech Seed
      stall_benefits += 1 if user.effects[PBEffects::LeechSeed] >= 0
      
      # Leftovers
      stall_benefits += 1 if user.item_id == :LEFTOVERS
      
      # Weather damage to opponent
      weather = @battle.pbWeather
      if [:Sandstorm, :Hail].include?(weather)
        @battle.allOtherSideBattlers(user.index).each do |opponent|
          next unless opponent && !opponent.fainted?
          # Opponent takes weather damage, we might not
          stall_benefits += 1
        end
      end
      
      return true if stall_benefits >= 2  # Multiple stall advantages
    end
    
    false  # Don't heal by default
  end
  
  # Quick damage estimate for recovery timing (simpler than full calc)
  def estimate_incoming_damage_percent(defender, move, attacker)
    return 0 unless move && move.power && move.power > 0
    
    atk = move.physicalMove? ? attacker.attack : attacker.spatk
    defense = move.physicalMove? ? defender.defense : defender.spdef
    defense = [defense, 1].max
    
    move_type = move.pbCalcType(attacker) rescue move.type
    defender_types = defender.pbTypes(true)
    effectiveness = Effectiveness.calculate(move_type, *defender_types)
    type_mult = effectiveness.to_f / Effectiveness::NORMAL_EFFECTIVE_MULTIPLIER
    
    stab = attacker.pbHasType?(move_type) ? STAB_MULTIPLIER : 1.0
    
    level = attacker.level
    base_damage = ((2.0 * level / 5 + 2) * move.power * atk / defense / 50 + 2)
    estimated_damage = base_damage * stab * type_mult * DAMAGE_RANDOM_MULTIPLIER
    
    (estimated_damage / defender.totalhp.to_f * 100).round
  end
  
  #=============================================================================
  # DEBUG TOOLS
  #=============================================================================
  
  # Enhanced damage calculation with debug output
  def debug_damage_calculation(switch_pkmn, move, attacker, show_breakdown: false)
    damage = calculate_incoming_damage(switch_pkmn, move, attacker)
    
    if show_breakdown && AdvancedAI::DEBUG_SWITCH_INTELLIGENCE
      PBDebug.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
      PBDebug.log("DAMAGE BREAKDOWN: #{move.name} → #{switch_pkmn.name}")
      PBDebug.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
      
      # Move info
      move_type = move.pbCalcType(attacker) rescue move.type
      PBDebug.log("Move: #{move.name} (#{move_type}, #{move.power} BP)")
      
      # Type effectiveness
      effectiveness = Effectiveness.calculate(move_type, *switch_pkmn.types.compact)
      eff_mult = effectiveness.to_f / Effectiveness::NORMAL_EFFECTIVE_MULTIPLIER
      PBDebug.log("Effectiveness: #{eff_mult}x (#{switch_pkmn.types.join('/')} vs #{move_type})")
      
      # Stats
      if move.physicalMove?
        PBDebug.log("Physical: #{attacker.attack} Atk vs #{switch_pkmn.defense} Def")
      else
        PBDebug.log("Special: #{attacker.spatk} SpA vs #{switch_pkmn.spdef} SpD")
      end
      
      # Abilities
      PBDebug.log("Attacker Ability: #{attacker.ability_id}") if attacker.ability_id
      PBDebug.log("Defender Ability: #{switch_pkmn.ability_id}") if switch_pkmn.ability_id
      
      # Final damage
      PBDebug.log("RESULT: #{(damage * 100).round(1)}% damage")
      PBDebug.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    end
    
    damage
  end
  
  # Log switch decision reasoning
  def log_switch_decision(user, should_switch, best_switch_idx = nil)
    return unless AdvancedAI::DEBUG_SWITCH_INTELLIGENCE
    
    PBDebug.log("")
    PBDebug.log("═══════════════════════════════════════")
    PBDebug.log("SWITCH DECISION SUMMARY")
    PBDebug.log("═══════════════════════════════════════")
    PBDebug.log("Current: #{user.name} (#{user.hp}/#{user.totalhp} HP)")
    
    if should_switch && best_switch_idx
      party = @battle.pbParty(user.index)
      best_mon = party[best_switch_idx]
      PBDebug.log("DECISION: ✅ SWITCH to #{best_mon.name}")
      PBDebug.log("Reason: Better matchup / Strategic advantage")
    else
      PBDebug.log("DECISION: ❌ STAY with #{user.name}")
      reasons = []
      reasons << "No better matchup" unless should_switch
      reasons << "Can secure KO" if can_ko_opponent?(user)
      reasons << "Has stat boosts" if user.stages.values.any? { |s| s > 0 }
      reasons << "Just switched in" if user.turnCount < 2
      PBDebug.log("Reason: #{reasons.join(', ')}")
    end
    
    PBDebug.log("═══════════════════════════════════════")
    PBDebug.log("")
  end
end

AdvancedAI.log("Switch Intelligence loaded", "Switch")
AdvancedAI.log("  - Sacrifice play logic", "Switch")
AdvancedAI.log("  - Setup move detection", "Switch")
AdvancedAI.log("  - Speed tier awareness", "Switch")
AdvancedAI.log("  - Ability/Item-aware damage calc", "Switch")
AdvancedAI.log("  - Debug tools enabled", "Switch")

### FILE: Tactical_Enhancements.rb ###
#===============================================================================
# Advanced AI System - Tactical Enhancements
# Features #1-21: Ability/Item/Move strategies, multi-turn planning, doubles
#===============================================================================

module AdvancedAI
  module TacticalEnhancements

    #===========================================================================
    # #1 MAGIC BOUNCE IN-BATTLE PENALTY
    # Status/hazard moves bounce back — never use them vs Magic Bounce
    #===========================================================================
    MAGIC_BOUNCE_ABILITIES = [:MAGICBOUNCE]
    MAGIC_BOUNCE_BLOCKED = [
      # Hazards
      :STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB,
      # Status
      :THUNDERWAVE, :WILLOWISP, :TOXIC, :POISONPOWDER, :STUNSPORE,
      :SLEEPPOWDER, :SPORE, :HYPNOSIS, :DARKVOID, :GLARE, :YAWN,
      :SING, :GRASSWHISTLE, :LOVELYKISS, :POISONGAS,
      # Stat drops / disruption
      :TAUNT, :ENCORE, :TORMENT, :DISABLE,
      # Entry disruption
      :ROAR, :WHIRLWIND,
      # Screens-debuff
      :DEFOG,  # Defog also raises target evasion — it's reflected
      # Other
      :LEECHSEED, :EMBARGO, :HEALBLOCK,
    ]

    def self.magic_bounce_penalty(target, move)
      return 0 unless target && move
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil
      return 0 unless MAGIC_BOUNCE_ABILITIES.include?(target_ability)
      return 0 unless move.statusMove? || MAGIC_BOUNCE_BLOCKED.include?(move.id)
      # Only penalize status/entry moves that bounce back
      if MAGIC_BOUNCE_BLOCKED.include?(move.id)
        AdvancedAI.log("#{move.name} blocked by Magic Bounce on #{target.name}", "Ability")
        return -500  # Effectively blocked — bounces back to us!
      end
      0
    end

    #===========================================================================
    # #2 MOLD BREAKER FAMILY — bypass target abilities in damage calc
    # Mold Breaker/Teravolt/Turboblaze ignore Levitate, Sturdy, Multiscale etc.
    #===========================================================================
    MOLD_BREAKER_ABILITIES = [:MOLDBREAKER, :TERAVOLT, :TURBOBLAZE, :MYCELIUMMIGHT]

    # Bonus when user has Mold Breaker and target has a defensive ability
    BYPASSED_ABILITIES = [:LEVITATE, :STURDY, :MULTISCALE, :SHADOWSHIELD,
                          :DISGUISE, :ICEFACE, :WONDERGUARD, :MAGICBOUNCE,
                          :FLASHFIRE, :WATERABSORB, :VOLTABSORB, :LIGHTNINGROD,
                          :STORMDRAIN, :SAPSIPPER, :MOTORDRIVE, :DRYSKIN,
                          :BATTLEARMOR, :SHELLARMOR, :UNAWARE, :FURCOAT]

    def self.mold_breaker_bonus(user, target, move)
      return 0 unless user && target && move && move.damagingMove?
      user_ability = user.respond_to?(:ability_id) ? user.ability_id : nil
      return 0 unless MOLD_BREAKER_ABILITIES.include?(user_ability)
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil
      return 0 unless target_ability && BYPASSED_ABILITIES.include?(target_ability)

      bonus = 0
      case target_ability
      when :LEVITATE
        # Ground moves now hit! Huge bonus for EQ/Earth Power
        bonus += 40 if move.type == :GROUND
        AdvancedAI.log("Mold Breaker bypasses Levitate: +#{bonus} for #{move.name}", "Ability") if bonus > 0
      when :STURDY
        bonus += 20  # Can OHKO from full HP now
      when :MULTISCALE, :SHADOWSHIELD
        bonus += 25  # Full damage at full HP
      when :DISGUISE, :ICEFACE
        bonus += 15  # Breaks form AND does damage
      when :WONDERGUARD
        bonus += 50  # Can hit through Wonder Guard!
      when :MAGICBOUNCE
        bonus += 10  # Not huge for damaging moves but still relevant
      when :FLASHFIRE, :WATERABSORB, :VOLTABSORB, :LIGHTNINGROD,
           :STORMDRAIN, :SAPSIPPER, :MOTORDRIVE, :DRYSKIN
        # Type-absorbing abilities bypassed — our move hits normally
        bonus += 35
        AdvancedAI.log("Mold Breaker bypasses #{target_ability}: +#{bonus} for #{move.name}", "Ability") if bonus > 0
      when :FURCOAT
        bonus += 15  # Full physical damage
      when :UNAWARE
        bonus += 10  # Our boosts count
      else
        bonus += 10  # Generic bypass bonus
      end
      bonus
    end

    #===========================================================================
    # #3 STURDY AWARENESS
    # Multi-hit moves bypass Sturdy; chip first to break it
    #===========================================================================
    MULTI_HIT_MOVES = [
      :BULLETSEED, :ICICLESPEAR, :ROCKBLAST, :SCALESHOT, :WATERSHURIKEN,
      :TAILSLAP, :TRIPLEAXEL, :SURGINGSTRIKES, :BONERUSH, :PINMISSILE,
      :DOUBLEHIT, :DOUBLEKICK, :TWINEEDLE, :TRIPLEAXEL, :POPULATIONBOMB,
      :ARMTHRUST, :BARRAGE, :COMETPUNCH, :FURYATTACK, :FURYSWIPES,
      :SPIKECANNON, :DUALWINGBEAT, :TRIPLEKICK
    ]

    def self.sturdy_awareness(user, target, move)
      return 0 unless target && move && move.damagingMove?
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil
      return 0 unless target_ability == :STURDY

      # Only relevant at full HP
      hp_pct = target.hp.to_f / target.totalhp
      return 0 unless hp_pct >= 0.99

      bonus = 0
      if MULTI_HIT_MOVES.include?(move.id)
        bonus += 40  # Multi-hit bypasses Sturdy!
        AdvancedAI.log("#{move.name} bypasses Sturdy (multi-hit): +40", "Ability")
      elsif move.power && move.power <= 60
        bonus += 10  # Weak move to break Sturdy, then follow up
      else
        bonus -= 15  # Strong move wasted — they'll survive at 1 HP
      end
      bonus
    end

    #===========================================================================
    # #4 MULTISCALE / SHADOW SHIELD — half damage at full HP
    # Prefer chip/hazards first; don't waste strongest move at full HP
    #===========================================================================
    def self.multiscale_awareness(user, target, move)
      return 0 unless target && move && move.damagingMove?
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil
      return 0 unless target_ability == :MULTISCALE || target_ability == :SHADOWSHIELD

      hp_pct = target.hp.to_f / target.totalhp
      return 0 unless hp_pct >= 0.99  # Only active at full HP

      bonus = 0
      # Prefer weak chip moves to break Multiscale
      if move.power && move.power <= 60
        bonus += 15  # Good — break Multiscale with chip
        AdvancedAI.log("#{move.name} chips #{target_ability} (weak move): +15", "Ability")
      elsif move.power && move.power >= 100
        bonus -= 20  # Bad — wasting strong move at half damage
        AdvancedAI.log("#{move.name} halved by #{target_ability}: -20", "Ability")
      end

      # Status moves that deal chip are great (Stealth Rock, Toxic, Will-O-Wisp)
      if move.statusMove?
        if [:TOXIC, :WILLOWISP, :THUNDERWAVE].include?(move.id)
          bonus += 10  # Status breaks Multiscale for next turn
        end
      end
      bonus
    end

    #===========================================================================
    # #5 FOCUS SASH CONSUMPTION TRACKING
    # If Sash is consumed (HP < 100% at any point), don't play around it
    #===========================================================================
    @sash_consumed = {}

    def self.mark_sash_consumed(battler_index)
      @sash_consumed[battler_index] = true
    end

    def self.sash_consumed?(battler_index)
      @sash_consumed[battler_index] == true
    end

    def self.cleanup_sash_tracking
      @sash_consumed = {}
    end

    def self.focus_sash_awareness(user, target, move)
      return 0 unless target && move && move.damagingMove?
      target_item = target.respond_to?(:item_id) ? target.item_id : nil
      return 0 unless target_item == :FOCUSSASH

      # If target has taken damage, Sash is broken
      hp_pct = target.hp.to_f / target.totalhp
      idx = target.respond_to?(:index) ? target.index : 0
      if hp_pct < 0.99 || sash_consumed?(idx)
        mark_sash_consumed(idx)
        return 0  # Sash already broken — score normally
      end

      # Sash is active — multi-hit moves bypass it
      if MULTI_HIT_MOVES.include?(move.id)
        AdvancedAI.log("#{move.name} bypasses Focus Sash (multi-hit): +30", "Item")
        return 30
      end

      # Strong single-hit moves are wasted on Sash — they survive at 1 HP anyway
      if move.power && move.power >= 100
        return -15  # Use a weaker move first to pop Sash
      end
      0
    end

    #===========================================================================
    # #6 FLAME ORB + GUTS + FACADE SYNERGY
    # Don't burn Guts mons; prefer Facade when Guts-active
    #===========================================================================
    GUTS_ABILITIES = [:GUTS, :MARVELSCALE, :QUICKFEET]

    def self.guts_status_penalty(target, move)
      return 0 unless target && move
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil

      # Don't inflict status on Guts/Marvel Scale/Quick Feet targets
      if target_ability == :GUTS
        if [:WILLOWISP, :TOXIC, :THUNDERWAVE, :SCALD].include?(move.id)
          AdvancedAI.log("#{move.name} powers up Guts on #{target.name}: -60", "Ability")
          return -60  # You're powering them up!
        end
        # Scald's 30% burn chance makes it riskier
        if move.id == :SCALD
          return -30
        end
      end

      if target_ability == :MARVELSCALE
        if [:WILLOWISP, :TOXIC, :THUNDERWAVE].include?(move.id)
          return -40  # +50% Defense when statused
        end
      end

      if target_ability == :QUICKFEET
        if [:THUNDERWAVE, :WILLOWISP, :TOXIC].include?(move.id)
          return -30  # 1.5x Speed when statused
        end
      end
      0
    end

    def self.facade_guts_bonus(user, move)
      return 0 unless user && move
      return 0 unless move.id == :FACADE
      user_ability = user.respond_to?(:ability_id) ? user.ability_id : nil
      user_status = user.respond_to?(:status) ? user.status : :NONE

      if user_status != :NONE
        bonus = 30  # Facade doubles to 140 BP when statused
        if user_ability == :GUTS
          bonus += 25  # 1.5x on top of 140 BP = 210 effective BP!
          AdvancedAI.log("Facade + Guts: +55 (210 effective BP!)", "Ability")
        end
        return bonus
      end
      0
    end

    # Don't inflict status on Poison Heal mons either
    def self.poison_heal_penalty(target, move)
      return 0 unless target && move
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil
      return 0 unless target_ability == :POISONHEAL

      if [:TOXIC, :POISONPOWDER, :POISONGAS, :TOXICSPIKES].include?(move.id)
        AdvancedAI.log("#{move.name} heals Poison Heal on #{target.name}: -80", "Ability")
        return -80  # You're giving them 1/8 HP recovery per turn!
      end
      0
    end

    #===========================================================================
    # #7 TRAPPING ABILITY AWARENESS
    # When WE have Arena Trap/Shadow Tag/Magnet Pull: opponent can't switch
    # → boost setup & Toxic; reduce switch-pressure concern
    #===========================================================================
    TRAPPING_ABILITIES = [:ARENATRAP, :SHADOWTAG, :MAGNETPULL]

    def self.trapping_ability_bonus(user, target, move)
      return 0 unless user && target && move
      user_ability = user.respond_to?(:ability_id) ? user.ability_id : nil
      return 0 unless TRAPPING_ABILITIES.include?(user_ability)

      # Check if target is actually trapped
      can_escape = false
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil

      case user_ability
      when :ARENATRAP
        # Flying types and Levitate are immune
        can_escape = true if target.respond_to?(:pbHasType?) && target.pbHasType?(:FLYING)
        can_escape = true if target_ability == :LEVITATE
        can_escape = true if target.respond_to?(:item_id) && target.item_id == :AIRBALLOON
      when :SHADOWTAG
        can_escape = true if target_ability == :SHADOWTAG  # Mirror match
        can_escape = true if target.respond_to?(:pbHasType?) && target.pbHasType?(:GHOST)
      when :MAGNETPULL
        # Only traps Steel types
        can_escape = true unless target.respond_to?(:pbHasType?) && target.pbHasType?(:STEEL)
      end
      return 0 if can_escape

      bonus = 0
      # Target can't escape — boost setup & status moves
      if AdvancedAI.setup_move?(move.id)
        bonus += 25  # Free setup — they can't switch to a counter
        AdvancedAI.log("Trapped foe: +25 for setup #{move.name}", "Tactic")
      end
      if [:TOXIC, :WILLOWISP, :THUNDERWAVE].include?(move.id)
        bonus += 20  # Status sticks — no switching out
      end
      if move.id == :PERISHSONG
        bonus += 40  # Perish trap combo!
        AdvancedAI.log("Perish trap: +40 for Perish Song", "Tactic")
      end
      # Reduce value of phazing (they're already trapped)
      if [:ROAR, :WHIRLWIND, :DRAGONTAIL, :CIRCLETHROW].include?(move.id)
        bonus -= 20  # Don't phaze — we want them trapped
      end
      bonus
    end

    #===========================================================================
    # #8 INTIMIDATE CYCLING (Doubles)
    # Switch Intimidate mons in/out to repeatedly lower Attack
    #===========================================================================
    def self.intimidate_cycle_bonus(battle, user, skill)
      return 0 unless battle && user && skill >= 70
      return 0 unless battle.pbSideSize(0) > 1  # Doubles only
      user_ability = user.respond_to?(:ability_id) ? user.ability_id : nil
      return 0 unless user_ability == :INTIMIDATE

      # Check if opponents are physical
      physical_threat_count = 0
      battle.allOtherSideBattlers(user.index).each do |opp|
        next unless opp && !opp.fainted?
        # Count physical attackers
        phys_moves = opp.moves.count { |m| m && m.physicalMove? && m.power && m.power >= 60 }
        physical_threat_count += 1 if phys_moves >= 2
        # Defiant/Competitive counter-check
        opp_ability = opp.respond_to?(:ability_id) ? opp.ability_id : nil
        return 0 if opp_ability == :DEFIANT || opp_ability == :COMPETITIVE
        return 0 if opp_ability == :CLEARBODY || opp_ability == :WHITESMOKE || opp_ability == :FULLMETALBODY
      end

      return 0 if physical_threat_count == 0

      # If we've been in battle for a while, switching out to come back = free Intimidate
      bonus = 0
      if user.turnCount >= 2 && physical_threat_count >= 1
        bonus += physical_threat_count * 15  # More physical threats = more value
        AdvancedAI.log("Intimidate cycle value: +#{bonus} (#{physical_threat_count} phys threats)", "Doubles")
      end
      bonus
    end

    #===========================================================================
    # #9 MULTI-TURN LOOK-AHEAD (2-3 turn sequences)
    # Evaluate common competitive sequences as cohesive plans
    #===========================================================================
    def self.multi_turn_bonus(battle, user, move, target, skill)
      return 0 unless user && move && skill >= 75
      bonus = 0

      user_moves = user.moves.map { |m| m.id if m }.compact
      hp_pct = user.hp.to_f / user.totalhp

      # Belly Drum → priority move sweep
      if move.id == :BELLYDRUM
        has_priority = user_moves.any? { |mid| [:AQUAJET, :MACHPUNCH, :BULLETPUNCH, :ICESHARD, :EXTREMESPEED, :SUCKERPUNCH, :SHADOWSNEAK, :JETPUNCH].include?(mid) }
        if has_priority && hp_pct > 0.55
          bonus += 40  # Belly Drum + priority = sweep potential
          AdvancedAI.log("Multi-turn: Belly Drum → priority sweep: +40", "Plan")
        elsif !has_priority
          bonus -= 10  # No priority = risky (can be revenge killed)
        end
      end

      # Shell Smash → sweep
      if move.id == :SHELLSMASH
        user_item = user.respond_to?(:item_id) ? user.item_id : nil
        if user_item == :WHITEHERB
          bonus += 30  # No defense drops!
          AdvancedAI.log("Multi-turn: Shell Smash + White Herb: +30", "Plan")
        end
        # Check if we outspeed after +2
        if target
          our_speed = user.speed * 2  # +2 Speed
          their_speed = target.respond_to?(:speed) ? target.speed : 100
          bonus += 20 if our_speed > their_speed  # We'll outspeed = sweep
        end
      end

      # Toxic → Protect stall
      if move.id == :TOXIC
        has_protect = user_moves.include?(:PROTECT) || user_moves.include?(:BANEFULBUNKER) || user_moves.include?(:SPIKYSHIELD)
        has_recovery = user_moves.any? { |mid| AdvancedAI.healing_move?(mid) rescue false }
        if has_protect && has_recovery
          bonus += 20  # Toxic stall plan
          AdvancedAI.log("Multi-turn: Toxic → Protect → Recover plan: +20", "Plan")
        end
      end

      # Substitute → setup
      if move.id == :SUBSTITUTE && hp_pct > 0.3
        has_setup = user_moves.any? { |mid| AdvancedAI.setup_move?(mid) rescue false }
        if has_setup
          bonus += 15  # Sub → setup is a classic competitive sequence
          AdvancedAI.log("Multi-turn: Substitute → setup: +15", "Plan")
        end
        # Sub + Focus Punch
        if user_moves.include?(:FOCUSPUNCH)
          bonus += 25
          AdvancedAI.log("Multi-turn: Sub → Focus Punch: +25", "Plan")
        end
      end

      # Dragon Dance / Quiver Dance → sweep check
      if [:DRAGONDANCE, :QUIVERDANCE, :SHIFTGEAR].include?(move.id)
        if target
          our_speed_boosted = user.speed * 1.5  # +1 Speed
          their_speed = target.respond_to?(:speed) ? target.speed : 100
          if our_speed_boosted > their_speed
            bonus += 15  # One DD and we outspeed = sweep
            AdvancedAI.log("Multi-turn: #{move.name} outspeeds at +1: +15", "Plan")
          end
        end
      end

      # Swords Dance/Nasty Plot at safe HP = followup sweep
      if [:SWORDSDANCE, :NASTYPLOT, :CALMMIND].include?(move.id)
        if hp_pct > 0.7 && user.effects[PBEffects::Substitute] > 0
          bonus += 20  # Behind Sub = safe setup
        end
      end

      bonus
    end

    #===========================================================================
    # #10 POWER HERB + CHARGE MOVES
    # Solar Beam, Meteor Beam, Phantom Force etc. skip charge turn
    #===========================================================================
    CHARGE_MOVES = [
      :SOLARBEAM, :SOLARBLADE, :METEORBEAM, :PHANTOMFORCE, :SHADOWFORCE,
      :SKULLBASH, :SKYATTACK, :FLY, :DIG, :DIVE, :BOUNCE, :GEOMANCY,
      :FREEZESHOCK, :ICEBURN, :RAZORWIND, :ELECTROSHOT
    ]

    def self.power_herb_bonus(user, move)
      return 0 unless user && move
      user_item = user.respond_to?(:item_id) ? user.item_id : nil
      return 0 unless user_item == :POWERHERB
      return 0 unless CHARGE_MOVES.include?(move.id)

      bonus = 35  # Skips charge turn = massive action economy gain
      # Meteor Beam also raises SpAtk → extra value
      bonus += 15 if move.id == :METEORBEAM
      # Geomancy raises SpAtk/SpDef/Speed → insane value
      bonus += 25 if move.id == :GEOMANCY
      AdvancedAI.log("Power Herb: #{move.name} instant: +#{bonus}", "Item")
      bonus
    end

    #===========================================================================
    # #11 WHITE HERB + SHELL SMASH / STAT-DROP MOVES
    # Negates defense drops from Shell Smash, Close Combat, etc.
    #===========================================================================
    SELF_DROP_MOVES = [:SHELLSMASH, :CLOSECOMBAT, :SUPERPOWER, :OVERHEAT,
                       :DRACOMETEOR, :LEAFSTORM, :FLEURCANNON, :PSYCHOBOOST,
                       :VCREATE]

    def self.white_herb_bonus(user, move)
      return 0 unless user && move
      user_item = user.respond_to?(:item_id) ? user.item_id : nil
      return 0 unless user_item == :WHITEHERB
      return 0 unless SELF_DROP_MOVES.include?(move.id)

      bonus = 0
      case move.id
      when :SHELLSMASH
        bonus += 35  # +2/+2/+2 with NO defense drops = insane
        AdvancedAI.log("White Herb + Shell Smash: +35 (no def drops!)", "Item")
      when :CLOSECOMBAT, :SUPERPOWER
        bonus += 15  # No Atk/Def drops
      when :OVERHEAT, :DRACOMETEOR, :LEAFSTORM, :FLEURCANNON, :PSYCHOBOOST
        bonus += 20  # No SpAtk drop = can spam
        AdvancedAI.log("White Herb + #{move.name}: +20 (no SpAtk drop)", "Item")
      when :VCREATE
        bonus += 15
      end
      bonus
    end

    #===========================================================================
    # #12 DISGUISE / ICE FACE — waste weak hit to break form
    #===========================================================================
    def self.disguise_iceface_awareness(user, target, move)
      return 0 unless target && move && move.damagingMove?
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil

      if target_ability == :DISGUISE
        # Check if Disguise is still active (form 0 = Disguised)
        form = target.respond_to?(:form) ? target.form : 0
        if form == 0  # Disguised form
          if move.power && move.power <= 60
            return 20  # Good — use weak move to pop Disguise
          elsif move.power && move.power >= 100
            return -25  # Bad — wasting strong move on Disguise
          end
        end
      end

      if target_ability == :ICEFACE
        form = target.respond_to?(:form) ? target.form : 0
        if form == 0 && move.physicalMove?  # Ice Face blocks first physical hit
          if move.power && move.power <= 60
            return 15  # Good — pop Ice Face cheaply
          elsif move.power && move.power >= 100
            return -20  # Bad — wasting strong physical move
          end
          # Special moves bypass Ice Face entirely!
        end
        if move.specialMove?
          return 10  # Special moves go through Ice Face
        end
      end
      0
    end

    #===========================================================================
    # #13 POISON HEAL / GUTS STATUS IMMUNITY (aggregated)
    # Combined: don't inflict status on ability-immune targets
    #===========================================================================
    # (Implemented in #6 above — guts_status_penalty + poison_heal_penalty)

    #===========================================================================
    # #14 GOOD AS GOLD — full status immunity
    #===========================================================================
    def self.good_as_gold_penalty(target, move)
      return 0 unless target && move
      target_ability = target.respond_to?(:ability_id) ? target.ability_id : nil
      return 0 unless target_ability == :GOODASGOLD
      return 0 unless move.statusMove?

      AdvancedAI.log("#{move.name} blocked by Good as Gold on #{target.name}: -200", "Ability")
      -200  # All status moves fail against Good as Gold
    end

    #===========================================================================
    # #15 FUTURE SIGHT + SWITCH SYNERGY
    # Use Future Sight, then switch to a fighter who pressures the target
    #===========================================================================
    def self.future_sight_bonus(battle, user, move, target)
      return 0 unless move && user
      return 0 unless move.id == :FUTURESIGHT || move.id == :DOOMDESIRE

      bonus = 0
      # Check if Future Sight is already active
      if target && target.effects[PBEffects::FutureSightCounter] > 0
        return -50  # Already active — don't stack
      end

      # Bonus if we have good switch-ins that pressure the target
      party = battle.pbParty(user.index) rescue []
      good_partners = 0
      party.each do |pkmn|
        next if !pkmn || pkmn.fainted? || pkmn.egg?
        next if pkmn == (user.respond_to?(:pokemon) ? user.pokemon : user)
        # Partner that can pressure the target (physical attacker, trapper, etc.)
        pkmn_roles = AdvancedAI.detect_roles(pkmn) rescue [:balanced]
        good_partners += 1 if pkmn_roles.include?(:wallbreaker) || pkmn_roles.include?(:sweeper)
      end

      if good_partners >= 1
        bonus += 20  # Future Sight + switch to attacker = double pressure
        bonus += 10 if good_partners >= 2
        AdvancedAI.log("Future Sight + switch option: +#{bonus}", "Tactic")
      end

      # Pivot moves make this even better (switch out safely)
      user_moves = user.moves.map { |m| m.id if m }.compact
      pivot_moves = [:UTURN, :VOLTSWITCH, :FLIPTURN, :PARTINGSHOT, :TELEPORT, :BATONPASS]
      if user_moves.any? { |mid| pivot_moves.include?(mid) }
        bonus += 10  # Can pivot out after Future Sight
      end
      bonus
    end

    #===========================================================================
    # #16 WISH PROACTIVE USE + WISH-PASS
    # Use Wish at high HP to prepare healing cycle
    #===========================================================================
    def self.wish_proactive_bonus(battle, user, move)
      return 0 unless move && user
      return 0 unless move.id == :WISH

      bonus = 0
      hp_pct = user.hp.to_f / user.totalhp

      # Already handled: Wish active → blocked. This handles the planning aspect.

      # At high HP: less immediate need, but good for cycling
      if hp_pct > 0.85
        # Check if any teammate is low
        party = battle.pbParty(user.index) rescue []
        low_teammates = party.count do |pkmn|
          next false if !pkmn || pkmn.fainted? || pkmn.egg?
          next false if pkmn == (user.respond_to?(:pokemon) ? user.pokemon : user)
          pkmn.hp.to_f / pkmn.totalhp < 0.5
        end

        if low_teammates >= 1
          bonus += 25  # Wish-pass to heal a teammate
          AdvancedAI.log("Wish-pass: low teammate needs healing: +25", "Tactic")
        else
          bonus += 10  # Proactive Wish at high HP = prepare for future
        end
      end

      # Wish + Protect combo detection
      user_moves = user.moves.map { |m| m.id if m }.compact
      if user_moves.include?(:PROTECT) || user_moves.include?(:BANEFULBUNKER)
        bonus += 10  # Can guarantee Wish landing with Protect next turn
      end
      bonus
    end

    #===========================================================================
    # #17 BELLY DRUM DEDICATED EVAL
    # All-or-nothing: +6 Atk but costs 50% HP
    #===========================================================================
    def self.belly_drum_eval(battle, user, move, target, skill)
      return 0 unless move && move.id == :BELLYDRUM
      return 0 unless user

      hp_pct = user.hp.to_f / user.totalhp
      # Need >50% HP to use
      return -200 if hp_pct <= 0.5

      bonus = 0
      user_moves = user.moves.map { |m| m.id if m }.compact
      user_item = user.respond_to?(:item_id) ? user.item_id : nil

      # Priority move = can sweep even at half HP
      priority_moves = [:AQUAJET, :MACHPUNCH, :BULLETPUNCH, :ICESHARD,
                        :EXTREMESPEED, :SUCKERPUNCH, :SHADOWSNEAK, :JETPUNCH]
      has_priority = user_moves.any? { |mid| priority_moves.include?(mid) }

      if has_priority
        bonus += 50  # Belly Drum + priority = guaranteed sweep
      end

      # Sitrus Berry recovery after Drum
      if user_item == :SITRUSBERRY
        bonus += 20  # Recover 25% after Drum → 75% HP at +6
      end

      # Check if we can actually sweep from +6
      if target
        our_atk_boosted = user.attack * 4  # +6 stages
        # Rough check: can we OHKO most things?
        their_def = target.respond_to?(:defense) ? target.defense : 100
        if our_atk_boosted > their_def * 3
          bonus += 20  # Likely sweeping
        end
      end

      # Penalty if opponent has priority/scarf revenge killer
      if target
        target_speed = target.respond_to?(:speed) ? target.speed : 100
        if target_speed > user.speed && !has_priority
          bonus -= 30  # They outspeed us = revenge killed post-Drum
        end
      end

      AdvancedAI.log("Belly Drum eval: #{bonus} (priority=#{has_priority}, HP=#{(hp_pct * 100).to_i}%%)", "Plan") if bonus != 0
      bonus
    end

    #===========================================================================
    # #18 STALL-BREAKER MODE
    # When facing stall, prioritize anti-stall tools cohesively
    #===========================================================================
    def self.stallbreaker_bonus(battle, user, move, target, skill)
      return 0 unless battle && user && move && skill >= 70
      return 0 unless target

      # Check if opponent is running stall
      state = AdvancedAI::StrategicAwareness.battle_state(battle) rescue nil
      archetype = state ? state[:opponent_archetype] : nil
      return 0 unless archetype == :stall

      bonus = 0
      # Taunt is king vs stall
      if move.id == :TAUNT
        bonus += 30
        AdvancedAI.log("Stallbreaker: Taunt vs stall: +30", "Strategy")
      end

      # Knock Off removes Leftovers/Black Sludge
      if move.id == :KNOCKOFF
        bonus += 20
      end

      # Setup moves: set up on passive walls
      if AdvancedAI.setup_move?(move.id)
        # Only if target is passive (wall/support)
        target_roles = AdvancedAI.detect_roles(target) rescue [:balanced]
        if target_roles.include?(:wall) || target_roles.include?(:stall) || target_roles.include?(:support)
          bonus += 20
          AdvancedAI.log("Stallbreaker: setup on passive #{target.name}: +20", "Strategy")
        end
      end

      # Trick/Switcheroo cripple walls with Choice items
      if [:TRICK, :SWITCHEROO].include?(move.id)
        user_item = user.respond_to?(:item_id) ? user.item_id : nil
        if AdvancedAI.choice_item?(user_item)
          bonus += 25  # Lock wall into one move
        end
      end

      # Super-effective wallbreaking moves
      if move.damagingMove? && move.power && move.power >= 100
        bonus += 10  # Raw power vs stall
      end
      bonus
    end

    #===========================================================================
    # #19 HAZARD STACKING ORDER
    # Dynamic hazard priority based on opponent team composition
    #===========================================================================
    def self.hazard_order_bonus(battle, user, move, target)
      return 0 unless move && user && target
      return 0 unless [:STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB].include?(move.id)

      bonus = 0
      opp_party = battle.pbParty((user.index + 1) % 2) rescue []

      case move.id
      when :TOXICSPIKES
        # Check if opponents are mostly Steel/Poison (immune to TSpikes)
        immune_count = opp_party.count do |pkmn|
          next false if !pkmn || pkmn.fainted? || pkmn.egg?
          types = pkmn.types rescue []
          types.include?(:STEEL) || types.include?(:POISON)
        end
        alive_count = opp_party.count { |p| p && !p.fainted? && !p.egg? }
        if alive_count > 0 && immune_count.to_f / alive_count >= 0.5
          bonus -= 30  # Half+ the team is immune
          AdvancedAI.log("TSpikes deprioritized: #{immune_count}/#{alive_count} immune", "Hazard")
        end

        # Check for Flying types / Levitate (not grounded)
        airborne_count = opp_party.count do |pkmn|
          next false if !pkmn || pkmn.fainted? || pkmn.egg?
          types = pkmn.types rescue []
          abilities = pkmn.respond_to?(:ability_id) ? [pkmn.ability_id] : []
          types.include?(:FLYING) || abilities.include?(:LEVITATE)
        end
        if alive_count > 0 && airborne_count.to_f / alive_count >= 0.5
          bonus -= 20  # Many fliers
        end

      when :STICKYWEB
        # Less valuable vs already-slow teams or Trick Room teams
        fast_count = opp_party.count do |pkmn|
          next false if !pkmn || pkmn.fainted? || pkmn.egg?
          base_speed = pkmn.respond_to?(:speed) ? pkmn.speed : 80
          base_speed >= 90  # Fast enough to benefit from speed drop
        end
        alive_count = opp_party.count { |p| p && !p.fainted? && !p.egg? }
        if alive_count > 0 && fast_count.to_f / alive_count < 0.3
          bonus -= 20  # Mostly slow team — Sticky Web less impactful
        end

        # Useless if TR is up
        if battle.field.effects[PBEffects::TrickRoom] > 0
          bonus -= 40  # Speed drop helps them in TR!
        end

      when :SPIKES
        # Less valuable if many fliers/levitators
        grounded_count = opp_party.count do |pkmn|
          next false if !pkmn || pkmn.fainted? || pkmn.egg?
          types = pkmn.types rescue []
          abilities = pkmn.respond_to?(:ability_id) ? [pkmn.ability_id] : []
          !types.include?(:FLYING) && !abilities.include?(:LEVITATE)
        end
        alive_count = opp_party.count { |p| p && !p.fainted? && !p.egg? }
        if alive_count > 0 && grounded_count.to_f / alive_count < 0.4
          bonus -= 20  # Most of team avoids Spikes
        end
      end
      bonus
    end

    #===========================================================================
    # #20 ALLY SWITCH AWARENESS + TR SETTER/SWEEPER COORDINATION (Doubles)
    #===========================================================================

    # Ally Switch: use strategically to dodge predicted attacks
    def self.ally_switch_bonus(battle, user, move, target, skill)
      return 0 unless move && move.id == :ALLYSWITCH
      return 0 unless battle.pbSideSize(0) > 1  # Doubles only

      bonus = 0
      partner = battle.allSameSideBattlers(user.index).find { |b| b && b != user && !b.fainted? }
      return 0 unless partner

      # Value: protect partner from predicted KO
      partner_hp_pct = partner.hp.to_f / partner.totalhp
      user_hp_pct = user.hp.to_f / user.totalhp

      if partner_hp_pct < 0.4 && user_hp_pct > 0.6
        bonus += 25  # Save low-HP partner by swapping positions
      end

      # Mind game value at high skill
      bonus += 10 if skill >= 85
      AdvancedAI.log("Ally Switch: +#{bonus}", "Doubles") if bonus > 0
      bonus
    end

    # Trick Room setter should Protect or sacrifice after setting TR
    def self.tr_setter_followup(battle, user, move, skill)
      return 0 unless battle && user && move && skill >= 70
      return 0 unless battle.pbSideSize(0) > 1  # Doubles only

      bonus = 0
      # If TR is active and we SET it (we're slow = TR setter)
      if battle.field.effects[PBEffects::TrickRoom] > 0
        our_speed = user.speed
        # Check if partner is the TR sweeper (slow, powerful)
        partner = battle.allSameSideBattlers(user.index).find { |b| b && b != user && !b.fainted? }
        if partner
          partner_speed = partner.respond_to?(:speed) ? partner.speed : 100
          # If we're faster than partner in TR (lower Speed = faster), we're the setter
          if our_speed > partner_speed
            # Setter should Protect to let sweeper act, or use support moves
            if move.id == :PROTECT || move.id == :BANEFULBUNKER || move.id == :SPIKYSHIELD
              bonus += 15  # Protect while sweeper attacks
            end
            # Helping Hand partner's sweep
            if move.id == :HELPINGHAND
              bonus += 20  # Boost the TR sweeper
            end
            # Self-sacrifice moves (Memento, Healing Wish)
            if [:MEMENTO, :HEALINGWISH, :LUNARDANCE].include?(move.id)
              bonus += 15  # Set up replacement
            end
          end
        end
      end
      bonus
    end

    #===========================================================================
    # #21 BOOSTER ENERGY SCORING
    # Paradox abilities (Protosynthesis/Quark Drive) + Booster Energy
    #===========================================================================
    PARADOX_ABILITIES = [:PROTOSYNTHESIS, :QUARKDRIVE]

    def self.booster_energy_bonus(user, move)
      return 0 unless user && move
      user_ability = user.respond_to?(:ability_id) ? user.ability_id : nil
      user_item = user.respond_to?(:item_id) ? user.item_id : nil
      return 0 unless PARADOX_ABILITIES.include?(user_ability)
      return 0 unless user_item == :BOOSTERENERGY

      # Booster Energy auto-activates the Paradox ability
      # → stat boost already active, so favor moves that leverage it
      bonus = 0
      # Determine which stat is boosted (highest stat)
      stats = {
        atk: user.respond_to?(:attack) ? user.attack : 0,
        spa: user.respond_to?(:spatk) ? user.spatk : 0,
        speed: user.respond_to?(:speed) ? user.speed : 0,
        def_stat: user.respond_to?(:defense) ? user.defense : 0,
        spd: user.respond_to?(:spdef) ? user.spdef : 0,
      }
      best_stat = stats.max_by { |_, v| v }.first

      case best_stat
      when :atk
        bonus += 10 if move.physicalMove?  # Leverage boosted Atk
      when :spa
        bonus += 10 if move.specialMove?   # Leverage boosted SpAtk
      when :speed
        bonus += 5  # Speed boost = outspeed more things
      end
      bonus
    end

    #===========================================================================
    # COMBINED SCORING — called from scoring pipeline
    #===========================================================================
    def self.tactical_score(battle, user, move, target, skill = 100)
      return 0 unless skill >= 50
      total = 0

      begin
        # Ability awareness (#1, #2, #3, #4, #6, #13, #14)
        if target
          total += magic_bounce_penalty(target, move)
          total += mold_breaker_bonus(user, target, move)
          total += sturdy_awareness(user, target, move)
          total += multiscale_awareness(user, target, move)
          total += focus_sash_awareness(user, target, move)
          total += guts_status_penalty(target, move)
          total += poison_heal_penalty(target, move)
          total += good_as_gold_penalty(target, move)
          total += disguise_iceface_awareness(user, target, move)
          total += trapping_ability_bonus(user, target, move)
        end

        # User-side item/ability bonuses (#6, #10, #11, #21)
        total += facade_guts_bonus(user, move)
        total += power_herb_bonus(user, move)
        total += white_herb_bonus(user, move)
        total += booster_energy_bonus(user, move)

        # Multi-turn planning (#9, #17)
        total += multi_turn_bonus(battle, user, move, target, skill) if skill >= 75
        total += belly_drum_eval(battle, user, move, target, skill) if move.id == :BELLYDRUM

        # Strategic (#15, #16, #18, #19)
        total += future_sight_bonus(battle, user, move, target) if target
        total += wish_proactive_bonus(battle, user, move) if move.id == :WISH
        total += stallbreaker_bonus(battle, user, move, target, skill) if target
        total += hazard_order_bonus(battle, user, move, target) if target

        # Doubles-specific (#8, #20)
        if battle.pbSideSize(0) > 1
          total += intimidate_cycle_bonus(battle, user, skill)
          total += ally_switch_bonus(battle, user, move, target, skill) if move.id == :ALLYSWITCH
          total += tr_setter_followup(battle, user, move, skill)
        end
      rescue => e
        AdvancedAI.log("[Tactical] Error: #{e.message}", "Tactical")
      end

      total
    end

    # Cleanup between battles
    def self.cleanup
      @sash_consumed = {}
    end
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.tactical_score(battle, user, move, target, skill = 100)
    TacticalEnhancements.tactical_score(battle, user, move, target, skill)
  end

  def self.mark_sash_consumed(battler_index)
    TacticalEnhancements.mark_sash_consumed(battler_index)
  end
end

#===============================================================================
# Integration in Battle::AI — Wires tactical enhancements into scoring pipeline
#===============================================================================
class Battle::AI
  def apply_tactical_enhancements(score, move, user, target, skill = 100)
    return score unless move && user
    begin
      real_user = user.respond_to?(:battler) ? user.battler : user
      real_target = target ? (target.respond_to?(:battler) ? target.battler : target) : nil
      bonus = AdvancedAI.tactical_score(@battle, real_user, move, real_target, skill)
      score += bonus if bonus && bonus != 0
    rescue => e
      AdvancedAI.log("[Tactical] Pipeline error: #{e.message}", "Tactical")
    end
    return score
  end
end

#===============================================================================
# Sash consumption tracking — hook into damage dealing
#===============================================================================
class Battle
  alias aai_tactical_cleanup_pbEndOfBattle pbEndOfBattle
  def pbEndOfBattle
    AdvancedAI::TacticalEnhancements.cleanup
    aai_tactical_cleanup_pbEndOfBattle
  end
end

AdvancedAI.log("Tactical Enhancements loaded", "Tactical")
AdvancedAI.log("  - #1 Magic Bounce in-battle penalty", "Tactical")
AdvancedAI.log("  - #2 Mold Breaker ability bypass", "Tactical")
AdvancedAI.log("  - #3 Sturdy multi-hit/chip awareness", "Tactical")
AdvancedAI.log("  - #4 Multiscale/Shadow Shield chip logic", "Tactical")
AdvancedAI.log("  - #5 Focus Sash consumption tracking", "Tactical")
AdvancedAI.log("  - #6 Guts/Facade/Poison Heal synergy", "Tactical")
AdvancedAI.log("  - #7 Trapping ability awareness", "Tactical")
AdvancedAI.log("  - #8 Intimidate cycling (Doubles)", "Tactical")
AdvancedAI.log("  - #9 Multi-turn look-ahead planning", "Tactical")
AdvancedAI.log("  - #10 Power Herb + charge moves", "Tactical")
AdvancedAI.log("  - #11 White Herb + Shell Smash synergy", "Tactical")
AdvancedAI.log("  - #12 Disguise/Ice Face form breaking", "Tactical")
AdvancedAI.log("  - #13 Status immunity abilities", "Tactical")
AdvancedAI.log("  - #14 Good as Gold full status immune", "Tactical")
AdvancedAI.log("  - #15 Future Sight + switch synergy", "Tactical")
AdvancedAI.log("  - #16 Wish proactive + Wish-pass", "Tactical")
AdvancedAI.log("  - #17 Belly Drum dedicated eval", "Tactical")
AdvancedAI.log("  - #18 Stall-breaker mode", "Tactical")
AdvancedAI.log("  - #19 Hazard stacking order", "Tactical")
AdvancedAI.log("  - #20 Ally Switch + TR coordination", "Tactical")
AdvancedAI.log("  - #21 Booster Energy scoring", "Tactical")

### FILE: Team_Preview_Intelligence.rb ###
#===============================================================================
# [017] Team Preview Intelligence - Optimal Lead Selection
#===============================================================================
# Selects optimal Lead based on Opponent Team (Team Preview)
#
# Features:
# - Lead Role Detection (Hazards, Fast Attacker, Weather Setter, etc.)
# - Matchup Analysis (which Lead is best?)
# - Anti-Lead Counter (Opponent has Fake Out? → Ghost Lead)
# - Team Synergy (Does Lead fit the rest of the team?)
#===============================================================================

module AdvancedAI
  module TeamPreviewIntelligence
    
    #===========================================================================
    # Lead Role Detection
    #===========================================================================
    
    LEAD_ROLES = {
      :hazard_lead => {
        description: "Sets Stealth Rock/Spikes",
        priority: 80,
        requires: [:hazard_moves, :decent_speed_or_focus_sash]
      },
      
      :weather_lead => {
        description: "Sets Weather for Team",
        priority: 85,
        requires: [:weather_ability_or_move, :team_benefits_from_weather]
      },
      
      :terrain_lead => {
        description: "Sets Terrain for Team",
        priority: 85,
        requires: [:terrain_ability_or_move, :team_benefits_from_terrain]
      },
      
      :fast_attacker => {
        description: "Fast Attacker for early pressure",
        priority: 70,
        requires: [:high_speed, :high_attack_or_spatk]
      },
      
      :fake_out_lead => {
        description: "Fake Out for Momentum",
        priority: 75,
        requires: [:fake_out_move]
      },
      
      :anti_lead => {
        description: "Counters typical Leads (Taunt, etc.)",
        priority: 75,
        requires: [:taunt_or_fast_attack, :high_speed]
      },
      
      :screen_setter => {
        description: "Sets Screens for Setup Sweepers",
        priority: 70,
        requires: [:screen_moves, :team_has_setup_sweepers]
      },
      
      :suicide_lead => {
        description: "Explosion/Hazards then dies",
        priority: 60,
        requires: [:explosion_or_hazards, :focus_sash_or_sturdy]
      }
    }
    
    #===========================================================================
    # Lead Selection
    #===========================================================================
    
    # Selects best Lead for Team
    def self.select_best_lead(battle, party, opponent_party)
      return 0 if !battle || !party || party.empty?
      
      best_lead_index = 0
      best_score = 0
      
      party.each_with_index do |pokemon, i|
        next if !pokemon || pokemon.fainted? || pokemon.egg?
        
        score = evaluate_lead(battle, pokemon, party, opponent_party)
        
        if score > best_score
          best_score = score
          best_lead_index = i
        end
      end
      
      AdvancedAI.log("[Team Preview] Best lead: #{party[best_lead_index].name} (Score: #{best_score})", :team_preview)
      return best_lead_index
    end
    
    # Evaluates Pokemon as Lead
    def self.evaluate_lead(battle, pokemon, party, opponent_party)
      return 0 if !pokemon
      
      score = 50  # Base score
      
      # 1. Lead Role Detection
      roles = detect_lead_roles(pokemon, party)
      roles.each do |role|
        score += LEAD_ROLES[role][:priority] if LEAD_ROLES.key?(role)
      end
      
      # 2. Matchup vs Opponent Team
      if opponent_party
        matchup_score = analyze_matchups(pokemon, opponent_party)
        score += matchup_score
      end
      
      # 3. Speed Tier (faster = better as Lead)
      if pokemon.speed >= 100
        score += 20
      elsif pokemon.speed >= 80
        score += 10
      elsif pokemon.speed < 50
        score -= 15  # Slow = worse Lead
      end
      
      # 4. Item Synergy
      item = pokemon.item_id
      if item
        score += 15 if item == :FOCUSSASH      # Survivability
        score += 10 if item == :HEATROCK       # Weather extend
        score += 10 if item == :DAMPROCK
        score += 10 if item == :SMOOTHROCK
        score += 10 if item == :ICYROCK
        score += 12 if item == :LIGHTCLAY      # Screen extend
        score -= 10 if item == :CHOICEBAND     # Locked = risky as Lead
        score -= 10 if item == :CHOICESPECS
      end
      
      # 5. Hazard Immunity (party Pokemon uses ability_id)
      if pokemon.hasType?(:FLYING) || pokemon.ability_id == :LEVITATE
        score += 8  # Partially immune to Stealth Rock/Spikes
      end
      
      if pokemon.item_id == :HEAVYDUTYBOOTS
        score += 12  # Full Hazard Immunity
      end
      
      # 6. Anti-Lead Capabilities
      pokemon.moves.each do |move|
        next if !move
        
        case move.id
        when :TAUNT
          score += 25  # Stops Hazard Leads
        when :FAKEOUT
          score += 20  # Momentum control
        when :MAGICCOAT
          score += 15  # Reflects hazards
        when :RAPIDSPIN, :DEFOG
          score += 10  # Can remove Hazards
        end
      end
      
      return score
    end
    
    #===========================================================================
    # Lead Role Detection for Pokemon
    #===========================================================================
    
    def self.detect_lead_roles(pokemon, party)
      return [] if !pokemon
      
      roles = []
      
      # Hazard Lead
      has_hazards = pokemon.moves.any? { |m| m && AdvancedAI.hazard_move?(m.id) }
      if has_hazards
        roles << :hazard_lead
      end
      
      # Weather Lead
      weather_ability = [:DROUGHT, :DRIZZLE, :SANDSTREAM, :SNOWWARNING].include?(pokemon.ability)
      weather_move = pokemon.moves.any? { |m| m && [:SUNNYDAY, :RAINDANCE, :SANDSTORM, :HAIL, :SNOWSCAPE].include?(m.id) }
      if weather_ability || weather_move
        # Check if team benefits
        team_benefits = party.any? { |p| p && AdvancedAI.benefits_from_weather?(p, get_weather_type(pokemon)) }
        roles << :weather_lead if team_benefits
      end
      
      # Terrain Lead
      terrain_ability = [:ELECTRICSURGE, :GRASSYSURGE, :MISTYSURGE, :PSYCHICSURGE].include?(pokemon.ability)
      terrain_move = pokemon.moves.any? { |m| m && [:ELECTRICTERRAIN, :GRASSYTERRAIN, :MISTYTERRAIN, :PSYCHICTERRAIN].include?(m.id) }
      if terrain_ability || terrain_move
        team_benefits = party.any? { |p| p && AdvancedAI.benefits_from_terrain?(p, get_terrain_type(pokemon)) }
        roles << :terrain_lead if team_benefits
      end
      
      # Fast Attacker
      if pokemon.speed >= 100 && (pokemon.attack >= 100 || pokemon.spatk >= 100)
        roles << :fast_attacker
      end
      
      # Fake Out Lead
      if pokemon.moves.any? { |m| m && m.id == :FAKEOUT }
        roles << :fake_out_lead
      end
      
      # Anti-Lead
      has_taunt = pokemon.moves.any? { |m| m && m.id == :TAUNT }
      if has_taunt && pokemon.speed >= 90
        roles << :anti_lead
      end
      
      # Screen Setter
      has_screens = pokemon.moves.any? { |m| m && [:LIGHTSCREEN, :REFLECT, :AURORAVEIL].include?(m.id) }
      team_has_sweepers = party.any? { |p| p && AdvancedAI.detect_roles(p).include?(:sweeper) }
      if has_screens && team_has_sweepers
        roles << :screen_setter
      end
      
      # Suicide Lead (party Pokemon uses ability_id)
      has_explosion = pokemon.moves.any? { |m| m && [:EXPLOSION, :SELFDESTRUCT].include?(m.id) }
      has_sturdy = pokemon.ability_id == :STURDY || pokemon.item_id == :FOCUSSASH
      if (has_explosion || has_hazards) && has_sturdy
        roles << :suicide_lead
      end
      
      return roles
    end
    
    #===========================================================================
    # Matchup Analysis
    #===========================================================================
    
    # Analyzes Matchups against Opponent Team
    def self.analyze_matchups(pokemon, opponent_party)
      return 0 if !pokemon || !opponent_party
      
      score = 0
      favorable_matchups = 0
      unfavorable_matchups = 0
      
      opponent_party.each do |opp|
        next if !opp || opp.egg?
        
        # Type Matchup
        matchup = calculate_type_matchup(pokemon, opp)
        
        if matchup > 1.2
          favorable_matchups += 1
          score += 15
        elsif matchup < 0.8
          unfavorable_matchups += 1
          score -= 10
        end
      end
      
      # Bonus if many favorable
      score += 20 if favorable_matchups >= 3
      
      # Penalty if many unfavorable
      score -= 15 if unfavorable_matchups >= 3
      
      return score
    end
    
    # Calculates Type-Matchup Score
    def self.calculate_type_matchup(attacker, defender)
      return 1.0 if !attacker || !defender
      
      total_multiplier = 1.0
      move_count = 0
      
      attacker.moves.each do |move|
        next if !move || move.category == :Status
        
        effectiveness = Effectiveness.calculate(move.type, defender.type1, defender.type2)
        # Effectiveness.calculate already returns the multiplier directly
        multiplier = effectiveness.to_f / Effectiveness::NORMAL_EFFECTIVE_MULTIPLIER.to_f
        
        total_multiplier += multiplier
        move_count += 1
      end
      
      return move_count > 0 ? total_multiplier / move_count : 1.0
    end
    
    #===========================================================================
    # Anti-Lead Logic
    #===========================================================================
    
    # Counters typical Hazard Leads
    def self.counter_hazard_lead(pokemon, opponent_party)
      return 0 if !pokemon || !opponent_party
      
      # Check if opponent likely has Hazard Lead
      opponent_has_hazard_lead = opponent_party.any? do |opp|
        next false if !opp
        opp.moves.any? { |m| m && AdvancedAI.hazard_move?(m.id) }
      end
      
      return 0 if !opponent_has_hazard_lead
      
      score = 0
      
      # Taunt = perfect Counter (+40)
      if pokemon.moves.any? { |m| m && m.id == :TAUNT }
        score += 40
      end
      
      # Magic Coat (+35)
      if pokemon.moves.any? { |m| m && m.id == :MAGICCOAT }
        score += 35
      end
      
      # Fast Attack (+20)
      if pokemon.speed >= 100
        score += 20
      end
      
      # Magic Bounce Ability (+45)
      if pokemon.ability == :MAGICBOUNCE
        score += 45
      end
      
      return score
    end
    
    #===========================================================================
    # Helper Methods
    #===========================================================================
    
    def self.get_weather_type(pokemon)
      return nil if !pokemon
      
      # Party Pokemon uses ability_id
      case pokemon.ability_id
      when :DROUGHT then return :sun
      when :DRIZZLE then return :rain
      when :SANDSTREAM then return :sandstorm
      when :SNOWWARNING then return :hail
      end
      
      pokemon.moves.each do |move|
        next if !move
        case move.id
        when :SUNNYDAY then return :sun
        when :RAINDANCE then return :rain
        when :SANDSTORM then return :sandstorm
        when :HAIL, :SNOWSCAPE then return :hail
        end
      end
      
      return nil
    end
    
    def self.get_terrain_type(pokemon)
      return nil if !pokemon
      
      case pokemon.ability
      when :ELECTRICSURGE then return :electric
      when :GRASSYSURGE then return :grassy
      when :MISTYSURGE then return :misty
      when :PSYCHICSURGE then return :psychic
      end
      
      pokemon.moves.each do |move|
        next if !move
        case move.id
        when :ELECTRICTERRAIN then return :electric
        when :GRASSYTERRAIN then return :grassy
        when :MISTYTERRAIN then return :misty
        when :PSYCHICTERRAIN then return :psychic
        end
      end
      
      return nil
    end
    
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.select_best_lead(battle, party, opponent_party = nil)
    TeamPreviewIntelligence.select_best_lead(battle, party, opponent_party)
  end
  
  def self.detect_lead_roles(pokemon, party)
    TeamPreviewIntelligence.detect_lead_roles(pokemon, party)
  end
end

### FILE: Threat_Assessment.rb ###
#===============================================================================
# Advanced AI System - Threat Assessment
# Evaluates Threat Level based on Stats, Moves, Abilities, Items
#===============================================================================

module AdvancedAI
  module ThreatAssessment
    # Main Function: Assess Threat (0-10 Scale)
    def self.assess_threat(battle, attacker, opponent, skill_level = 100)
      return 5 unless battle && attacker && opponent && !opponent.fainted?
      
      threat = 5.0  # Base threat
      
      # 1. STAT-BASED THREAT (0-2.5)
      threat += assess_stat_threat(attacker, opponent)
      
      # 2. TYPE MATCHUP THREAT (0-2.0)
      threat += assess_type_threat(attacker, opponent)
      
      # 3. MOVE-BASED THREAT (0-2.0)
      if skill_level >= 50
        threat += assess_move_threat(battle, attacker, opponent)
      end
      
      # 4. ABILITY-BASED THREAT (0-1.5)
      if skill_level >= 60
        threat += assess_ability_threat(attacker, opponent)
      end
      
      # 5. HP-BASED MODIFIER (x0.3 - x1.2)
      threat *= assess_hp_modifier(opponent)
      
      # 6. SETUP THREAT (0-1.5)
      if skill_level >= 55
        threat += assess_setup_threat(opponent)
      end
      
      # 7. SPEED THREAT (0-1.0)
      threat += assess_speed_threat(attacker, opponent)
      
      return [[threat, 0].max, 10].min  # Clamp 0-10
    end
    
    private
    
    # Stat-based Threat
    def self.assess_stat_threat(attacker, opponent)
      threat = 0.0
      
      # Offensive Stats
      if opponent.attack > attacker.defense * 1.5
        threat += 1.0
      elsif opponent.attack > attacker.defense
        threat += 0.5
      end
      
      if opponent.spatk > attacker.spdef * 1.5
        threat += 1.0
      elsif opponent.spatk > attacker.spdef
        threat += 0.5
      end
      
      return [threat, 2.5].min
    end
    
    # Type Matchup Threat
    def self.assess_type_threat(attacker, opponent)
      threat = 0.0
      
      # Check Opponent's Type Advantage
      opponent_types = opponent.pbTypes(true)
      attacker_types = attacker.pbTypes(true)
      
      opponent_types.each do |opp_type|
        attacker_types.each do |att_type|
          effectiveness = Effectiveness.calculate(opp_type, att_type, nil)
          
          if Effectiveness.super_effective?(effectiveness)
            threat += 1.0
          elsif Effectiveness.not_very_effective?(effectiveness)
            threat -= 0.5
          elsif Effectiveness.ineffective?(effectiveness)
            threat -= 1.0
          end
        end
      end
      
      return [threat, 2.0].min
    end
    
    # Move-based Threat
    def self.assess_move_threat(battle, attacker, opponent)
      threat = 0.0
      memory = AdvancedAI::MoveMemory.get_memory(battle, opponent)
      
      # Analyze Known Moves
      if memory[:moves]
        memory[:moves].each do |move_id|
          move_data = GameData::Move.get(move_id)
          
          # Priority Moves
          threat += 0.5 if move_data.priority > 0
          
          # Super Effective Coverage
          if move_data.damaging?
            attacker_types = attacker.pbTypes(true)
            attacker_types.each do |type|
              effectiveness = Effectiveness.calculate(move_data.type, type, nil)
              threat += 0.8 if Effectiveness.super_effective?(effectiveness)
            end
          end
          
          # OHKO Moves
          threat += 1.0 if [:GUILLOTINE, :FISSURE, :SHEERCOLD, :HORNDRILL].include?(move_id)
          
          # Setup Moves
          threat += 0.3 if move_data.function_code.start_with?("RaiseUser")
        end
      end
      
      # Max Known Damage
      max_damage = AdvancedAI::MoveMemory.max_known_damage(battle, opponent, attacker)
      if max_damage > attacker.hp * 0.8
        threat += 1.0
      elsif max_damage > attacker.hp * 0.5
        threat += 0.5
      end
      
      return [threat, 2.0].min
    end
    
    # Ability-based Threat
    def self.assess_ability_threat(attacker, opponent)
      threat = 0.0
      ability = opponent.ability_id
      
      return 0.0 unless ability
      
      # === Mold Breaker Family (ignores defensive abilities) ===
      if [:MOLDBREAKER, :TURBOBLAZE, :TERAVOLT].include?(ability)
        # Extra dangerous against Wonder Guard, Multiscale, etc.
        if [:WONDERGUARD, :MULTISCALE, :STURDY, :MAGICGUARD, :LEVITATE].include?(attacker.ability_id)
          threat += 1.5  # Bypasses our protection
        else
          threat += 0.4
        end
      end
      
      # Mycelium Might (ignores abilities for status moves)
      if ability == :MYCELIUMMIGHT
        threat += 0.3
      end
      
      # Extreme Offensive Abilities
      if [:HUGEPOWER, :PUREPOWER, :PARENTALBOND, :GORILLATACTICS, :PROTOSYNTHESIS, :QUARKDRIVE].include?(ability)
        threat += 1.5
      end
      
      # Strong Offensive Abilities
      if [:ADAPTABILITY, :SHEERFORCE, :TECHNICIAN, :SKILLLINK, :STRONGJAW, :TOUGHCLAWS, :SHARPNESS].include?(ability)
        threat += 0.8
      end
      
      # === Gen 9 Offensive Abilities ===
      if ability == :SUPREMEOVERLORD
        # Scales with fainted allies - dangerous late game
        threat += 0.6
      end
      
      if ability == :ORICHALCUMPULSE
        threat += 0.7  # Sets Sun + boosts Attack
      end
      
      if ability == :HADRONENGINE
        threat += 0.7  # Sets Electric Terrain + boosts SpAtk
      end
      
      if ability == :TOXICCHAIN
        threat += 0.5  # 30% Toxic chance on all moves
      end
      
      if ability == :ROCKYPAYLOAD
        threat += 0.4  # Rock-type boost
      end
      
      # Priority Abilities
      if [:GALEWINGS, :PRANKSTER, :QUICKDRAW].include?(ability)
        threat += 0.6
      end
      
      # === Gen 9 Priority Blockers ===
      if ability == :ARMORTAIL
        # Blocks priority moves - threat if we rely on priority
        if attacker.moves&.any? { |m| m && m.priority > 0 }
          threat += 0.5  # Counters our strategy
        end
      end
      
      # Speed Boost
      if [:SPEEDBOOST, :UNBURDEN, :MOTORDRIVE].include?(ability)
        threat += 0.5
      end
      
      # Defensive Abilities (reduce offensive threat, but make opponent hard to kill)
      if [:WONDERGUARD, :MULTISCALE, :REGENERATOR, :MAGICBOUNCE].include?(ability)
        threat += 0.3
      end
      
      # === Gen 9 Defensive Abilities ===
      if ability == :GOODASGOLD
        # Immune to status moves - major defensive threat
        threat += 0.4
      end
      
      if ability == :PURIFYINGSALT
        # Status immune + Ghost resist
        threat += 0.3
      end
      
      if ability == :GUARDDOG
        # Immune to Intimidate + Attack boost on switch-in attempts
        threat += 0.3
      end
      
      if ability == :WINDRIDER
        # Immune to Tailwind/wind moves + Attack boost
        threat += 0.3
      end
      
      if [:WELLBAKEDBODY, :EARTHEATER].include?(ability)
        # Fire/Ground immunity + stat boost
        threat += 0.2
      end
      
      return [threat, 2.0].min  # Raised cap for all the new abilities
    end
    
    # HP Modifier
    def self.assess_hp_modifier(opponent)
      hp_percent = opponent.hp.to_f / opponent.totalhp
      
      if hp_percent < 0.2
        return 0.3  # Almost fainted
      elsif hp_percent < 0.4
        return 0.6
      elsif hp_percent < 0.6
        return 0.8
      elsif hp_percent > 0.9
        return 1.2  # Full Power
      else
        return 1.0
      end
    end
    
    # Setup Threat
    def self.assess_setup_threat(opponent)
      threat = 0.0
      
      # Stat Boosts
      [:ATTACK, :SPECIAL_ATTACK, :SPEED].each do |stat|
        stage = opponent.stages[stat]
        threat += stage * 0.3 if stage > 0
      end
      
      return [threat, 1.5].min
    end
    
    # Speed Threat
    def self.assess_speed_threat(attacker, opponent)
      return 0.0 if opponent.pbSpeed <= attacker.pbSpeed
      
      speed_ratio = opponent.pbSpeed.to_f / attacker.pbSpeed
      
      if speed_ratio > 2.0
        return 1.0
      elsif speed_ratio > 1.5
        return 0.7
      else
        return 0.4
      end
    end
    
    public
    
    # Finds most threatening opponent
    def self.most_threatening_opponent(battle, attacker, skill_level = 100)
      return nil unless battle && attacker
      
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      return nil if opponents.empty?
      
      threats = opponents.map do |opp|
        [opp, assess_threat(battle, attacker, opp, skill_level)]
      end
      
      threats.max_by { |opp, threat| threat }&.first
    end
    
    # Prioritizes Target in Doubles
    def self.priority_target(battle, attacker, opp1, opp2, skill_level = 100)
      return opp1 unless opp2
      return opp2 unless opp1
      
      threat1 = assess_threat(battle, attacker, opp1, skill_level)
      threat2 = assess_threat(battle, attacker, opp2, skill_level)
      
      AdvancedAI.log("#{opp1.pbThis}: #{threat1.round(2)} threat vs #{opp2.pbThis}: #{threat2.round(2)} threat", "Threat")
      
      threat1 >= threat2 ? opp1 : opp2
    end
  end
end

# API-Wrapper
module AdvancedAI
  def self.assess_threat(battle, attacker, opponent, skill_level = 100)
    ThreatAssessment.assess_threat(battle, attacker, opponent, skill_level)
  end
  
  def self.most_threatening_opponent(battle, attacker, skill_level = 100)
    ThreatAssessment.most_threatening_opponent(battle, attacker, skill_level)
  end
  
  def self.priority_target(battle, attacker, opp1, opp2, skill_level = 100)
    ThreatAssessment.priority_target(battle, attacker, opp1, opp2, skill_level)
  end
end

# Integration in Battle::AI
class Battle::AI
  def apply_threat_assessment(score, move, user, target)
    skill = @trainer&.skill || 100
    return score unless AdvancedAI.feature_enabled?(:core, skill)
    return score unless target
    
    # user is AIBattler, need real battler for threat assessment
    real_user = user.respond_to?(:battler) ? user.battler : user
    real_target = target.respond_to?(:battler) ? target.battler : target
    
    threat = AdvancedAI.assess_threat(@battle, real_user, real_target, skill)
    
    # Higher Threat = Higher Score for Attack
    if move.damagingMove?
      score += (threat * 5).to_i  # 0-50 Points
    end
    
    # Low Threat = Consider Switch
    if threat < 3.0 && skill >= 50
      score -= 15  # Other targets more attractive
    end
    
    return score
  end
end

AdvancedAI.log("Threat Assessment System loaded", "Threat")

### FILE: Doubles_Coordination.rb ###
#===============================================================================
# Advanced AI System - Doubles Coordination
# Partner Synergy, Overkill Prevention, Spread Move Optimization
#===============================================================================

module AdvancedAI
  module DoublesCoordination
    # Prevents Overkill (both partners attack weak target)
    def self.prevent_overkill(battle, attacker, target, skill_level = 100)
      return 0 unless skill_level >= 50
      return 0 unless battle.pbSideSize(0) > 1  # Doubles/Triples only
      return 0 unless target
      
      partner = find_partner(battle, attacker)
      return 0 unless partner
      
      # Check if partner is also targeting this battler
      partner_targeting_same = partner_targets?(battle, partner, target)
      return 0 unless partner_targeting_same
      
      # If target is already weak
      hp_percent = target.hp.to_f / target.totalhp
      if hp_percent < 0.3
        return -40  # Switch target to avoid overkill
      elsif hp_percent < 0.5
        return -20
      end
      
      0
    end
    
    # Prevents Move Conflicts (both use same Setup/Support Move)
    def self.prevent_move_conflicts(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 50
      return 0 unless battle.pbSideSize(0) > 1
      
      partner = find_partner(battle, attacker)
      return 0 unless partner
      
      # Both want to set Screens
      if [:REFLECT, :LIGHTSCREEN, :AURORAVEIL].include?(move.id)
        return -60  # One is enough
      end
      
      # Both want to set Hazards
      if [:STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB].include?(move.id)
        return -50
      end
      
      # Both want to set Weather
      if [:SUNNYDAY, :RAINDANCE, :SANDSTORM, :HAIL, :SNOWSCAPE].include?(move.id)
        return -40
      end
      
      0
    end
    
    # Optimizes Spread Moves (Earthquake, etc.)
    def self.optimize_spread_moves(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless battle.pbSideSize(0) > 1
      return 0 unless move.pbTarget(attacker).num_targets > 1
      
      score = 0
      partner = find_partner(battle, attacker)
      
      # === SPREAD MOVE DAMAGE REDUCTION ===
      # In doubles, spread moves deal 75% damage to each target
      # This makes single-target moves relatively more valuable per target
      score -= 8  # Small penalty for reduced damage per target
      
      # Penalty if Partner is hit
      if partner && hits_partner?(move, attacker, partner)
        # Check Immunity/Resistance
        type_mod = Effectiveness.calculate(move.type, *partner.pbTypes(true))
        
        if Effectiveness.ineffective?(type_mod)
          score += 30  # Partner immune → very good!
        elsif Effectiveness.not_very_effective?(type_mod)
          score += 15  # Partner resists
        else
          score -= 40  # Hits Partner hard
        end
      end
      
      # Bonus if multiple enemies are hit
      enemies_hit = count_enemies_hit(battle, attacker, move)
      score += enemies_hit * 20
      
      score
    end
    
    # Coordinates Field Effects (no Weather override)
    def self.coordinate_field_effects(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 70
      return 0 unless battle.pbSideSize(0) > 1
      
      score = 0
      partner = find_partner(battle, attacker)
      return 0 unless partner
      
      # Weather Coordination
      if move.function_code.include?("Weather")
        # Check Partner Ability
        partner_ability = partner.ability_id
        
        if move.id == :RAINDANCE && [:SWIFTSWIM, :DRIZZLE].include?(partner_ability)
          score += 40  # Partner benefits
        elsif move.id == :SUNNYDAY && [:CHLOROPHYLL, :DROUGHT].include?(partner_ability)
          score += 40
        elsif move.id == :SANDSTORM && [:SANDRUSH, :SANDSTREAM].include?(partner_ability)
          score += 40
        elsif move.id == :HAIL && [:SLUSHRUSH, :SNOWWARNING].include?(partner_ability)
          score += 40
        end
      end
      
      # Terrain Coordination
      if move.function_code.include?("Terrain")
        partner_ability = partner.ability_id
        
        if move.id == :ELECTRICTERRAIN && [:SURGESURFER].include?(partner_ability)
          score += 35
        elsif move.id == :GRASSYTERRAIN && partner.pbHasType?(:GRASS)
          score += 25
        elsif move.id == :PSYCHICTERRAIN && [:PSYCHICSURGE].include?(partner_ability)
          score += 35
        end
      end
      
      score
    end
    
    # Protect + Setup Combo
    def self.protect_setup_combo(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 65
      return 0 unless battle.pbSideSize(0) > 1
      
      partner = find_partner(battle, attacker)
      return 0 unless partner
      
      # If Partner is setting up, use Protect
      if move.id == :PROTECT || move.id == :DETECT
        partner_setup = partner.moves.any? { |m| m && m.stat_up.any? }
        return 50 if partner_setup && partner.hp > partner.totalhp * 0.7
      end
      
      0
    end
    
    #===========================================================================
    # Protective Moves for Doubles (Wide Guard, Quick Guard)
    #===========================================================================
    module ProtectiveMovesDoubles
      # List of common spread moves that hit multiple targets
      SPREAD_MOVES = [
        :EARTHQUAKE, :SURF, :ROCKSLIDE, :DISCHARGE, :LAVAPLUME,
        :BLIZZARD, :HEATWAVE, :MUDDYWATER, :RAZORLEAF, :ICICLESPEAR,
        :BULLDOZE, :SNARL, :GLACIATE, :ORIGINPULSE, :PRECIPICEBLADES,
        :DIAMONDSTORM, :PARABOLICCHARGE, :DAZZLINGGLEAM, :EXPLOSION,
        :SELFDESTRUCT, :MAGNITUDE, :BOOMBURST, :HYPERVOICE, :SLUDGEWAVE
      ]
      
      # List of priority moves that Quick Guard blocks
      PRIORITY_MOVES = [
        :FAKEOUT, :AQUAJET, :MACHPUNCH, :BULLETPUNCH, :ICESHARD,
        :SHADOWSNEAK, :VACUUMWAVE, :QUICKATTACK, :EXTREMESPEED,
        :ACCELEROCK, :FIRSTIMPRESSION, :WATERSHURIKEN, :SUCKERPUNCH,
        :JETPUNCH, :GRASSYGLIDE, :THUNDERCLAP
      ]
      
      # Predicts if opponent is likely to use a spread move
      def self.predict_spread_moves(battle, attacker)
        return [] unless battle.pbSideSize(0) > 1
        
        predicted_moves = []
        battle.allOtherSideBattlers(attacker.index).each do |opponent|
          next unless opponent && !opponent.fainted?
          
          opponent.moves.each do |move|
            next unless move
            # Check if move is a known spread move
            if SPREAD_MOVES.include?(move.id)
              predicted_moves << move.id
            # Or check if move targets multiple Pokémon
            elsif move.pbTarget(opponent).num_targets > 1
              predicted_moves << move.id
            end
          end
        end
        
        predicted_moves.uniq
      end
      
      # Predicts if opponent is likely to use a priority move
      def self.predict_priority_moves(battle, attacker)
        return [] unless battle.pbSideSize(0) > 1
        
        predicted_moves = []
        battle.allOtherSideBattlers(attacker.index).each do |opponent|
          next unless opponent && !opponent.fainted?
          
          opponent.moves.each do |move|
            next unless move
            if PRIORITY_MOVES.include?(move.id) || move.priority > 0
              predicted_moves << move.id
            end
          end
        end
        
        predicted_moves.uniq
      end
      
      # Evaluates Wide Guard usage
      def self.evaluate_wide_guard(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :WIDEGUARD
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        
        # Predict if opponents have spread moves
        predicted_spread = predict_spread_moves(battle, attacker)
        
        if predicted_spread.empty?
          return -30  # No spread moves predicted, don't waste turn
        end
        
        # Base bonus for having spread moves
        score += 40
        
        # Check if partner is weak to predicted spread moves
        if partner
          predicted_spread.each do |move_id|
            move_data = GameData::Move.try_get(move_id)
            next unless move_data
            
            type_mod = Effectiveness.calculate(move_data.type, partner.types[0], partner.types[1])
            
            if Effectiveness.super_effective?(type_mod)
              score += 30  # Partner is weak to this spread move!
            elsif Effectiveness.not_very_effective?(type_mod)
              score += 10  # Still good to protect
            end
          end
        end
        
        # Bonus if multiple allies present (Triples)
        allies_count = battle.allSameSideBattlers(attacker.index).count { |b| b && !b.fainted? }
        score += (allies_count - 1) * 15
        
        # Check if Wide Guard was recently used (avoid spamming)
        if attacker.effects[PBEffects::ProtectRate] > 1
          score -= 40  # Protect-like moves have diminishing returns
        end
        
        score
      end
      
      # Evaluates Quick Guard usage
      def self.evaluate_quick_guard(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :QUICKGUARD
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        
        # Predict if opponents have priority moves
        predicted_priority = predict_priority_moves(battle, attacker)
        
        if predicted_priority.empty?
          return -30  # No priority moves predicted
        end
        
        # Base bonus
        score += 35
        
        # Higher priority if partner is low HP (vulnerable to priority)
        if partner && partner.hp < partner.totalhp * 0.4
          score += 40
        end
        
        # Fake Out is especially dangerous Turn 1
        if battle.turnCount == 0 && predicted_priority.include?(:FAKEOUT)
          score += 50
        end
        
        # Check protect rate
        if attacker.effects[PBEffects::ProtectRate] > 1
          score -= 35
        end
        
        score
      end
    end
    
    #===========================================================================
    # Redirection Strategies (Follow Me, Rage Powder)
    #===========================================================================
    module RedirectionStrategies
      # Detects if partner is using a setup move
      def self.partner_is_setting_up?(partner)
        return false unless partner
        
        # Check if partner has setup moves
        setup_moves = [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :CALMMIND,
                       :BULKUP, :AGILITY, :ROCKPOLISH, :QUIVERDANCE,
                       :SHELLSMASH, :GEOMANCY, :GROWTH, :WORKUP]
        
        partner.moves.any? { |m| m && setup_moves.include?(m.id) }
      end
      
      # Checks if user is a good redirector (high defenses)
      def self.good_redirector?(attacker)
        return false unless attacker
        
        # Check defensive stats
        def_stat = attacker.defense
        spdef_stat = attacker.spdef
        hp_stat = attacker.hp
        
        # Good redirector has high HP and defenses
        total_bulk = def_stat + spdef_stat + (hp_stat / 2)
        return total_bulk > 300  # Arbitrary threshold
      end
      
      # Evaluates Follow Me usage
      def self.evaluate_follow_me(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :FOLLOWME || move.id == :RAGEPOWDER
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        # Check for Ghost-type opponents (Follow Me doesn't work on them)
        if move.id == :FOLLOWME
          ghost_opponents = battle.allOtherSideBattlers(attacker.index).any? do |opp|
            opp && !opp.fainted? && opp.pbHasType?(:GHOST)
          end
          score -= 50 if ghost_opponents
        end
        
        # High priority if partner is setting up
        if partner_is_setting_up?(partner)
          score += 70
          # Even higher if partner is healthy
          if partner.hp > partner.totalhp * 0.7
            score += 20
          end
        end
        
        # Protect low HP partner
        if partner.hp < partner.totalhp * 0.3
          score += 60
        elsif partner.hp < partner.totalhp * 0.5
          score += 30
        end
        
        # Bonus if user is bulky (good redirector)
        if good_redirector?(attacker)
          score += 25
        end
        
        # Bonus if user has high HP
        if attacker.hp > attacker.totalhp * 0.8
          score += 20
        end
        
        # Penalty if already used recently (can't spam)
        if attacker.effects[PBEffects::FollowMe] > 0
          score -= 80
        end
        
        score
      end
      
      # Evaluates Rage Powder usage (similar to Follow Me but Grass-type)
      def self.evaluate_rage_powder(battle, attacker, move, skill_level = 100)
        # Rage Powder is essentially Follow Me for Grass-types
        # Use the same logic but check for Grass immunities
        return 0 unless move.id == :RAGEPOWDER
        
        score = evaluate_follow_me(battle, attacker, move, skill_level)
        
        # Check for Grass-type opponents or Overcoat ability (immune to powder)
        immune_opponents = battle.allOtherSideBattlers(attacker.index).any? do |opp|
          next false unless opp && !opp.fainted?
          opp.pbHasType?(:GRASS) || opp.ability_id == :OVERCOAT
        end
        
        score -= 40 if immune_opponents
        
        score
      end
      
      # Determines if partner should be protected
      def self.should_protect_partner?(battle, attacker, partner)
        return false unless partner
        
        # Protect if partner is setting up
        return true if partner_is_setting_up?(partner)
        
        # Protect if partner is low HP
        return true if partner.hp < partner.totalhp * 0.4
        
        # Protect if partner is a sweeper (high offensive stats)
        if partner.attack > 120 || partner.spatk > 120
          return true
        end
        
        false
      end
    end
    
    #===========================================================================
    # Fake Out & Protect Coordination
    #===========================================================================
    
    # Evaluates Fake Out in doubles context
    def self.evaluate_fake_out(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless battle.pbSideSize(0) > 1
      return 0 unless move.id == :FAKEOUT
      
      score = 0
      
      # Fake Out only works on Turn 1 or when just switched in
      if battle.turnCount == 0 || attacker.turnCount == 0
        score += 50  # Strong bonus for Turn 1
      else
        return -80  # Fake Out fails if not Turn 1
      end
      
      # Target threats to partner
      partner = find_partner(battle, attacker)
      if partner && target
        # Check if target is a threat to partner
        target.moves.each do |target_move|
          next unless target_move
          
          type_mod = Effectiveness.calculate(target_move.type, partner.types[0], partner.types[1])
          if Effectiveness.super_effective?(type_mod)
            score += 30  # Target threatens partner!
          end
        end
        
        # Prioritize disrupting setup sweepers
        setup_moves = [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :SHELLSMASH]
        if target.moves.any? { |m| m && setup_moves.include?(m.id) }
          score += 40
        end
      end
      
      # Avoid if partner is also using Fake Out (coordination)
      if partner && partner.moves.any? { |m| m && m.id == :FAKEOUT }
        score -= 30  # Don't both use Fake Out
      end
      
      score
    end
    
    # Enhanced Protect evaluation for doubles
    def self.evaluate_protect_doubles(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 65
      return 0 unless battle.pbSideSize(0) > 1
      return 0 unless [:PROTECT, :DETECT, :KINGSSHIELD, :SPIKYSHIELD, :BANEFULBUNKER].include?(move.id)
      
      score = 0
      partner = find_partner(battle, attacker)
      
      # Protect while partner uses spread move that hits allies
      if partner
        partner.moves.each do |partner_move|
          next unless partner_move
          
          # Check if partner's move hits allies
          if hits_partner?(partner_move, partner, attacker)
            # Check if we're weak to it
            type_mod = Effectiveness.calculate(partner_move.type, attacker.types[0], attacker.types[1])
            
            if !Effectiveness.ineffective?(type_mod)
              score += 55  # Protect from partner's spread move!
            end
          end
        end
        
        # Protect while partner sets up
        if RedirectionStrategies.partner_is_setting_up?(partner)
          score += 50
        end
      end
      
      # Alternate Protect usage (don't spam)
      if attacker.effects[PBEffects::ProtectRate] > 1
        score -= 60  # Diminishing returns
      end
      
      # Protect when predicting opponent's spread move
      predicted_spread = ProtectiveMovesDoubles.predict_spread_moves(battle, attacker)
      if !predicted_spread.empty?
        score += 25
      end
      
      score
    end
    
    #===========================================================================
    # Speed Control Strategies (Tailwind, Trick Room, Icy Wind)
    #===========================================================================
    module SpeedControlDoubles
      # Slow Pokemon that benefit from Trick Room
      TRICK_ROOM_THRESHOLD = 60  # Base speed threshold
      
      # Fast Pokemon that benefit from Tailwind
      TAILWIND_THRESHOLD = 80  # Base speed threshold
      
      # Speed-lowering moves
      SPEED_CONTROL_MOVES = [:ICYWIND, :ELECTROWEBS, :STRINGSHOT, :BULLDOZE, :ROCKSLIDE]
      
      # Evaluates Tailwind usage
      def self.evaluate_tailwind(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :TAILWIND
        
        score = 0
        
        # Check if Tailwind is already active
        if attacker.pbOwnSide.effects[PBEffects::Tailwind] > 0
          return -80  # Already have Tailwind
        end
        
        # Calculate team speed benefits
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        fast_allies = allies.count { |b| b.speed >= TAILWIND_THRESHOLD }
        
        # More fast allies = more benefit
        score += fast_allies * 25
        
        # Check if we're currently slower than opponents
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        slower_count = 0
        allies.each do |ally|
          opponents.each do |opp|
            slower_count += 1 if ally.speed < opp.speed
          end
        end
        
        # Bonus if we're currently outsped
        score += slower_count * 15
        
        # Penalty if Trick Room is active (speed control conflict)
        if battle.field.effects[PBEffects::TrickRoom] > 0
          score -= 70
        end
        
        # Bonus on Turn 1 (set up speed advantage early)
        if battle.turnCount == 0
          score += 30
        end
        
        # Check if partner can sweep with speed boost
        partner = DoublesCoordination.find_partner(battle, attacker)
        if partner
          if partner.attack > 120 || partner.spatk > 120
            score += 25  # Partner is offensive
          end
        end
        
        score
      end
      
      # Evaluates Trick Room usage
      def self.evaluate_trick_room(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :TRICKROOM
        
        score = 0
        
        # Trick Room toggles on/off
        trick_room_active = battle.field.effects[PBEffects::TrickRoom] > 0
        
        if trick_room_active
          # Check if WE benefit from current Trick Room
          allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          slow_allies = allies.count { |b| b.speed < TRICK_ROOM_THRESHOLD }
          
          if slow_allies >= allies.length / 2
            return -60  # Don't turn OFF our own Trick Room
          else
            score += 40  # Turn off opponent's Trick Room
          end
        else
          # Set up Trick Room
          allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          slow_allies = allies.count { |b| b.speed < TRICK_ROOM_THRESHOLD }
          
          # Need slow allies to benefit
          if slow_allies == 0
            return -50  # No slow Pokemon to benefit
          end
          
          score += slow_allies * 30
          
          # Bonus if opponents are fast
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          fast_opponents = opponents.count { |b| b.speed >= TAILWIND_THRESHOLD }
          score += fast_opponents * 20
          
          # Penalty if Tailwind is active (speed control conflict)
          if attacker.pbOwnSide.effects[PBEffects::Tailwind] > 0
            score -= 50
          end
          
          # Turn 1 bonus
          if battle.turnCount == 0
            score += 25
          end
        end
        
        score
      end
      
      # Evaluates Icy Wind / speed-lowering spread moves
      def self.evaluate_speed_control_attack(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless SPEED_CONTROL_MOVES.include?(move.id)
        
        score = 0
        
        # Check if we're currently slower
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        outsped = 0
        allies.each do |ally|
          opponents.each do |opp|
            outsped += 1 if ally.speed < opp.speed
          end
        end
        
        # Bonus for each speed tie we can fix
        score += outsped * 15
        
        # Extra bonus for Icy Wind (spread move + speed drop)
        if move.id == :ICYWIND
          score += opponents.count * 10
        end
        
        # Penalty if Trick Room is active (we WANT to be slower)
        if battle.field.effects[PBEffects::TrickRoom] > 0
          score -= 40
        end
        
        score
      end
      
      # Checks if team benefits from Trick Room
      def self.team_benefits_from_trick_room?(battle, side)
        battlers = []
        battle.allSameSideBattlers(side).each { |b| battlers << b if b && !b.fainted? }
        
        slow_count = battlers.count { |b| b.speed < TRICK_ROOM_THRESHOLD }
        slow_count >= battlers.length / 2
      end
    end
    
    #===========================================================================
    # Enhanced Weather Coordination for Doubles
    #===========================================================================
    module WeatherCoordinationDoubles
      # Weather abilities
      WEATHER_ABILITIES = {
        :Sun  => [:DROUGHT, :ORICHALCUMPULSE],
        :Rain => [:DRIZZLE, :PRIMORDIALSEA],
        :Sand => [:SANDSTREAM],
        :Hail => [:SNOWWARNING],
        :Snow => [:SNOWWARNING]
      }
      
      # Abilities that benefit from weather
      WEATHER_SYNERGY = {
        :Sun  => [:CHLOROPHYLL, :SOLARPOWER, :FLOWERGIFT, :LEAFGUARD, :HARVEST, :PROTOSYNTHESIS],
        :Rain => [:SWIFTSWIM, :RAINDISH, :DRYSKIN, :HYDRATION],
        :Sand => [:SANDRUSH, :SANDFORCE, :SANDVEIL],
        :Hail => [:SLUSHRUSH, :ICEBODY, :SNOWCLOAK],
        :Snow => [:SLUSHRUSH, :ICEBODY, :SNOWCLOAK]
      }
      
      # Move types boosted by weather
      WEATHER_MOVE_BOOST = {
        :Sun  => :FIRE,
        :Rain => :WATER,
        :Sand => :ROCK,  # Sand boosts SpDef of Rock-types
        :Hail => :ICE,
        :Snow => :ICE
      }
      
      # Evaluates weather move in doubles context
      def self.evaluate_weather_move(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        
        weather_moves = {
          :SUNNYDAY => :Sun,
          :RAINDANCE => :Rain,
          :SANDSTORM => :Sand,
          :HAIL => :Hail,
          :SNOWSCAPE => :Snow,
          :CHILLYRECEPTION => :Snow
        }
        
        target_weather = weather_moves[move.id]
        return 0 unless target_weather
        
        score = 0
        
        # Check current weather
        current_weather = battle.field.weather
        if current_weather == target_weather
          return -60  # Already have this weather
        end
        
        # Count allies that benefit
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        synergy_abilities = WEATHER_SYNERGY[target_weather] || []
        
        allies.each do |ally|
          # Ability synergy
          if synergy_abilities.include?(ally.ability_id)
            score += 40
          end
          
          # Move type synergy
          boost_type = WEATHER_MOVE_BOOST[target_weather]
          if boost_type
            stab_moves = ally.moves.count { |m| m && m.type == boost_type }
            score += stab_moves * 15
          end
        end
        
        # Penalty if opponents also benefit
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        opponents.each do |opp|
          if synergy_abilities.include?(opp.ability_id)
            score -= 35
          end
        end
        
        # Turn 1 bonus for early setup
        if battle.turnCount == 0
          score += 20
        end
        
        # Check partner's ability for auto-weather (don't override)
        partner = DoublesCoordination.find_partner(battle, attacker)
        if partner
          WEATHER_ABILITIES.each do |weather_type, abilities|
            if abilities.include?(partner.ability_id)
              if weather_type == target_weather
                score -= 30  # Partner already sets this weather
              else
                score -= 20  # Weather conflict with partner
              end
            end
          end
        end
        
        score
      end
      
      # Evaluates moves that benefit from current weather
      def self.evaluate_weather_boosted_move(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless battle.pbSideSize(0) > 1
        
        score = 0
        current_weather = battle.field.weather
        
        # Sun boosts Fire, weakens Water
        if current_weather == :Sun
          score += 25 if move.type == :FIRE
          score -= 20 if move.type == :WATER
          # Solar Beam / Solar Blade don't need charging
          score += 30 if [:SOLARBEAM, :SOLARBLADE].include?(move.id)
        end
        
        # Rain boosts Water, weakens Fire
        if current_weather == :Rain
          score += 25 if move.type == :WATER
          score -= 20 if move.type == :FIRE
          # Thunder / Hurricane don't miss
          score += 20 if [:THUNDER, :HURRICANE].include?(move.id)
        end
        
        # Hail/Snow enables Blizzard accuracy
        if [:Hail, :Snow].include?(current_weather)
          score += 20 if move.id == :BLIZZARD
          # Aurora Veil can be used
          score += 30 if move.id == :AURORAVEIL
        end
        
        # Sand boosts Rock-type SpDef, Sandstorm damage to non-immune
        if current_weather == :Sand
          score += 15 if move.type == :GROUND  # Often paired with Sand teams
        end
        
        # Weather Ball changes type
        if move.id == :WEATHERBALL && current_weather != :None
          score += 25
        end
        
        score
      end
    end
    
    #===========================================================================
    # Ally Protection & Synergy Moves
    #===========================================================================
    module AllySynergyDoubles
      # Moves that help allies
      ALLY_BOOST_MOVES = [:HELPINGHAND, :COACHING, :DECORATE, :AROMATHERAPY, 
                          :HEALBELL, :LIFEDEW, :POLLENPUFF, :HEALPULSE]
      
      # Evaluates Helping Hand
      def self.evaluate_helping_hand(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :HELPINGHAND
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return -50 unless partner  # No partner to help
        
        # Partner has high-damage moves
        if partner.attack > 120 || partner.spatk > 120
          score += 40
        end
        
        # Partner is faster than opponents (will attack this turn)
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        faster_than_all = opponents.all? { |opp| partner.speed > opp.speed }
        score += 25 if faster_than_all
        
        # Partner has spread move (Helping Hand affects all hits)
        has_spread = partner.moves.any? do |m| 
          m && m.pbTarget(partner).num_targets > 1
        end
        score += 30 if has_spread
        
        # Penalty if partner is using non-damaging move
        # (Helping Hand only boosts damage)
        score -= 20 if RedirectionStrategies.partner_is_setting_up?(partner)
        
        score
      end
      
      # Evaluates Coaching
      def self.evaluate_coaching(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :COACHING
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return -50 unless partner
        
        # Partner is physical attacker
        if partner.attack > partner.spatk
          score += 35
          # Partner doesn't have +6 Atk already
          if partner.stages[:ATTACK] < 6
            score += 20
          end
        end
        
        # Partner is healthy (can make use of boost)
        if partner.hp > partner.totalhp * 0.6
          score += 20
        end
        
        score
      end
      
      # Evaluates ally healing moves
      def self.evaluate_ally_heal(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless [:LIFEDEW, :HEALPULSE, :POLLENPUFF].include?(move.id)
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return -30 unless partner
        
        hp_percent = partner.hp.to_f / partner.totalhp
        
        # More valuable when partner is hurt
        if hp_percent < 0.3
          score += 60
        elsif hp_percent < 0.5
          score += 40
        elsif hp_percent < 0.7
          score += 20
        else
          score -= 30  # Partner is healthy
        end
        
        # Pollen Puff does damage to enemies
        if move.id == :POLLENPUFF
          score += 15  # Versatile move
        end
        
        score
      end
      
      # Evaluates Ally Switch
      def self.evaluate_ally_switch(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 80
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :ALLYSWITCH
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return -30 unless partner
        
        # Predict incoming super effective attack on partner
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        partner_threatened = false
        attacker_resists = false
        
        opponents.each do |opp|
          opp.moves.each do |opp_move|
            next unless opp_move && opp_move.damagingMove?
            
            # Check if partner is weak
            partner_mod = Effectiveness.calculate(opp_move.type, partner.types[0], partner.types[1])
            attacker_mod = Effectiveness.calculate(opp_move.type, attacker.types[0], attacker.types[1])
            
            if Effectiveness.super_effective?(partner_mod)
              partner_threatened = true
              if Effectiveness.not_very_effective?(attacker_mod) || Effectiveness.ineffective?(attacker_mod)
                attacker_resists = true
              end
            end
          end
        end
        
        if partner_threatened && attacker_resists
          score += 60  # Swap to take resisted hit
        elsif partner_threatened
          score += 25  # At least swap positions
        end
        
        # Don't spam (becomes predictable)
        if attacker.effects[PBEffects::AllySwitch]
          score -= 40
        end
        
        score
      end
    end
    
    #===========================================================================
    # Combo Detection & Setup Coordination
    #===========================================================================
    module ComboCoordinationDoubles
      # Classic doubles combos
      CLASSIC_COMBOS = {
        # [Move, Partner Ability/Move that synergizes]
        :EARTHQUAKE => [:LEVITATE, :FLYINGTYPE, :AIRBALLOON, :TELEKINESIS],
        :SURF => [:WATERABSORB, :DRYSKIN, :STORMDRAIN],
        :DISCHARGE => [:LIGHTNINGROD, :VOLTABSORB, :MOTORDRIVE],
        :HEATWAVE => [:FLASHFIRE, :WELLBAKEDBODY],
        :BEATUP => [:JUSTIFIED],  # Beat Up + Justified combo
        :SWAGGER => [:OWNTEMPO],  # Swagger + Own Tempo combo
      }
      
      # Checks for combo potential
      def self.check_combo_potential(battle, attacker, move)
        return 0 unless battle.pbSideSize(0) > 1
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        combo_synergy = CLASSIC_COMBOS[move.id]
        return 0 unless combo_synergy
        
        score = 0
        
        combo_synergy.each do |synergy|
          case synergy
          when :FLYINGTYPE
            score += 50 if partner.pbHasType?(:FLYING)
          when :AIRBALLOON
            score += 40 if partner.item_id == :AIRBALLOON
          else
            # Check ability
            score += 45 if partner.ability_id == synergy
          end
        end
        
        score
      end
      
      # Detects if move sets up partner
      def self.evaluate_setup_for_partner(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        # Screens help partner survive
        if [:REFLECT, :LIGHTSCREEN, :AURORAVEIL].include?(move.id)
          # More valuable if partner is offensive (wants to survive to attack)
          if partner.attack > 100 || partner.spatk > 100
            score += 25
          end
        end
        
        # Check for Beat Up + Justified combo
        if move.id == :BEATUP && partner.ability_id == :JUSTIFIED
          score += 80  # Classic combo!
        end
        
        # Decorate specifically boosts ally
        if move.id == :DECORATE
          score += 60
        end
        
        score
      end
    end
    
    #===========================================================================
    # Turn Order Manipulation (After You, Quash, Instruct)
    #===========================================================================
    module TurnOrderDoubles
      # Evaluates After You (makes ally move next)
      def self.evaluate_after_you(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :AFTERYOU
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return -50 unless partner
        
        # Useful if partner is slower but has priority needs
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        # Partner is slower than opponents
        partner_outsped = opponents.any? { |opp| partner.speed < opp.speed }
        
        if partner_outsped
          score += 35
          
          # Partner has setup move (wants to set up before being attacked)
          if RedirectionStrategies.partner_is_setting_up?(partner)
            score += 40
          end
          
          # Partner is a sweeper
          if partner.attack > 120 || partner.spatk > 120
            score += 25
          end
          
          # Partner is low HP (needs to attack before KO'd)
          if partner.hp < partner.totalhp * 0.4
            score += 30
          end
        else
          score -= 30  # Partner already faster, After You less useful
        end
        
        score
      end
      
      # Evaluates Quash (makes opponent move last)
      def self.evaluate_quash(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :QUASH
        return 0 unless target
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        
        # Target is faster than our team
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        target_faster_than_allies = allies.any? { |ally| target.speed > ally.speed }
        
        if target_faster_than_allies
          score += 40
          
          # Target is a setup sweeper (delay their setup)
          setup_moves = [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :SHELLSMASH, :QUIVERDANCE]
          if target.moves.any? { |m| m && setup_moves.include?(m.id) }
            score += 35
          end
          
          # Target has priority moves (Quash still makes them go last)
          if target.moves.any? { |m| m && m.priority > 0 }
            score += 25
          end
        else
          score -= 25  # Target already slow
        end
        
        score
      end
      
      # Evaluates Instruct (makes ally repeat their move)
      def self.evaluate_instruct(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :INSTRUCT
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return -50 unless partner
        
        # Instruct works best with high-damage moves
        # Check partner's last used move (if we can track it)
        if partner.lastMoveUsed
          last_move = GameData::Move.try_get(partner.lastMoveUsed)
          if last_move
            # High power move = good target for Instruct
            if last_move.power >= 100
              score += 50
            elsif last_move.power >= 70
              score += 30
            elsif last_move.power == 0
              score -= 30  # Status move, less value
            end
            
            # Spread move = extra value (hits multiple)
            if last_move.target && last_move.target.num_targets > 1
              score += 25
            end
          end
        else
          # No last move tracked, moderate score
          if partner.attack > 120 || partner.spatk > 120
            score += 25  # Offensive partner likely used strong move
          end
        end
        
        score
      end
    end
    
    #===========================================================================
    # Additional Protection Moves (Mat Block, Crafty Shield, Spotlight)
    #===========================================================================
    module AdditionalProtectionDoubles
      # Evaluates Mat Block (Riolu/Lucario's team protection, Turn 1 only)
      def self.evaluate_mat_block(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :MATBLOCK
        
        score = 0
        
        # Mat Block only works on Turn 1
        if attacker.turnCount != 0
          return -100  # Fails if not first turn out
        end
        
        # Protects entire team from damaging moves
        score += 60
        
        # Check if partner is setting up
        partner = DoublesCoordination.find_partner(battle, attacker)
        if partner && RedirectionStrategies.partner_is_setting_up?(partner)
          score += 40
        end
        
        # Bonus if opponents have strong attackers
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        high_offense = opponents.count { |opp| opp.attack > 100 || opp.spatk > 100 }
        score += high_offense * 20
        
        score
      end
      
      # Evaluates Crafty Shield (blocks status moves for team)
      def self.evaluate_crafty_shield(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :CRAFTYSHIELD
        
        score = 0
        
        # Check if opponents have status moves
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        status_moves = 0
        dangerous_status = [:SPORE, :DARKVOIDE, :THUNDERWAVE, :WILLOWISP, :TOXIC, 
                            :TAUNT, :ENCORE, :DISABLE, :SWAGGER]
        
        opponents.each do |opp|
          opp.moves.each do |opp_move|
            next unless opp_move
            if opp_move.category == 2 || dangerous_status.include?(opp_move.id)
              status_moves += 1
            end
          end
        end
        
        if status_moves == 0
          return -40  # No status moves to block
        end
        
        score += status_moves * 15
        
        # Extra value if partner is vulnerable to status
        partner = DoublesCoordination.find_partner(battle, attacker)
        if partner
          # Physical attacker vulnerable to burn
          if partner.attack > partner.spatk
            score += 15
          end
          # Fast Pokemon vulnerable to paralysis
          if partner.speed > 100
            score += 15
          end
        end
        
        # Protect rate penalty
        if attacker.effects[PBEffects::ProtectRate] > 1
          score -= 40
        end
        
        score
      end
      
      # Evaluates Spotlight (makes opponent the center of attention)
      def self.evaluate_spotlight(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :SPOTLIGHT
        return 0 unless target
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        # Spotlight redirects attacks TO the target
        # Useful when target has ability that punishes contact or is bulky
        
        # Target has Rough Skin, Iron Barbs, etc.
        punishing_abilities = [:ROUGHSKIN, :IRONBARBS, :FLAMEBODY, :STATIC, :POISONPOINT]
        if punishing_abilities.include?(target.ability_id)
          score += 40
        end
        
        # Target is bulky (can take hits)
        if target.defense > 100 || target.spdef > 100
          score += 25
        end
        
        # Target has Rocky Helmet
        if target.item_id == :ROCKYHELMET
          score += 30
        end
        
        score
      end
    end
    
    #===========================================================================
    # Gen 9 Specific Moves & Abilities
    #===========================================================================
    module Gen9DoublesStrategies
      # Evaluates Revival Blessing (revive fainted ally)
      def self.evaluate_revival_blessing(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :REVIVALBLESSING
        
        score = 0
        
        # Check for fainted party members
        party = battle.pbParty(attacker.index)
        fainted_count = party.count { |pkmn| pkmn && pkmn.fainted? }
        
        if fainted_count == 0
          return -100  # No one to revive
        end
        
        score += 70  # Strong move to bring back ally
        
        # Extra value if key Pokemon is fainted
        # (Check for high BST or key roles)
        party.each do |pkmn|
          next unless pkmn && pkmn.fainted?
          bst = pkmn.baseStats.values.sum
          if bst > 500
            score += 30  # Strong Pokemon worth reviving
            break
          end
        end
        
        score
      end
      
      # Evaluates Shed Tail (create substitute for switch-in)
      def self.evaluate_shed_tail(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :SHEDTAIL
        
        score = 0
        
        # Need HP to sacrifice
        if attacker.hp <= attacker.totalhp / 2
          return -50  # Too low HP to use
        end
        
        # Check for good switch-in candidates
        party = battle.pbParty(attacker.index)
        available = party.count { |pkmn| pkmn && !pkmn.fainted? && pkmn != attacker.pokemon }
        
        if available == 0
          return -100  # No one to switch in
        end
        
        score += 50
        
        # Extra value if we have setup sweepers in back
        party.each do |pkmn|
          next unless pkmn && !pkmn.fainted? && pkmn != attacker.pokemon
          # Check for setup move in moveset
          pkmn.moves.each do |m|
            next unless m
            if [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :SHELLSMASH, :QUIVERDANCE, :CALMMIND].include?(m.id)
              score += 35
              break
            end
          end
        end
        
        score
      end
      
      # Evaluates Doodle (copy ability to partner)
      def self.evaluate_doodle(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :DOODLE
        return 0 unless target
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        # Good abilities to copy
        good_abilities = [:INTIMIDATE, :HUGEPOWER, :PUREPOWER, :SPEEDBOOST, :PROTEAN, 
                          :LIBERO, :ADAPTABILITY, :CONTRARY, :MOODY, :UNAWARE,
                          :MAGICGUARD, :MULTISCALE, :STURDY, :LEVITATE]
        
        if good_abilities.include?(target.ability_id)
          score += 50
          
          # Synergy check - does partner benefit?
          case target.ability_id
          when :HUGEPOWER, :PUREPOWER
            score += 30 if partner.attack > partner.spatk
          when :SPEEDBOOST
            score += 25 if partner.speed < 100
          when :INTIMIDATE
            score += 20  # Always useful
          end
        end
        
        score
      end
      
      # Checks for Commander ability combo (Tatsugiri + Dondozo)
      def self.check_commander_combo(battle, attacker)
        return 0 unless battle.pbSideSize(0) > 1
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        # Check for Commander ability and Dondozo
        if attacker.ability_id == :COMMANDER && partner.species == :DONDOZO
          return 100  # Massive bonus for this combo
        elsif partner.ability_id == :COMMANDER && attacker.species == :DONDOZO
          return 80  # Bonus for being the Dondozo
        end
        
        0
      end
      
      # Evaluates Tidy Up (removes hazards and substitutes)
      def self.evaluate_tidy_up(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless move.id == :TIDYUP
        
        score = 0
        
        # Check for hazards on our side
        own_side = attacker.pbOwnSide
        hazard_count = 0
        hazard_count += 1 if own_side.effects[PBEffects::StealthRock]
        hazard_count += own_side.effects[PBEffects::Spikes] if own_side.effects[PBEffects::Spikes]
        hazard_count += own_side.effects[PBEffects::ToxicSpikes] if own_side.effects[PBEffects::ToxicSpikes]
        hazard_count += 1 if own_side.effects[PBEffects::StickyWeb]
        
        score += hazard_count * 20
        
        # Also removes substitutes (can be useful against opponent subs)
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        subs = opponents.count { |opp| opp.effects[PBEffects::Substitute] > 0 }
        score += subs * 25
        
        # Bonus: Also boosts Attack and Speed
        if attacker.stages[:ATTACK] < 6
          score += 20
        end
        if attacker.stages[:SPEED] < 6
          score += 15
        end
        
        score
      end
      
      # Evaluates Psychic Terrain synergy (blocks priority)
      def self.evaluate_psychic_terrain_doubles(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :PSYCHICTERRAIN
        
        score = 0
        
        # Already active?
        if battle.field.terrain == :Psychic
          return -60
        end
        
        # Blocks priority moves - check if opponents have them
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        priority_count = 0
        opponents.each do |opp|
          opp.moves.each do |m|
            next unless m
            priority_count += 1 if m.priority > 0
          end
        end
        
        score += priority_count * 20
        
        # Boosts Psychic moves
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        psychic_users = allies.count do |ally|
          ally.moves.any? { |m| m && m.type == :PSYCHIC && m.damagingMove? }
        end
        score += psychic_users * 25
        
        # Synergy with Expanding Force (becomes spread move)
        expanding_force_users = allies.count do |ally|
          ally.moves.any? { |m| m && m.id == :EXPANDINGFORCE }
        end
        score += expanding_force_users * 40
        
        score
      end
      
      # Evaluates Electromorphosis / Wind Rider ability synergy
      def self.check_ability_synergy(battle, attacker, move)
        return 0 unless battle.pbSideSize(0) > 1
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        score = 0
        
        # Wind Rider: Boosted by wind moves from partner
        wind_moves = [:TAILWIND, :BLEAKWINDSTORM, :SPRINGTIDESTORM, :WILDSTORMWIND]
        if partner.ability_id == :WINDRIDER && wind_moves.include?(move.id)
          score += 45  # Partner gets Attack boost
        end
        
        # Electromorphosis: Takes Electric hit to charge
        # (Less relevant for AI using move, but check for partner)
        
        # Steam Engine: Speed boost from Fire/Water
        if partner.ability_id == :STEAMENGINE
          if move.type == :FIRE || move.type == :WATER
            # Only if move hits partner
            if DoublesCoordination.hits_partner?(move, attacker, partner)
              score += 35
            end
          end
        end
        
        # Anger Point: Critical hit triggers max Attack
        # (Hard to control, but Frost Breath/Storm Throw always crit)
        if partner.ability_id == :ANGERPOINT
          if [:FROSTBREATH, :STORMTHROW].include?(move.id)
            if DoublesCoordination.hits_partner?(move, attacker, partner)
              score += 60  # Guaranteed max Attack!
            end
          end
        end
        
        score
      end
      
      # Evaluates Hospitality ability (heals partner on switch-in)
      def self.check_hospitality_synergy(battle, attacker)
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless attacker.ability_id == :HOSPITALITY
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        # Hospitality already triggered on switch, but useful context
        if partner.hp < partner.totalhp * 0.75
          return 20  # Partner appreciates the heal
        end
        
        0
      end
    end
    
    #===========================================================================
    # Gen 8 Dynamax Coordination for Doubles
    #===========================================================================
    module DynamaxDoublesStrategies
      # Max Moves that benefit the whole team
      MAX_TEAM_MOVES = {
        :MAXAIRSTREAM => :SPEED,      # +1 Speed to all allies
        :MAXSTEELSPIKE => :DEFENSE,   # +1 Defense to all allies
        :MAXQUAKE => :SPDEF,          # +1 SpDef to all allies
        :MAXOOZE => :SPATK,           # +1 SpAtk to all allies
        :MAXKNUCKLE => :ATTACK,       # +1 Attack to all allies
      }
      
      # Max Moves that set weather
      MAX_WEATHER_MOVES = {
        :MAXFLARE => :Sun,
        :MAXGEYSER => :Rain,
        :MAXROCKFALL => :Sandstorm,
        :MAXHAILSTORM => :Hail
      }
      
      # Max Moves that set terrain
      MAX_TERRAIN_MOVES = {
        :MAXLIGHTNING => :Electric,
        :MAXOVERGROWTH => :Grassy,
        :MAXMINDSTORM => :Psychic,
        :MAXSTARFALL => :Misty
      }
      
      # Evaluates Max Guard usage (Protect while Dynamaxed)
      def self.evaluate_max_guard(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :MAXGUARD
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        
        # Max Guard blocks Max Moves (important in Dynamax mirrors)
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        dynamaxed_opponents = opponents.count { |opp| opp.dynamax? rescue false }
        
        score += dynamaxed_opponents * 30
        
        # Similar to normal Protect logic
        if partner && RedirectionStrategies.partner_is_setting_up?(partner)
          score += 45
        end
        
        # Protect rate penalty
        if attacker.effects[PBEffects::ProtectRate] > 1
          score -= 50
        end
        
        score
      end
      
      # Evaluates team-boosting Max Moves
      def self.evaluate_max_team_move(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        
        stat_boost = MAX_TEAM_MOVES[move.id]
        return 0 unless stat_boost
        
        score = 0
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        case stat_boost
        when :SPEED
          # Max Airstream - Speed boost is huge in doubles
          slow_allies = allies.count { |a| a.stages[:SPEED] < 6 }
          score += slow_allies * 25
          
          # Extra value if outsped by opponents
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          outsped = allies.count { |a| opponents.any? { |o| o.speed > a.speed } }
          score += outsped * 15
          
        when :ATTACK
          # Max Knuckle - boost physical attackers
          phys_attackers = allies.count { |a| a.attack > a.spatk && a.stages[:ATTACK] < 6 }
          score += phys_attackers * 20
          
        when :SPATK
          # Max Ooze - boost special attackers
          spec_attackers = allies.count { |a| a.spatk > a.attack && a.stages[:SPECIAL_ATTACK] < 6 }
          score += spec_attackers * 20
          
        when :DEFENSE
          # Max Steelspike - boost team defense
          score += allies.count * 15
          # Extra if facing physical threats
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          phys_threats = opponents.count { |o| o.attack > o.spatk }
          score += phys_threats * 10
          
        when :SPDEF
          # Max Quake - boost team SpDef
          score += allies.count * 15
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          spec_threats = opponents.count { |o| o.spatk > o.attack }
          score += spec_threats * 10
        end
        
        score
      end
      
      # Evaluates weather-setting Max Moves
      def self.evaluate_max_weather_move(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        
        weather_type = MAX_WEATHER_MOVES[move.id]
        return 0 unless weather_type
        
        # Use existing weather coordination logic
        score = WeatherCoordinationDoubles.evaluate_weather_move(battle, attacker, move, skill_level)
        
        # Bonus for Max Move (more damage than regular weather move)
        score += 15
        
        score
      end
      
      # Evaluates terrain-setting Max Moves
      def self.evaluate_max_terrain_move(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        
        terrain_type = MAX_TERRAIN_MOVES[move.id]
        return 0 unless terrain_type
        
        # Use existing terrain coordination logic
        score = TerrainSynergyDoubles.evaluate_terrain_doubles(battle, attacker, move, skill_level)
        
        # Bonus for Max Move
        score += 15
        
        score
      end
      
      # Evaluates when to Dynamax in doubles
      def self.evaluate_dynamax_timing(battle, attacker, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        
        # Don't both Dynamax at the same time
        if partner && (partner.dynamax? rescue false)
          score -= 60  # Partner already Dynamaxed
        end
        
        # Dynamax when you're the main threat
        if attacker.attack > 130 || attacker.spatk > 130
          score += 30
        end
        
        # Dynamax for survivability when low
        if attacker.hp < attacker.totalhp * 0.5
          score += 25
        end
        
        # Dynamax if partner can support (Helping Hand, Follow Me)
        if partner
          support_moves = [:HELPINGHAND, :FOLLOWME, :RAGEPOWDER, :ALLYSWITCH]
          has_support = partner.moves.any? { |m| m && support_moves.include?(m.id) }
          score += 35 if has_support
        end
        
        score
      end
      
      # G-Max moves with special effects
      def self.evaluate_gmax_move(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        
        score = 0
        
        # G-Max Volcalith (ongoing Rock damage)
        if move.id == :GMAXVOLCALITH
          opponents = battle.allOtherSideBattlers(attacker.index).count { |b| b && !b.fainted? }
          score += opponents * 20
        end
        
        # G-Max Vine Lash / Wildfire / Cannonade (ongoing damage)
        if [:GMAXVINELASH, :GMAXWILDFIRE, :GMAXCANNONADE].include?(move.id)
          opponents = battle.allOtherSideBattlers(attacker.index).count { |b| b && !b.fainted? }
          score += opponents * 20
        end
        
        # G-Max Wind Rage (removes screens/hazards)
        if move.id == :GMAXWINDRAGE
          opp_side = attacker.pbOpposingSide
          has_screens = opp_side.effects[PBEffects::Reflect] > 0 || 
                        opp_side.effects[PBEffects::LightScreen] > 0 ||
                        opp_side.effects[PBEffects::AuroraVeil] > 0
          score += 40 if has_screens
        end
        
        # G-Max Resonance (Aurora Veil effect)
        if move.id == :GMAXRESONANCE
          if attacker.pbOwnSide.effects[PBEffects::AuroraVeil] == 0
            score += 50
          end
        end
        
        score
      end
    end
    
    #===========================================================================
    # Additional Gen 9 Doubles Strategies
    #===========================================================================
    module Gen9ExtendedStrategies
      # Evaluates Terastallization coordination
      def self.evaluate_tera_timing_doubles(battle, attacker, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless battle.pbSideSize(0) > 1
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        
        # Don't both Tera at the same time (usually)
        if partner && (partner.tera? rescue false)
          score -= 30  # Partner already Terastallized
        end
        
        # Tera to STAB boost (offensive Tera)
        tera_type = attacker.tera_type rescue nil
        if tera_type
          # Check if we have moves of that type
          tera_moves = attacker.moves.count { |m| m && m.type == tera_type && m.damagingMove? }
          score += tera_moves * 20
        end
        
        # Defensive Tera (change type to resist threats)
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        # This is complex - simplified version
        if attacker.hp < attacker.totalhp * 0.6
          score += 15  # More likely to Tera for survival
        end
        
        score
      end
      
      # Evaluates Collision Course / Electro Drift (boosted if super effective)
      def self.evaluate_paradox_moves(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless [:COLLISIONCOURSE, :ELECTRODRIFT].include?(move.id)
        return 0 unless target
        
        score = 0
        
        # These moves get 33% boost if super effective
        type_mod = Effectiveness.calculate(move.type, target.types[0], target.types[1])
        if Effectiveness.super_effective?(type_mod)
          score += 35  # Bonus for using on weak target
        end
        
        score
      end
      
      # Evaluates Ice Spinner / Steel Roller (terrain removal)
      def self.evaluate_terrain_removal(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless [:ICESPINNER, :STEELROLLER].include?(move.id)
        
        score = 0
        
        # Check if terrain is active
        if battle.field.terrain != :None
          score += 30
          
          # Extra bonus if opponent benefits from terrain
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          
          case battle.field.terrain
          when :Electric
            # Remove if opponents have Electric moves or Surge Surfer
            electric_benefit = opponents.any? { |o| o.ability_id == :SURGESURFER }
            score += 25 if electric_benefit
          when :Psychic
            # Priority blocking might help opponents more
            allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
            ally_priority = allies.count { |a| a.moves.any? { |m| m && m.priority > 0 } }
            score += ally_priority * 15  # Remove if WE have priority
          when :Grassy
            # Healing might help opponents
            score += 15
          end
        else
          # Steel Roller fails without terrain
          if move.id == :STEELROLLER
            return -100
          end
        end
        
        score
      end
      
      # Evaluates Court Change (swaps hazards)
      def self.evaluate_court_change(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless move.id == :COURTCHANGE
        
        score = 0
        own_side = attacker.pbOwnSide
        opp_side = attacker.pbOpposingSide
        
        # Count our hazards
        our_hazards = 0
        our_hazards += 1 if own_side.effects[PBEffects::StealthRock]
        our_hazards += own_side.effects[PBEffects::Spikes] if own_side.effects[PBEffects::Spikes]
        our_hazards += own_side.effects[PBEffects::ToxicSpikes] if own_side.effects[PBEffects::ToxicSpikes]
        our_hazards += 1 if own_side.effects[PBEffects::StickyWeb]
        
        # Count their hazards
        their_hazards = 0
        their_hazards += 1 if opp_side.effects[PBEffects::StealthRock]
        their_hazards += opp_side.effects[PBEffects::Spikes] if opp_side.effects[PBEffects::Spikes]
        their_hazards += opp_side.effects[PBEffects::ToxicSpikes] if opp_side.effects[PBEffects::ToxicSpikes]
        their_hazards += 1 if opp_side.effects[PBEffects::StickyWeb]
        
        # Also count screens
        our_screens = 0
        our_screens += 1 if own_side.effects[PBEffects::Reflect] > 0
        our_screens += 1 if own_side.effects[PBEffects::LightScreen] > 0
        our_screens += 1 if own_side.effects[PBEffects::AuroraVeil] > 0
        
        their_screens = 0
        their_screens += 1 if opp_side.effects[PBEffects::Reflect] > 0
        their_screens += 1 if opp_side.effects[PBEffects::LightScreen] > 0
        their_screens += 1 if opp_side.effects[PBEffects::AuroraVeil] > 0
        
        # Good if we have more hazards and they have more screens
        score += (our_hazards - their_hazards) * 20
        score += (their_screens - our_screens) * 25
        
        # Also consider Tailwind
        our_tailwind = own_side.effects[PBEffects::Tailwind] > 0 ? 1 : 0
        their_tailwind = opp_side.effects[PBEffects::Tailwind] > 0 ? 1 : 0
        score += (their_tailwind - our_tailwind) * 30
        
        score
      end
      
      # Evaluates Mortal Spin (hazard removal + poison)
      def self.evaluate_mortal_spin(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless move.id == :MORTALSPIN
        
        score = 0
        own_side = attacker.pbOwnSide
        
        # Check for hazards to remove
        hazard_count = 0
        hazard_count += 1 if own_side.effects[PBEffects::StealthRock]
        hazard_count += own_side.effects[PBEffects::Spikes] if own_side.effects[PBEffects::Spikes]
        hazard_count += own_side.effects[PBEffects::ToxicSpikes] if own_side.effects[PBEffects::ToxicSpikes]
        hazard_count += 1 if own_side.effects[PBEffects::StickyWeb]
        
        score += hazard_count * 25
        
        # Also poisons targets (spread move in doubles)
        if battle.pbSideSize(0) > 1
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          poisonable = opponents.count do |opp|
            !opp.pbHasType?(:POISON) && !opp.pbHasType?(:STEEL) && opp.status == :NONE
          end
          score += poisonable * 15
        end
        
        score
      end
      
      # Evaluates Make It Rain (spread move with SpAtk drop)
      def self.evaluate_make_it_rain(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :MAKEITRAIN
        
        score = 0
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        # Spread Steel move is good
        score += opponents.count * 20
        
        # But drops SpAtk - penalty if staying in
        if attacker.hp > attacker.totalhp * 0.5
          score -= 15  # Staying in, SpAtk drop hurts
        else
          score += 10  # Might switch out anyway
        end
        
        score
      end
      
      # Evaluates Triple Arrows (defense drop + flinch chance)
      def self.evaluate_triple_arrows(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless move.id == :TRIPLEARROWS
        return 0 unless target
        
        score = 0
        
        # Defense drop helps partner's physical attacks
        partner = DoublesCoordination.find_partner(battle, attacker)
        if partner && partner.attack > partner.spatk
          score += 25
        end
        
        # Flinch chance
        if attacker.speed > target.speed
          score += 15
        end
        
        score
      end
      
      # Evaluates Trailblaze / Chilling Water (guaranteed stat changes)
      def self.evaluate_stat_lowering_attacks(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless [:TRAILBLAZE, :CHILLINGWATER, :LUMINACRASH].include?(move.id)
        return 0 unless target
        
        score = 0
        
        case move.id
        when :TRAILBLAZE
          # Boosts own Speed
          if attacker.stages[:SPEED] < 6
            score += 20
          end
        when :CHILLINGWATER
          # Lowers target Attack
          partner = DoublesCoordination.find_partner(battle, attacker)
          if partner && target.attack > target.spatk
            score += 25  # Reduce threat to partner
          end
        when :LUMINACRASH
          # Drops SpDef by 2 stages
          partner = DoublesCoordination.find_partner(battle, attacker)
          if partner && partner.spatk > partner.attack
            score += 30  # Partner can capitalize
          end
        end
        
        score
      end
      
      # Evaluates Order Up (Commander boost when Dondozo uses it)
      def self.evaluate_order_up(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless move.id == :ORDERUP
        
        score = 0
        
        # Check if Tatsugiri is in the Commander slot
        if attacker.species == :DONDOZO
          # Dondozo with Tatsugiri inside gets stat boost based on Tatsugiri form
          # This is complex to check, but give base bonus
          score += 30
        end
        
        score
      end
      
      # Evaluates Salt Cure (ongoing damage based on type)
      def self.evaluate_salt_cure(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless move.id == :SALTCURE
        return 0 unless target
        
        score = 0
        
        # Salt Cure does 1/8 damage, 1/4 to Water/Steel
        if target.pbHasType?(:WATER) || target.pbHasType?(:STEEL)
          score += 50  # Double damage per turn!
        else
          score += 25  # Still good chip damage
        end
        
        # More valuable if target is bulky (will take more turns)
        if target.hp > target.totalhp * 0.7
          score += 15
        end
        
        score
      end
      
      # Evaluates Rage Fist (power increases with hits taken)
      def self.evaluate_rage_fist(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless move.id == :RAGEFIST
        
        score = 0
        
        # Check how many times attacker has been hit
        times_hit = attacker.effects[PBEffects::RageFist] rescue 0
        
        # Base power 50 + 50 per hit, max 350
        effective_power = [50 + (times_hit * 50), 350].min
        
        if effective_power >= 200
          score += 40
        elsif effective_power >= 150
          score += 25
        elsif effective_power >= 100
          score += 10
        end
        
        score
      end
    end
    
    #===========================================================================
    # Terrain Synergy for Doubles
    #===========================================================================
    module TerrainSynergyDoubles
      TERRAIN_MOVES = {
        :ELECTRICTERRAIN => :Electric,
        :GRASSYTERRAIN => :Grassy,
        :PSYCHICTERRAIN => :Psychic,
        :MISTYTERRAIN => :Misty
      }
      
      TERRAIN_ABILITIES = {
        :Electric => [:SURGESURFER, :ELECTRICSEED],
        :Grassy => [:GRASSYSEED],
        :Psychic => [:PSYCHICSEED],
        :Misty => [:MISTYSEED]
      }
      
      def self.evaluate_terrain_doubles(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        
        terrain_type = TERRAIN_MOVES[move.id]
        return 0 unless terrain_type
        
        score = 0
        
        # Already active?
        if battle.field.terrain == terrain_type
          return -60
        end
        
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        # Check ability synergy
        synergy_abilities = TERRAIN_ABILITIES[terrain_type] || []
        allies.each do |ally|
          if synergy_abilities.include?(ally.ability_id)
            score += 35
          end
          
          # Check for Seed items
          seed_items = {
            :Electric => :ELECTRICSEED,
            :Grassy => :GRASSYSEED,
            :Psychic => :PSYCHICSEED,
            :Misty => :MISTYSEED
          }
          if ally.item_id == seed_items[terrain_type]
            score += 40
          end
        end
        
        # Type-specific bonuses
        case terrain_type
        when :Electric
          # Boosts Electric moves, prevents Sleep
          electric_users = allies.count { |a| a.moves.any? { |m| m && m.type == :ELECTRIC && m.damagingMove? } }
          score += electric_users * 20
          # Rising Voltage doubles in Electric Terrain
          rising_voltage_users = allies.count { |a| a.moves.any? { |m| m && m.id == :RISINGVOLTAGE } }
          score += rising_voltage_users * 35
          
        when :Grassy
          # Heals grounded Pokemon, boosts Grass, weakens Earthquake
          grass_users = allies.count { |a| a.moves.any? { |m| m && m.type == :GRASS && m.damagingMove? } }
          score += grass_users * 20
          # Reduces Earthquake damage
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          eq_users = opponents.count { |o| o.moves.any? { |m| m && m.id == :EARTHQUAKE } }
          score += eq_users * 15
          # Grassy Glide priority
          grassy_glide_users = allies.count { |a| a.moves.any? { |m| m && m.id == :GRASSYGLIDE } }
          score += grassy_glide_users * 30
          
        when :Psychic
          # Blocks priority, boosts Psychic moves
          psychic_users = allies.count { |a| a.moves.any? { |m| m && m.type == :PSYCHIC && m.damagingMove? } }
          score += psychic_users * 20
          # Expanding Force becomes spread move
          expanding_force_users = allies.count { |a| a.moves.any? { |m| m && m.id == :EXPANDINGFORCE } }
          score += expanding_force_users * 40
          
        when :Misty
          # Prevents status, weakens Dragon
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          dragon_users = opponents.count { |o| o.moves.any? { |m| m && m.type == :DRAGON && m.damagingMove? } }
          score += dragon_users * 20
          # Misty Explosion boosted
          misty_explosion_users = allies.count { |a| a.moves.any? { |m| m && m.id == :MISTYEXPLOSION } }
          score += misty_explosion_users * 25
        end
        
        score
      end
    end
    
    #===========================================================================
    # Item Awareness for Doubles (VGC Meta Items)
    #===========================================================================
    module ItemAwarenessDoubles
      # Focus Sash awareness - don't overkill, need to break sash first
      def self.check_focus_sash(battle, attacker, target, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless target
        return 0 unless target.item_id == :FOCUSSASH
        return 0 unless target.hp == target.totalhp  # Sash only works at full HP
        
        score = 0
        
        # Multi-hit moves break sash then KO
        if move.multiHitMove?
          score += 40
        end
        
        # Spread moves - partner can break sash, we KO
        partner = DoublesCoordination.find_partner(battle, attacker)
        if partner && battle.pbSideSize(0) > 1
          # If partner is faster and also attacking this target
          score += 25
        end
        
        # Weather/hazard damage breaks sash
        if battle.field.weather != :None
          weather_damages = [:Sandstorm, :Hail]
          if weather_damages.include?(battle.field.weather)
            # Check if target takes weather damage
            unless target.pbHasType?(:ROCK) || target.pbHasType?(:GROUND) || 
                   target.pbHasType?(:STEEL) || target.pbHasType?(:ICE)
              score += 20  # Weather will break sash
            end
          end
        end
        
        score
      end
      
      # Weakness Policy abuse - hit partner with weak super effective move
      def self.evaluate_weakness_policy_abuse(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 80
        return 0 unless battle.pbSideSize(0) > 1
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        return 0 unless partner.item_id == :WEAKNESSPOLICY
        
        score = 0
        
        # Check if move hits partner and is super effective
        if DoublesCoordination.hits_partner?(move, attacker, partner)
          type_mod = Effectiveness.calculate(move.type, partner.types[0], partner.types[1])
          
          if Effectiveness.super_effective?(type_mod)
            # Low power move preferred (don't KO partner!)
            if move.power <= 40
              score += 80  # Weak move triggers WP without killing
            elsif move.power <= 60
              score += 50
            else
              score -= 20  # Too strong, might KO
            end
          end
        end
        
        # Beat Up on WP Justified mon is god-tier
        if move.id == :BEATUP && partner.ability_id == :JUSTIFIED && partner.item_id == :WEAKNESSPOLICY
          score += 100  # +4 Attack and +2 Attack/SpAtk!
        end
        
        score
      end
      
      # Safety Goggles awareness (immune to powder/spore moves)
      def self.check_safety_goggles(battle, attacker, target, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless target
        return 0 unless target.item_id == :SAFETYGOGGLES
        
        score = 0
        
        powder_moves = [:SPORE, :SLEEPPOWDER, :STUNSPORE, :POISONPOWDER, :RAGEPOWDER,
                        :POWDER, :COTTONSPORE]
        
        if powder_moves.include?(move.id)
          score -= 80  # Move will fail
        end
        
        score
      end
      
      # Assault Vest awareness (can only use attacking moves)
      def self.check_assault_vest_target(battle, target, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless target
        return 0 unless target.item_id == :ASSAULTVEST
        
        # Target can't use status moves - less Protect, less setup
        30  # Bonus - opponent is limited
      end
      
      # Choice item awareness
      def self.check_choice_item(battle, attacker, target, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless target
        
        choice_items = [:CHOICEBAND, :CHOICESPECS, :CHOICESCARF]
        return 0 unless choice_items.include?(target.item_id)
        
        score = 0
        
        # Choice locked opponent - can predict their move
        if target.lastMoveUsed
          score += 25  # We know what they're locked into
          
          # If locked into something we resist
          last_move = GameData::Move.try_get(target.lastMoveUsed)
          if last_move
            type_mod = Effectiveness.calculate(last_move.type, attacker.types[0], attacker.types[1])
            if Effectiveness.not_very_effective?(type_mod) || Effectiveness.ineffective?(type_mod)
              score += 35  # They're locked into bad move vs us
            end
          end
        end
        
        score
      end
      
      # Eject Button / Red Card awareness
      def self.check_ejection_items(battle, target, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless target
        
        if target.item_id == :EJECTBUTTON
          # Hitting them causes switch - might lose momentum
          return -15
        elsif target.item_id == :REDCARD
          # Hitting them switches US - careful
          return -25
        end
        
        0
      end
      
      # Air Balloon awareness
      def self.check_air_balloon(battle, target, move, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless target
        return 0 unless target.item_id == :AIRBALLOON
        
        # Ground moves fail
        if move.type == :GROUND
          return -80
        end
        
        # Popping the balloon is valuable
        if move.damagingMove?
          return 15  # Pop their balloon
        end
        
        0
      end
      
      # Room Service / Adrenaline Orb awareness
      def self.check_stat_trigger_items(battle, attacker, partner, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless partner
        
        score = 0
        
        # Room Service triggers in Trick Room
        if partner.item_id == :ROOMSERVICE
          if battle.field.effects[PBEffects::TrickRoom] > 0
            score += 30  # Partner got speed drop for TR
          end
        end
        
        # Adrenaline Orb triggers on Intimidate
        if partner.item_id == :ADRENALINEORB
          # Bonus if facing Intimidate users
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          if opponents.any? { |o| o.ability_id == :INTIMIDATE }
            score += 25
          end
        end
        
        score
      end
      
      # Sitrus Berry / Healing Berries awareness
      def self.check_healing_berries(battle, target, skill_level = 100)
        return 0 unless skill_level >= 60
        return 0 unless target
        
        healing_berries = [:SITRUSBERRY, :AGUAVBERRY, :FIGYBERRY, :IAPAPABERRY,
                          :MAGOBERRY, :WIKIBERRY, :ORANBERRY]
        
        return 0 unless healing_berries.include?(target.item_id)
        
        # Target will heal at 50% or below - need to burst them
        if target.hp > target.totalhp * 0.5
          return 15  # Try to burst through the heal threshold
        else
          return -10  # They'll heal, might not KO
        end
      end
    end
    
    #===========================================================================
    # Ability Synergies for Doubles (VGC Meta Abilities)
    #===========================================================================
    module AbilitySynergyDoubles
      # Intimidate awareness
      def self.check_intimidate(battle, attacker, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        
        # Check if we have Intimidate
        if attacker.ability_id == :INTIMIDATE
          # Value of Intimidate higher against physical attackers
          opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
          phys_attackers = opponents.count { |o| o.attack > o.spatk }
          score += phys_attackers * 15
          
          # Check for Defiant/Competitive (they punish Intimidate)
          punishing_abilities = [:DEFIANT, :COMPETITIVE, :CONTRARY, :MIRRORARMOR]
          if opponents.any? { |o| punishing_abilities.include?(o.ability_id) }
            score -= 40
          end
        end
        
        # Check if partner has Defiant/Competitive (Intimidate helps them!)
        if partner
          if partner.ability_id == :DEFIANT || partner.ability_id == :COMPETITIVE
            # Facing Intimidate is actually good for us
            opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
            if opponents.any? { |o| o.ability_id == :INTIMIDATE }
              score += 35
            end
          end
        end
        
        score
      end
      
      # Prankster awareness
      def self.check_prankster(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless attacker.ability_id == :PRANKSTER
        return 0 unless move.category == 2  # Status move
        
        score = 0
        
        # Prankster gives priority to status moves
        score += 20
        
        # But Dark types are immune to Prankster status
        if target && target.pbHasType?(:DARK)
          score -= 80  # Move fails
        end
        
        score
      end
      
      # Inner Focus / Own Tempo (Fake Out immunity)
      def self.check_flinch_immunity(battle, target, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless target
        
        flinch_immune = [:INNERFOCUS, :OWNTEMPO, :SHIELDDUST, :SCRAPPY]
        
        if flinch_immune.include?(target.ability_id)
          if move.id == :FAKEOUT || move.addlEffect == "Flinch"
            return -50  # Flinch won't work
          end
        end
        
        0
      end
      
      # Friend Guard awareness (reduces damage to partner)
      def self.check_friend_guard(battle, attacker, target, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless target
        return 0 unless battle.pbSideSize(0) > 1
        
        partner = DoublesCoordination.find_partner(battle, target)
        return 0 unless partner
        
        # If target's partner has Friend Guard, target takes less damage
        if partner.ability_id == :FRIENDGUARD
          return -15  # 25% damage reduction
        end
        
        0
      end
      
      # Telepathy (immune to partner's moves)
      def self.check_telepathy(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 65
        return 0 unless battle.pbSideSize(0) > 1
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        # If partner has Telepathy, we can use spread moves freely
        if partner.ability_id == :TELEPATHY
          if DoublesCoordination.hits_partner?(move, attacker, partner)
            return 40  # Partner won't be hit
          end
        end
        
        0
      end
      
      # Neutralizing Gas awareness
      def self.check_neutralizing_gas(battle, attacker, skill_level = 100)
        return 0 unless skill_level >= 75
        
        # Check if anyone has Neutralizing Gas active
        all_battlers = battle.allBattlers
        if all_battlers.any? { |b| b && !b.fainted? && b.ability_id == :NEUTRALIZINGGAS }
          # All abilities are nullified - ignore ability-based strategies
          return 20  # Simplifies calculations
        end
        
        0
      end
      
      # Skill Swap / Entrainment / Role Play strategies
      def self.evaluate_ability_manipulation(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 80
        return 0 unless [:SKILLSWAP, :ENTRAINMENT, :ROLEPLAY, :GASTROACID].include?(move.id)
        return 0 unless target
        
        score = 0
        
        case move.id
        when :SKILLSWAP
          # Good abilities to steal
          good_abilities = [:HUGEPOWER, :PUREPOWER, :SPEEDBOOST, :INTIMIDATE,
                           :MULTISCALE, :MAGICGUARD, :LEVITATE, :PRANKSTER]
          if good_abilities.include?(target.ability_id)
            score += 50
          end
          
          # Bad abilities to give away
          bad_abilities = [:SLOWSTART, :TRUANT, :DEFEATIST, :STALL]
          if bad_abilities.include?(attacker.ability_id)
            score += 60  # Give them our bad ability
          end
          
        when :ENTRAINMENT
          # Give target our ability - good if we have something bad
          bad_for_them = [:TRUANT, :SLOWSTART, :DEFEATIST]
          if bad_for_them.include?(attacker.ability_id)
            score += 70
          end
          
        when :GASTROACID
          # Suppress target's ability
          strong_abilities = [:HUGEPOWER, :INTIMIDATE, :LEVITATE, :MULTISCALE,
                             :MAGICGUARD, :WONDERGUARD]
          if strong_abilities.include?(target.ability_id)
            score += 55
          end
        end
        
        score
      end
      
      # Slow Start awareness (Regigigas)
      def self.check_slow_start(battle, attacker, target, skill_level = 100)
        return 0 unless skill_level >= 65
        
        if target && target.ability_id == :SLOWSTART
          # Target is weakened for 5 turns
          return 25  # Take advantage
        end
        
        if attacker.ability_id == :SLOWSTART
          # We're weakened - play defensively
          return -20
        end
        
        0
      end
      
      #=========================================================================
      # Ally-Boosting Abilities (Power Spot, Battery, Steely Spirit, Flower Gift)
      #=========================================================================
      
      # Power Spot (Stonjourner) - +30% move power to allies
      def self.check_power_spot(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move && move.damagingMove?
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner && !partner.fainted?
        
        if partner.ability_id == :POWERSPOT
          # Our moves deal 30% more damage!
          return 25
        end
        
        0
      end
      
      # Battery (Charjabug) - +30% special move power to allies
      def self.check_battery(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move && move.specialMove?
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner && !partner.fainted?
        
        if partner.ability_id == :BATTERY
          # Our special moves deal 30% more damage!
          return 25
        end
        
        0
      end
      
      # Steely Spirit - +50% Steel move power to allies
      def self.check_steely_spirit(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move && move.damagingMove? && move.type == :STEEL
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner && !partner.fainted?
        
        if partner.ability_id == :STEELYSPIRIT
          # Our Steel moves deal 50% more damage!
          return 40
        end
        
        # Also check if WE have Steely Spirit (partner's Steel moves are boosted)
        if attacker.ability_id == :STEELYSPIRIT
          # Partner benefits - consider this when protecting the ally
          return 10
        end
        
        0
      end
      
      # Flower Gift (Cherrim) - +50% Atk & SpDef in Sun
      def self.check_flower_gift(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        
        # Only active in Sun
        weather = battle.pbWeather
        return 0 unless [:Sun, :HarshSun].include?(weather)
        
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner && !partner.fainted?
        
        score = 0
        
        # If partner has Flower Gift, we get boosted
        if partner.ability_id == :FLOWERGIFT
          if move && move.physicalMove?
            score += 35  # 50% Attack boost
          end
          # Also +50% SpDef for surviving special attacks
          score += 15
        end
        
        # If WE have Flower Gift, partner benefits
        if attacker.ability_id == :FLOWERGIFT
          # Consider protecting partner / setting sun
          score += 10
        end
        
        score
      end
      
      # Comprehensive ally-boost check
      def self.check_ally_boosting_abilities(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        
        score = 0
        score += check_power_spot(battle, attacker, move, skill_level)
        score += check_battery(battle, attacker, move, skill_level)
        score += check_steely_spirit(battle, attacker, move, skill_level)
        score += check_flower_gift(battle, attacker, move, skill_level)
        
        score
      end
    end
    
    #===========================================================================
    # VGC Meta Strategies (World Championship Tactics)
    #===========================================================================
    module VGCMetaStrategies
      # Perish Trap strategy
      def self.evaluate_perish_trap(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 80
        return 0 unless move.id == :PERISHSONG
        
        score = 0
        
        # Check if we have trapping moves/abilities
        partner = DoublesCoordination.find_partner(battle, attacker)
        trapping_moves = [:MEANLOOK, :BLOCK, :SPIDERWEB, :SPIRITSHACKLE]
        trapping_abilities = [:SHADOWTAG, :ARENATRAP, :MAGNETPULL]
        
        has_trapping = false
        if partner
          has_trapping = partner.moves.any? { |m| m && trapping_moves.include?(m.id) }
          has_trapping ||= trapping_abilities.include?(partner.ability_id)
        end
        has_trapping ||= attacker.moves.any? { |m| m && trapping_moves.include?(m.id) }
        has_trapping ||= trapping_abilities.include?(attacker.ability_id)
        
        if has_trapping
          score += 60
        else
          score -= 20  # Opponents can just switch out
        end
        
        # Check if we have more Pokemon in back
        own_party = battle.pbParty(attacker.index)
        fainted_own = own_party.count { |p| p && p.fainted? }
        
        opp_party = battle.pbParty(battle.allOtherSideBattlers(attacker.index).first&.index || 1)
        fainted_opp = opp_party.count { |p| p && p.fainted? }
        
        if fainted_own < fainted_opp
          score += 40  # We have more reserves
        end
        
        score
      end
      
      # Taunt evaluation for doubles
      def self.evaluate_taunt_doubles(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 70
        return 0 unless battle.pbSideSize(0) > 1
        return 0 unless move.id == :TAUNT
        return 0 unless target
        
        score = 0
        
        # Check target's status move count
        status_moves = target.moves.count { |m| m && m.category == 2 }
        
        if status_moves >= 3
          score += 60  # Target relies on status moves
        elsif status_moves >= 2
          score += 40
        elsif status_moves >= 1
          score += 20
        else
          score -= 30  # Pure attacker, Taunt does little
        end
        
        # High priority targets for Taunt
        priority_taunt = [:TRICKROOM, :TAILWIND, :PROTECT, :FOLLOWME, :RAGEPOWDER,
                         :SPORE, :WILLOWISP, :THUNDERWAVE]
        if target.moves.any? { |m| m && priority_taunt.include?(m.id) }
          score += 35
        end
        
        # Check for Mental Herb (blocks Taunt once)
        if target.item_id == :MENTALHERB
          score -= 25
        end
        
        # Prankster Taunt is especially good
        if attacker.ability_id == :PRANKSTER
          score += 25
        end
        
        score
      end
      
      # Encore evaluation for doubles
      def self.evaluate_encore_doubles(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless move.id == :ENCORE
        return 0 unless target
        
        score = 0
        
        # Encore last used move
        if target.lastMoveUsed
          last_move = GameData::Move.try_get(target.lastMoveUsed)
          if last_move
            # Encore them into bad moves
            bad_to_encore = [:PROTECT, :DETECT, :SPLASH, :HELPINGHAND]
            if bad_to_encore.include?(target.lastMoveUsed)
              score += 70  # Locked into useless move
            end
            
            # Encore them into something we resist
            if last_move.damagingMove?
              type_mod = Effectiveness.calculate(last_move.type, attacker.types[0], attacker.types[1])
              if Effectiveness.not_very_effective?(type_mod)
                score += 40
              elsif Effectiveness.ineffective?(type_mod)
                score += 60
              end
            end
          end
        end
        
        score
      end
      
      # Imprison for doubles (block opponent's Protect/TR)
      def self.evaluate_imprison(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 80
        return 0 unless move.id == :IMPRISON
        
        score = 0
        
        # Check what moves we share with opponents
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        our_moves = attacker.moves.map { |m| m&.id }.compact
        
        # Key moves to block
        key_moves = [:PROTECT, :TRICKROOM, :TAILWIND, :FAKEOUT, :SPORE]
        
        opponents.each do |opp|
          opp.moves.each do |opp_move|
            next unless opp_move
            if our_moves.include?(opp_move.id) && key_moves.include?(opp_move.id)
              score += 30
            end
          end
        end
        
        score
      end
      
      # Soak strategy (make target Water-type)
      def self.evaluate_soak(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless move.id == :SOAK
        return 0 unless target
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        
        # Partner has Grass/Electric moves
        if partner
          grass_elec = partner.moves.any? do |m|
            m && m.damagingMove? && [:GRASS, :ELECTRIC].include?(m.type)
          end
          if grass_elec
            score += 50  # Make target weak to partner's moves
          end
        end
        
        # Remove their STAB/immunities
        if target.pbHasType?(:GROUND)
          score += 35  # Remove Ground immunity to Electric
        end
        if target.pbHasType?(:GHOST)
          score += 30  # Remove Ghost immunities
        end
        
        score
      end
      
      # Ally Switch mind games
      def self.evaluate_ally_switch_prediction(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 85
        return 0 unless move.id == :ALLYSWITCH
        return 0 unless battle.pbSideSize(0) > 1
        
        score = 0
        partner = DoublesCoordination.find_partner(battle, attacker)
        return 0 unless partner
        
        # Predict super effective attacks coming at partner
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        partner_in_danger = false
        we_resist = false
        
        opponents.each do |opp|
          opp.moves.each do |opp_move|
            next unless opp_move && opp_move.damagingMove?
            
            # Check if partner is weak
            partner_mod = Effectiveness.calculate(opp_move.type, partner.types[0], partner.types[1])
            our_mod = Effectiveness.calculate(opp_move.type, attacker.types[0], attacker.types[1])
            
            if Effectiveness.super_effective?(partner_mod)
              partner_in_danger = true
              if Effectiveness.not_very_effective?(our_mod) || Effectiveness.ineffective?(our_mod)
                we_resist = true
              end
            end
          end
        end
        
        if partner_in_danger && we_resist
          score += 55
        elsif partner_in_danger
          score += 25
        end
        
        # Mind games - Ally Switch becomes predictable if spammed
        # Add some randomness at high skill
        if skill_level >= 90 && rand(100) < 30
          score += 20  # Sometimes do it anyway
        end
        
        score
      end
      
      # Gravity strategy (enables Ground moves on Flying, boosts accuracy)
      def self.evaluate_gravity(battle, attacker, move, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless move.id == :GRAVITY
        
        score = 0
        
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        # Check if allies have Ground moves
        ground_users = allies.count { |a| a.moves.any? { |m| m && m.type == :GROUND && m.damagingMove? } }
        
        # Check if opponents are Flying/Levitate
        flying_opponents = opponents.count do |o|
          o.pbHasType?(:FLYING) || o.ability_id == :LEVITATE || o.item_id == :AIRBALLOON
        end
        
        score += ground_users * 25
        score += flying_opponents * 30
        
        # Gravity boosts accuracy - good with low accuracy moves
        low_accuracy_moves = allies.count do |a|
          a.moves.any? { |m| m && m.damagingMove? && m.accuracy < 80 }
        end
        score += low_accuracy_moves * 15
        
        score
      end
      
      # Guard Split / Power Split
      def self.evaluate_stat_split(battle, attacker, move, target, skill_level = 100)
        return 0 unless skill_level >= 75
        return 0 unless [:GUARDSPLIT, :POWERSPLIT].include?(move.id)
        return 0 unless target
        
        score = 0
        
        case move.id
        when :GUARDSPLIT
          # Average defenses - good if we're frail and they're bulky
          our_def = attacker.defense + attacker.spdef
          their_def = target.defense + target.spdef
          
          if their_def > our_def * 1.5
            score += 45  # We gain bulk, they lose it
          end
          
        when :POWERSPLIT
          # Average offenses - good if we're weak and they're strong
          our_off = attacker.attack + attacker.spatk
          their_off = target.attack + target.spatk
          
          if their_off > our_off * 1.5
            score += 50  # Neuters their offense
          end
        end
        
        score
      end
    end
    
    #===========================================================================
    # Switch-In Awareness (What happens when Pokemon enters)
    #===========================================================================
    module SwitchInAwareness
      # Intimidate on switch
      def self.predict_intimidate_switch(battle, attacker, skill_level = 100)
        return 0 unless skill_level >= 70
        
        # Check opponent's back for Intimidate users
        # This is predictive - harder to implement without team preview
        # For now, check if current opponents have Intimidate
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        if opponents.any? { |o| o.ability_id == :INTIMIDATE }
          # Intimidate already active
          if attacker.stages[:ATTACK] < 0
            return -15  # We're already debuffed
          end
        end
        
        0
      end
      
      # Weather ability switch-in awareness
      def self.predict_weather_switch(battle, attacker, skill_level = 100)
        return 0 unless skill_level >= 70
        
        # Current weather might change on switch
        # Track if opponent has weather setters in back
        # For now, be aware of current weather abilities
        
        current_weather = battle.field.weather
        
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        # Check if our team benefits from current weather
        weather_synergy = {
          :Sun => [:CHLOROPHYLL, :SOLARPOWER, :FLOWERGIFT],
          :Rain => [:SWIFTSWIM, :RAINDISH, :DRYSKIN],
          :Sandstorm => [:SANDRUSH, :SANDFORCE],
          :Hail => [:SLUSHRUSH, :ICEBODY]
        }
        
        synergy_abilities = weather_synergy[current_weather] || []
        if allies.any? { |a| synergy_abilities.include?(a.ability_id) }
          return 25  # We benefit from current weather
        end
        
        0
      end
      
      # Terrain setter switch awareness
      def self.predict_terrain_switch(battle, attacker, skill_level = 100)
        return 0 unless skill_level >= 70
        
        terrain_setters = {
          :Electric => [:ELECTRICSURGE],
          :Grassy => [:GRASSYSURGE],
          :Psychic => [:PSYCHICSURGE],
          :Misty => [:MISTYSURGE]
        }
        
        current_terrain = battle.field.terrain
        
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        # Check if we set the current terrain
        our_setter = false
        terrain_setters.each do |terrain, abilities|
          if current_terrain == terrain
            if allies.any? { |a| abilities.include?(a.ability_id) }
              our_setter = true
              break
            end
          end
        end
        
        our_setter ? 20 : 0
      end
    end
    
    private
    
    def self.find_partner(battle, attacker)
      battle.allSameSideBattlers(attacker.index).find { |b| b && b != attacker && !b.fainted? }
    end
    
    def self.partner_targets?(battle, partner, target)
      return false unless partner && target
      # Check if partner's chosen action targets the same opponent
      # In Battle::AI, choices are stored in @battle.choices
      begin
        partner_choice = battle.choices[partner.index] rescue nil
        if partner_choice && partner_choice[0] == :UseMove
          partner_target_idx = partner_choice[3]  # Target index
          return partner_target_idx == target.index if partner_target_idx
        end
      rescue
        # Fall back to heuristic: does partner have moves that target this foe?
      end

      # Heuristic: if partner is a physical/special attacker and target is low HP,
      # assume they're likely targeting it
      if target.hp < target.totalhp * 0.35
        return true  # Low HP target is a likely shared target
      end

      false
    end
    
    def self.hits_partner?(move, attacker, partner)
      targets = move.pbTarget(attacker)
      # In v21.1, spread moves that hit partners include AllOtherPokemon, AllFoesAndAllies, etc.
      # We check if num_targets > 1 and it's NOT just hitting foes.
      return targets.num_targets > 1 && ![:AllNearFoes, :AllFoes, :RandomFoe].include?(targets.id)
    end
    
    def self.count_enemies_hit(battle, attacker, move)
      battle.allOtherSideBattlers(attacker.index).count { |b| b && !b.fainted? }
    end
  end
end

# API-Wrapper
module AdvancedAI
  def self.prevent_overkill(battle, attacker, target, skill_level = 100)
    DoublesCoordination.prevent_overkill(battle, attacker, target, skill_level)
  end
  
  def self.prevent_move_conflicts(battle, attacker, move, skill_level = 100)
    DoublesCoordination.prevent_move_conflicts(battle, attacker, move, skill_level)
  end
  
  def self.optimize_spread_moves(battle, attacker, move, skill_level = 100)
    DoublesCoordination.optimize_spread_moves(battle, attacker, move, skill_level)
  end
  
  def self.coordinate_field_effects(battle, attacker, move, skill_level = 100)
    DoublesCoordination.coordinate_field_effects(battle, attacker, move, skill_level)
  end
  
  def self.protect_setup_combo(battle, attacker, move, skill_level = 100)
    DoublesCoordination.protect_setup_combo(battle, attacker, move, skill_level)
  end
  
  # New Doubles APIs
  def self.evaluate_wide_guard(battle, attacker, move, skill_level = 100)
    DoublesCoordination::ProtectiveMovesDoubles.evaluate_wide_guard(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_quick_guard(battle, attacker, move, skill_level = 100)
    DoublesCoordination::ProtectiveMovesDoubles.evaluate_quick_guard(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_follow_me(battle, attacker, move, skill_level = 100)
    DoublesCoordination::RedirectionStrategies.evaluate_follow_me(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_rage_powder(battle, attacker, move, skill_level = 100)
    DoublesCoordination::RedirectionStrategies.evaluate_rage_powder(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_fake_out(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination.evaluate_fake_out(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_protect_doubles(battle, attacker, move, skill_level = 100)
    DoublesCoordination.evaluate_protect_doubles(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_tailwind(battle, attacker, move, skill_level = 100)
    DoublesCoordination::SpeedControlDoubles.evaluate_tailwind(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_trick_room(battle, attacker, move, skill_level = 100)
    DoublesCoordination::SpeedControlDoubles.evaluate_trick_room(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_speed_control_attack(battle, attacker, move, skill_level = 100)
    DoublesCoordination::SpeedControlDoubles.evaluate_speed_control_attack(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_weather_move_doubles(battle, attacker, move, skill_level = 100)
    DoublesCoordination::WeatherCoordinationDoubles.evaluate_weather_move(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_weather_boosted_move(battle, attacker, move, skill_level = 100)
    DoublesCoordination::WeatherCoordinationDoubles.evaluate_weather_boosted_move(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_helping_hand(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AllySynergyDoubles.evaluate_helping_hand(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_coaching(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AllySynergyDoubles.evaluate_coaching(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_ally_heal(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AllySynergyDoubles.evaluate_ally_heal(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_ally_switch(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AllySynergyDoubles.evaluate_ally_switch(battle, attacker, move, skill_level)
  end
  
  def self.check_combo_potential(battle, attacker, move)
    DoublesCoordination::ComboCoordinationDoubles.check_combo_potential(battle, attacker, move)
  end
  
  def self.evaluate_setup_for_partner(battle, attacker, move, skill_level = 100)
    DoublesCoordination::ComboCoordinationDoubles.evaluate_setup_for_partner(battle, attacker, move, skill_level)
  end
  
  # Turn Order Manipulation APIs
  def self.evaluate_after_you(battle, attacker, move, skill_level = 100)
    DoublesCoordination::TurnOrderDoubles.evaluate_after_you(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_quash(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::TurnOrderDoubles.evaluate_quash(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_instruct(battle, attacker, move, skill_level = 100)
    DoublesCoordination::TurnOrderDoubles.evaluate_instruct(battle, attacker, move, skill_level)
  end
  
  # Additional Protection APIs
  def self.evaluate_mat_block(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AdditionalProtectionDoubles.evaluate_mat_block(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_crafty_shield(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AdditionalProtectionDoubles.evaluate_crafty_shield(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_spotlight(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::AdditionalProtectionDoubles.evaluate_spotlight(battle, attacker, move, target, skill_level)
  end
  
  # Gen 9 APIs
  def self.evaluate_revival_blessing(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9DoublesStrategies.evaluate_revival_blessing(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_shed_tail(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9DoublesStrategies.evaluate_shed_tail(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_doodle(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::Gen9DoublesStrategies.evaluate_doodle(battle, attacker, move, target, skill_level)
  end
  
  def self.check_commander_combo(battle, attacker)
    DoublesCoordination::Gen9DoublesStrategies.check_commander_combo(battle, attacker)
  end
  
  def self.evaluate_tidy_up(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9DoublesStrategies.evaluate_tidy_up(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_psychic_terrain_doubles(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9DoublesStrategies.evaluate_psychic_terrain_doubles(battle, attacker, move, skill_level)
  end
  
  def self.check_ability_synergy(battle, attacker, move)
    DoublesCoordination::Gen9DoublesStrategies.check_ability_synergy(battle, attacker, move)
  end
  
  # Terrain APIs
  def self.evaluate_terrain_doubles(battle, attacker, move, skill_level = 100)
    DoublesCoordination::TerrainSynergyDoubles.evaluate_terrain_doubles(battle, attacker, move, skill_level)
  end
  
  # Gen 8 Dynamax APIs
  def self.evaluate_max_guard(battle, attacker, move, skill_level = 100)
    DoublesCoordination::DynamaxDoublesStrategies.evaluate_max_guard(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_max_team_move(battle, attacker, move, skill_level = 100)
    DoublesCoordination::DynamaxDoublesStrategies.evaluate_max_team_move(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_max_weather_move(battle, attacker, move, skill_level = 100)
    DoublesCoordination::DynamaxDoublesStrategies.evaluate_max_weather_move(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_max_terrain_move(battle, attacker, move, skill_level = 100)
    DoublesCoordination::DynamaxDoublesStrategies.evaluate_max_terrain_move(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_dynamax_timing(battle, attacker, skill_level = 100)
    DoublesCoordination::DynamaxDoublesStrategies.evaluate_dynamax_timing(battle, attacker, skill_level)
  end
  
  def self.evaluate_gmax_move(battle, attacker, move, skill_level = 100)
    DoublesCoordination::DynamaxDoublesStrategies.evaluate_gmax_move(battle, attacker, move, skill_level)
  end
  
  # Gen 9 Extended APIs
  def self.evaluate_tera_timing_doubles(battle, attacker, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_tera_timing_doubles(battle, attacker, skill_level)
  end
  
  def self.evaluate_paradox_moves(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_paradox_moves(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_terrain_removal(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_terrain_removal(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_court_change(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_court_change(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_mortal_spin(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_mortal_spin(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_make_it_rain(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_make_it_rain(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_triple_arrows(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_triple_arrows(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_stat_lowering_attacks(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_stat_lowering_attacks(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_order_up(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_order_up(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_salt_cure(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_salt_cure(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_rage_fist(battle, attacker, move, skill_level = 100)
    DoublesCoordination::Gen9ExtendedStrategies.evaluate_rage_fist(battle, attacker, move, skill_level)
  end
  
  # Item Awareness APIs (VGC Meta Items)
  def self.check_focus_sash(battle, attacker, target, move, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.check_focus_sash(battle, attacker, target, move, skill_level)
  end
  
  def self.evaluate_weakness_policy_abuse(battle, attacker, move, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.evaluate_weakness_policy_abuse(battle, attacker, move, skill_level)
  end
  
  def self.check_safety_goggles(battle, attacker, target, move, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.check_safety_goggles(battle, attacker, target, move, skill_level)
  end
  
  def self.check_assault_vest_target(battle, target, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.check_assault_vest_target(battle, target, skill_level)
  end
  
  def self.check_choice_item(battle, attacker, target, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.check_choice_item(battle, attacker, target, skill_level)
  end
  
  def self.check_ejection_items(battle, target, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.check_ejection_items(battle, target, skill_level)
  end
  
  def self.check_air_balloon(battle, target, move, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.check_air_balloon(battle, target, move, skill_level)
  end
  
  def self.check_stat_trigger_items(battle, attacker, partner, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.check_stat_trigger_items(battle, attacker, partner, skill_level)
  end
  
  def self.check_healing_berries(battle, target, skill_level = 100)
    DoublesCoordination::ItemAwarenessDoubles.check_healing_berries(battle, target, skill_level)
  end
  
  # Ability Synergy APIs
  def self.check_intimidate(battle, attacker, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_intimidate(battle, attacker, skill_level)
  end
  
  def self.check_prankster(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_prankster(battle, attacker, move, target, skill_level)
  end
  
  def self.check_flinch_immunity(battle, target, move, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_flinch_immunity(battle, target, move, skill_level)
  end
  
  def self.check_friend_guard(battle, attacker, target, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_friend_guard(battle, attacker, target, skill_level)
  end
  
  def self.check_telepathy(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_telepathy(battle, attacker, move, skill_level)
  end
  
  def self.check_neutralizing_gas(battle, attacker, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_neutralizing_gas(battle, attacker, skill_level)
  end
  
  def self.evaluate_ability_manipulation(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.evaluate_ability_manipulation(battle, attacker, move, target, skill_level)
  end
  
  def self.check_slow_start(battle, attacker, target, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_slow_start(battle, attacker, target, skill_level)
  end
  
  def self.check_ally_boosting_abilities(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_ally_boosting_abilities(battle, attacker, move, skill_level)
  end
  
  def self.check_power_spot(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_power_spot(battle, attacker, move, skill_level)
  end
  
  def self.check_battery(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_battery(battle, attacker, move, skill_level)
  end
  
  def self.check_steely_spirit(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_steely_spirit(battle, attacker, move, skill_level)
  end
  
  def self.check_flower_gift(battle, attacker, move, skill_level = 100)
    DoublesCoordination::AbilitySynergyDoubles.check_flower_gift(battle, attacker, move, skill_level)
  end
  
  # VGC Meta Strategies APIs
  def self.evaluate_perish_trap(battle, attacker, move, skill_level = 100)
    DoublesCoordination::VGCMetaStrategies.evaluate_perish_trap(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_taunt_doubles(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::VGCMetaStrategies.evaluate_taunt_doubles(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_encore_doubles(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::VGCMetaStrategies.evaluate_encore_doubles(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_imprison(battle, attacker, move, skill_level = 100)
    DoublesCoordination::VGCMetaStrategies.evaluate_imprison(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_soak(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::VGCMetaStrategies.evaluate_soak(battle, attacker, move, target, skill_level)
  end
  
  def self.evaluate_ally_switch_prediction(battle, attacker, move, skill_level = 100)
    DoublesCoordination::VGCMetaStrategies.evaluate_ally_switch_prediction(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_gravity(battle, attacker, move, skill_level = 100)
    DoublesCoordination::VGCMetaStrategies.evaluate_gravity(battle, attacker, move, skill_level)
  end
  
  def self.evaluate_stat_split(battle, attacker, move, target, skill_level = 100)
    DoublesCoordination::VGCMetaStrategies.evaluate_stat_split(battle, attacker, move, target, skill_level)
  end
  
  # Switch-In Awareness APIs
  def self.predict_intimidate_switch(battle, attacker, skill_level = 100)
    DoublesCoordination::SwitchInAwareness.predict_intimidate_switch(battle, attacker, skill_level)
  end
  
  def self.predict_weather_switch(battle, attacker, skill_level = 100)
    DoublesCoordination::SwitchInAwareness.predict_weather_switch(battle, attacker, skill_level)
  end
  
  def self.predict_terrain_switch(battle, attacker, skill_level = 100)
    DoublesCoordination::SwitchInAwareness.predict_terrain_switch(battle, attacker, skill_level)
  end
end

# Integration in Battle::AI
class Battle::AI
  def apply_doubles_coordination(score, move, user, target, skill = 100)
    return score unless @battle.pbSideSize(0) > 1
    return score unless AdvancedAI.feature_enabled?(:core, skill)
    
    # Original coordination
    score += AdvancedAI.prevent_overkill(@battle, user, target, skill) if target
    score += AdvancedAI.prevent_move_conflicts(@battle, user, move, skill)
    score += AdvancedAI.optimize_spread_moves(@battle, user, move, skill)
    score += AdvancedAI.coordinate_field_effects(@battle, user, move, skill)
    score += AdvancedAI.protect_setup_combo(@battle, user, move, skill)
    
    # Protective moves (Wide Guard, Quick Guard)
    score += AdvancedAI.evaluate_wide_guard(@battle, user, move, skill)
    score += AdvancedAI.evaluate_quick_guard(@battle, user, move, skill)
    
    # Redirection (Follow Me, Rage Powder)
    score += AdvancedAI.evaluate_follow_me(@battle, user, move, skill)
    score += AdvancedAI.evaluate_rage_powder(@battle, user, move, skill)
    
    # Fake Out & Protect
    score += AdvancedAI.evaluate_fake_out(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_protect_doubles(@battle, user, move, skill)
    
    # Speed Control (Tailwind, Trick Room, Icy Wind)
    score += AdvancedAI.evaluate_tailwind(@battle, user, move, skill)
    score += AdvancedAI.evaluate_trick_room(@battle, user, move, skill)
    score += AdvancedAI.evaluate_speed_control_attack(@battle, user, move, skill)
    
    # Weather Coordination
    score += AdvancedAI.evaluate_weather_move_doubles(@battle, user, move, skill)
    score += AdvancedAI.evaluate_weather_boosted_move(@battle, user, move, skill)
    
    # Ally Synergy (Helping Hand, Coaching, Heals)
    score += AdvancedAI.evaluate_helping_hand(@battle, user, move, skill)
    score += AdvancedAI.evaluate_coaching(@battle, user, move, skill)
    score += AdvancedAI.evaluate_ally_heal(@battle, user, move, skill)
    score += AdvancedAI.evaluate_ally_switch(@battle, user, move, skill)
    
    # Combo Detection
    score += AdvancedAI.check_combo_potential(@battle, user, move)
    score += AdvancedAI.evaluate_setup_for_partner(@battle, user, move, skill)
    
    # Turn Order Manipulation (After You, Quash, Instruct)
    score += AdvancedAI.evaluate_after_you(@battle, user, move, skill)
    score += AdvancedAI.evaluate_quash(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_instruct(@battle, user, move, skill)
    
    # Additional Protection (Mat Block, Crafty Shield, Spotlight)
    score += AdvancedAI.evaluate_mat_block(@battle, user, move, skill)
    score += AdvancedAI.evaluate_crafty_shield(@battle, user, move, skill)
    score += AdvancedAI.evaluate_spotlight(@battle, user, move, target, skill) if target
    
    # Gen 8 Dynamax Strategies
    score += AdvancedAI.evaluate_max_guard(@battle, user, move, skill)
    score += AdvancedAI.evaluate_max_team_move(@battle, user, move, skill)
    score += AdvancedAI.evaluate_max_weather_move(@battle, user, move, skill)
    score += AdvancedAI.evaluate_max_terrain_move(@battle, user, move, skill)
    score += AdvancedAI.evaluate_gmax_move(@battle, user, move, skill)
    
    # Gen 9 Strategies
    score += AdvancedAI.evaluate_revival_blessing(@battle, user, move, skill)
    score += AdvancedAI.evaluate_shed_tail(@battle, user, move, skill)
    score += AdvancedAI.evaluate_doodle(@battle, user, move, target, skill) if target
    score += AdvancedAI.check_commander_combo(@battle, user)
    score += AdvancedAI.evaluate_tidy_up(@battle, user, move, skill)
    score += AdvancedAI.evaluate_psychic_terrain_doubles(@battle, user, move, skill)
    score += AdvancedAI.check_ability_synergy(@battle, user, move)
    
    # Gen 9 Extended Strategies
    score += AdvancedAI.evaluate_paradox_moves(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_terrain_removal(@battle, user, move, skill)
    score += AdvancedAI.evaluate_court_change(@battle, user, move, skill)
    score += AdvancedAI.evaluate_mortal_spin(@battle, user, move, skill)
    score += AdvancedAI.evaluate_make_it_rain(@battle, user, move, skill)
    score += AdvancedAI.evaluate_triple_arrows(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_stat_lowering_attacks(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_order_up(@battle, user, move, skill)
    score += AdvancedAI.evaluate_salt_cure(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_rage_fist(@battle, user, move, skill)
    
    # Terrain Synergy
    score += AdvancedAI.evaluate_terrain_doubles(@battle, user, move, skill)
    
    # Item Awareness (VGC Meta Items)
    if target
      score += AdvancedAI.check_focus_sash(@battle, user, target, move, skill)
      score += AdvancedAI.check_safety_goggles(@battle, user, target, move, skill)
      score += AdvancedAI.check_assault_vest_target(@battle, target, skill)
      score += AdvancedAI.check_choice_item(@battle, user, target, skill)
      score += AdvancedAI.check_ejection_items(@battle, target, skill)
      score += AdvancedAI.check_air_balloon(@battle, target, move, skill)
      score += AdvancedAI.check_healing_berries(@battle, target, skill)
    end
    score += AdvancedAI.evaluate_weakness_policy_abuse(@battle, user, move, skill)
    partner = @battle.allSameSideBattlers(user.index).find { |b| b && b != user && !b.fainted? }
    score += AdvancedAI.check_stat_trigger_items(@battle, user, partner, skill) if partner
    
    # Ability Synergy
    score += AdvancedAI.check_intimidate(@battle, user, skill)
    score += AdvancedAI.check_prankster(@battle, user, move, target, skill) if target
    score += AdvancedAI.check_flinch_immunity(@battle, target, move, skill) if target
    score += AdvancedAI.check_friend_guard(@battle, user, target, skill) if target
    score += AdvancedAI.check_telepathy(@battle, user, move, skill)
    score += AdvancedAI.check_neutralizing_gas(@battle, user, skill)
    score += AdvancedAI.evaluate_ability_manipulation(@battle, user, move, target, skill) if target
    score += AdvancedAI.check_slow_start(@battle, user, target, skill) if target
    
    # Ally-Boosting Abilities (Power Spot, Battery, Steely Spirit, Flower Gift)
    score += AdvancedAI.check_ally_boosting_abilities(@battle, user, move, skill)
    
    # VGC Meta Strategies
    score += AdvancedAI.evaluate_perish_trap(@battle, user, move, skill)
    score += AdvancedAI.evaluate_taunt_doubles(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_encore_doubles(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_imprison(@battle, user, move, skill)
    score += AdvancedAI.evaluate_soak(@battle, user, move, target, skill) if target
    score += AdvancedAI.evaluate_ally_switch_prediction(@battle, user, move, skill)
    score += AdvancedAI.evaluate_gravity(@battle, user, move, skill)
    score += AdvancedAI.evaluate_stat_split(@battle, user, move, target, skill) if target
    
    # Switch-In Awareness
    score += AdvancedAI.predict_intimidate_switch(@battle, user, skill)
    score += AdvancedAI.predict_weather_switch(@battle, user, skill)
    score += AdvancedAI.predict_terrain_switch(@battle, user, skill)
    
    # #19: Joint Target Selection
    if target
      real_user = user.respond_to?(:battler) ? user.battler : user
      real_target = target.respond_to?(:battler) ? target.battler : target
      score += DoublesCoordination.joint_target_bonus(@battle, real_user, move, real_target, skill) rescue 0
    end
    
    return score
  end
end

#===============================================================================
# #19: Joint Target Selection — optimize who attacks what in doubles
#===============================================================================
module AdvancedAI
  module DoublesCoordination
    # Returns a bonus/penalty for attacking a specific target in doubles
    # Considers partner's likely action to avoid overkill and optimize KOs
    def self.joint_target_bonus(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless battle.pbSideSize(0) > 1
      return 0 unless target && move

      partner = find_partner(battle, attacker)
      return 0 unless partner

      bonus = 0
      enemies = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      return 0 if enemies.length < 2  # Only one target anyway

      # Estimate our damage to this target
      our_damage = CombatUtilities.estimate_damage(attacker, move, target, as_percent: true) rescue 0

      # Check if partner is likely targeting the same foe
      partner_on_same = partner_targets?(battle, partner, target)

      if partner_on_same && our_damage >= target.hp.to_f / target.totalhp
        # We can KO alone — partner should attack the other target
        # Slight penalty to encourage partner to spread attacks
        bonus -= 10
      end

      if partner_on_same && our_damage < 0.5
        # Neither of us can KO this target → might be better to focus the other one
        other_targets = enemies.reject { |e| e == target }
        other_targets.each do |other|
          other_hp_pct = other.hp.to_f / other.totalhp
          if other_hp_pct < 0.4
            bonus -= 15  # Other target is low, pick them off instead
            break
          end
        end
      end

      # If we have type advantage on this target but partner doesn't, focus here
      if move.damagingMove?
        target_types = target.respond_to?(:pbTypes) ? target.pbTypes : [:NORMAL]
        eff = 1.0
        target_types.each { |t| eff *= Effectiveness.calculate_one(move.type, t) rescue 1.0 }
        if eff > 1.0
          bonus += 10  # We have SE on this target
        end
      end

      bonus
    end
  end
end

AdvancedAI.log("Doubles Coordination System loaded", "Doubles")
AdvancedAI.log("  - Wide Guard & Quick Guard strategies", "Doubles")
AdvancedAI.log("  - Follow Me / Rage Powder redirection", "Doubles")
AdvancedAI.log("  - Fake Out & Protect coordination", "Doubles")
AdvancedAI.log("  - Tailwind & Trick Room speed control", "Doubles")
AdvancedAI.log("  - Enhanced weather coordination", "Doubles")
AdvancedAI.log("  - Ally synergy moves (Helping Hand, Coaching)", "Doubles")
AdvancedAI.log("  - Combo detection (Beat Up + Justified, etc.)", "Doubles")
AdvancedAI.log("  - Turn order manipulation (After You, Quash, Instruct)", "Doubles")
AdvancedAI.log("  - Additional protection (Mat Block, Crafty Shield)", "Doubles")
AdvancedAI.log("  - Gen 8 Dynamax coordination (Max Airstream, G-Max moves)", "Doubles")
AdvancedAI.log("  - Gen 9 strategies (Revival Blessing, Shed Tail, Doodle)", "Doubles")
AdvancedAI.log("  - Commander combo (Tatsugiri + Dondozo)", "Doubles")
AdvancedAI.log("  - Gen 9 extended (Salt Cure, Rage Fist, Court Change)", "Doubles")
AdvancedAI.log("  - Terastallization & Paradox Pokemon moves", "Doubles")
AdvancedAI.log("  - Terrain synergy (Rising Voltage, Expanding Force, etc.)", "Doubles")
AdvancedAI.log("  - Item awareness (Focus Sash, Weakness Policy, Choice items)", "Doubles")
AdvancedAI.log("  - Ability synergy (Intimidate, Prankster, Telepathy)", "Doubles")
AdvancedAI.log("  - Ally-boosting abilities (Power Spot, Battery, Steely Spirit, Flower Gift)", "Doubles")
AdvancedAI.log("  - VGC Meta strategies (Perish Trap, Taunt, Encore, Imprison)", "Doubles")
AdvancedAI.log("  - Switch-In awareness (Intimidate, Weather, Terrain)", "Doubles")
AdvancedAI.log("  - Spread move 75% damage reduction awareness", "Doubles")
AdvancedAI.log("  - #8 Intimidate cycling switch bonus", "Doubles")
AdvancedAI.log("  - #20 Ally Switch awareness + TR setter coordination", "Doubles")

### FILE: Doubles_Strategy.rb ###
#===============================================================================
# Advanced AI System - Doubles/VGC Optimizations
# Spread moves, redirection, Fake Out, Helping Hand, Protect coordination
#===============================================================================

module AdvancedAI
  module DoublesStrategy
    
    #===========================================================================
    # Spread Move Damage Reduction
    #===========================================================================
    
    SPREAD_MOVES = [
      :EARTHQUAKE, :SURF, :DISCHARGE, :LAVAPLUME, :ROCKSLIDE, :ICICLECRASH,
      :BLIZZARD, :HEATWAVE, :SLUDGEWAVE, :DAZZLINGGLEAM, :MUDDYWATER,
      :RAZORLEAF, :ICYWIND, :BULLDOZE, :PARABOLICCHARGE, :GMAXCANNONADE,
      :BOOMBURST, :RELICSONG, :PETALBLIZZARD, :EXPLOSION, :SELFDESTRUCT,
      :MAGNITUDE, :GLACIATE, :ORIGINPULSE, :PRECIPICEBLADES, :ERUPTION,
      :WATERSPOUT, :SNARL, :STRUGGLE
    ]
    
    # Spread moves deal 0.75x damage when hitting multiple targets
    SPREAD_DAMAGE_MULTIPLIER = 0.75
    
    #===========================================================================
    # Redirection Moves
    #===========================================================================
    
    REDIRECTION_MOVES = {
      :FOLLOWME => { priority: 2, duration: 1 },
      :RAGEPOWDER => { priority: 2, duration: 1 },
      :SPOTLIGHT => { priority: 3, duration: 1 }
    }
    
    # Abilities that redirect
    REDIRECTION_ABILITIES = [:LIGHTNINGROD, :STORMDRAIN]
    
    #===========================================================================
    # Support Moves
    #===========================================================================
    
    # Helping Hand: +50% damage to partner's next move
    HELPING_HAND_BOOST = 1.5
    
    #===========================================================================
    # Damage Calculation for Doubles
    #===========================================================================
    
    def self.adjust_damage_for_doubles(base_damage, move, battle)
      return base_damage unless battle.pbSideSize(0) > 1  # Only in doubles
      
      # Spread moves deal 0.75x damage
      if SPREAD_MOVES.include?(move.id)
        base_damage *= SPREAD_DAMAGE_MULTIPLIER
      end
      
      return base_damage
    end
    
    #===========================================================================
    # Redirection Detection
    #===========================================================================
    
    def self.has_active_redirection?(battle, side_index)
      return false unless battle.pbSideSize(0) > 1
      
      # Check all battlers on the side for redirection
      battle.allSameSideBattlers(side_index).each do |battler|
        next if battler.fainted?
        
        # Follow Me / Rage Powder effect
        return true if battler.effects[PBEffects::FollowMe] > 0
        
        # Spotlight effect
        return true if battler.effects[PBEffects::Spotlight] > 0
        
        # Lightning Rod / Storm Drain (redirects specific types)
        if REDIRECTION_ABILITIES.include?(battler.ability_id)
          return true
        end
      end
      
      return false
    end
    
    def self.score_redirection_move(user, move, battle, skill_level = 100)
      return 0 unless skill_level >= 70
      return 0 unless battle.pbSideSize(0) > 1
      return 0 unless REDIRECTION_MOVES.key?(move.id)
      
      score = 0
      
      # Protect partner from incoming attacks
      partner = user.allAllies.first
      return 0 unless partner && !partner.fainted?
      
      # High value if partner is low HP
      partner_hp_percent = AdvancedAI::CombatUtilities.hp_percent(partner)
      score += AdvancedAI::CombatUtilities.hp_threshold_score(
        partner_hp_percent,
        AdvancedAI::CombatUtilities::PARTNER_HP_CONCERN
      )
      score += 15  # Base value for setup/support
      
      # Bonus if partner is setting up
      if partner.effects[PBEffects::FocusEnergy] > 0 ||
         partner.stages[:ATTACK] > 0 || partner.stages[:SPECIAL_ATTACK] > 0
        score += 40  # Protect setup sweeper
      end
      
      # Penalty if user is frail (can't take hits)
      user_hp_percent = AdvancedAI::CombatUtilities.hp_percent(user)
      if user_hp_percent < 0.33
        score -= 60  # Can't redirect if we'll die
      elsif user_hp_percent < 0.50
        score -= 30
      end
      
      return score
    end
    
    #===========================================================================
    # Helping Hand Bonus
    #===========================================================================
    
    def self.score_helping_hand(user, target, battle, skill_level = 100)
      return 0 unless skill_level >= 75
      return 0 unless battle.pbSideSize(0) > 1
      
      score = 0
      
      # Only useful for partner (not user)
      return 0 if target.index == user.index
      return 0 unless user.allAllies.include?(target)
      
      # Check if partner has strong attacking move ready
      partner_has_strong_move = target.moves.any? do |m|
        m.damagingMove? && m.power && m.power >= 80
      end
      
      if partner_has_strong_move
        score += 60  # Boost strong attack
        
        # Extra bonus if partner can KO with boost
        # (Would require damage calc - simplified here)
        score += 40
      else
        score += 20  # Generic bonus
      end
      
      # Penalty if user could KO instead
      user_can_ko = user.moves.any? do |m|
        m.damagingMove? && m.power && m.power >= 100
      end
      
      if user_can_ko
        score -= 40  # Maybe better to attack yourself
      end
      
      return score
    end
    
    #===========================================================================
    # Fake Out Strategy
    #===========================================================================
    
    def self.score_fake_out_doubles(user, target, battle, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless battle.pbSideSize(0) > 1
      return 0 if battle.turnCount > 0  # Only Turn 1
      
      score = 0
      
      # Fake Out is CRITICAL Turn 1 in doubles
      score += 80  # High base value - flinch + free turn for partner
      
      # Bonus if partner can setup
      partner = user.allAllies.first
      if partner && !partner.fainted?
        partner_has_setup = partner.moves.any? do |m|
          [:TAILWIND, :TRICKROOM, :REFLECT, :LIGHTSCREEN].include?(m.id)
        end
        
        if partner_has_setup
          score += 60  # Free setup turn!
        end
      end
      
      # Bonus vs faster threats
      if target.pbSpeed > user.pbSpeed
        score += 30  # Prevent opponent from moving first
      end
      
      # Target Prioritization: Hit the bigger threat
      # (Simplified - would need threat assessment)
      if target.attack > 120 || target.spatk > 120
        score += 25  # Flinch the sweeper
      end
      
      return score
    end
    
    #===========================================================================
    # Protect Coordination (both partners protect = waste)
    #===========================================================================
    
    def self.score_protect_coordination(user, battle)
      return 0 unless battle.pbSideSize(0) > 1
      
      penalty = 0
      
      # Check if partner is also using Protect
      partner = user.allAllies.first
      if partner && !partner.fainted?
        # If partner used Protect last turn, don't both Protect this turn
        if partner.lastMoveUsed && [:PROTECT, :DETECT, :KINGSSHIELD, :SPIKYSHIELD, :BANEFULBUNKER].include?(partner.lastMoveUsed)
          penalty += 50  # Don't both protect - wasteful
        end
        
        # If partner is protecting this turn (check current move choice)
        # (Would need battle state tracking - simplified here)
      end
      
      return -penalty
    end
    
    #===========================================================================
    # Spread Move Target Selection
    #===========================================================================
    
    def self.prefer_spread_move?(user, battle, skill_level = 100)
      return false unless skill_level >= 80
      return false unless battle.pbSideSize(0) > 1
      
      # Check if user has spread move
      has_spread = user.moves.any? { |m| SPREAD_MOVES.include?(m.id) }
      return false unless has_spread
      
      # Prefer spread if both opponents are damaged equally
      opponents = user.allOpposing
      return false if opponents.length < 2
      
      # Check if both are weak to the spread move
      # (Simplified - would need type effectiveness calc)
      
      # Prefer spread if both opponents are low HP (can KO both)
      both_low_hp = opponents.all? { |opp| opp.hp < opp.totalhp * 0.4 }
      return true if both_low_hp
      
      return false
    end
    
    #===========================================================================
    # Wide Guard / Quick Guard Detection
    #===========================================================================
    
    def self.has_wide_guard?(side, battle)
      return false unless battle.pbSideSize(0) > 1
      
      # Check if opponent has Wide Guard active
      return side.effects[PBEffects::WideGuard] if side.effects[PBEffects::WideGuard]
      
      return false
    end
    
    def self.has_quick_guard?(side, battle)
      return false unless battle.pbSideSize(0) > 1
      
      # Check if opponent has Quick Guard active
      return side.effects[PBEffects::QuickGuard] if side.effects[PBEffects::QuickGuard]
      
      return false
    end
    
    def self.score_guard_penalty(user, move, target, battle)
      return 0 unless battle.pbSideSize(0) > 1
      
      penalty = 0
      target_side = target.pbOwnSide
      
      # Wide Guard blocks spread moves
      if has_wide_guard?(target_side, battle) && SPREAD_MOVES.include?(move.id)
        penalty += 200  # Move will fail!
      end
      
      # Quick Guard blocks priority moves
      if has_quick_guard?(target_side, battle) && move.priority > 0
        penalty += 200  # Move will fail!
      end
      
      return -penalty
    end
    
  end
end


#===============================================================================
# Integration: Hook into pbRegisterMove
#===============================================================================

class Battle::AI
  alias doubles_strategy_pbRegisterMove pbRegisterMove
  
  def pbRegisterMove(user, move)
    score = doubles_strategy_pbRegisterMove(user, move)
    
    # Skip if not doubles
    return score unless @battle.pbSideSize(0) > 1
    return score unless user && move
    
    skill_level = 100
    target = @battle.allOtherSideBattlers(user.index).find { |b| b && !b.fainted? }
    
    # Fake Out bonus (Turn 1 only)
    if move.id == :FAKEOUT && target
      score += AdvancedAI::DoublesStrategy.score_fake_out_doubles(user, target, @battle, skill_level)
    end
    
    # Redirection moves
    if AdvancedAI::DoublesStrategy::REDIRECTION_MOVES.key?(move.id)
      score += AdvancedAI::DoublesStrategy.score_redirection_move(user, move, @battle, skill_level)
    end
    
    # Helping Hand
    if move.id == :HELPINGHAND && target
      score += AdvancedAI::DoublesStrategy.score_helping_hand(user, target, @battle, skill_level)
    end
    
    # Protect coordination penalty
    if [:PROTECT, :DETECT, :KINGSSHIELD, :SPIKYSHIELD, :BANEFULBUNKER].include?(move.id)
      score += AdvancedAI::DoublesStrategy.score_protect_coordination(user, @battle)
    end
    
    # Wide Guard / Quick Guard penalties
    if target
      guard_penalty = AdvancedAI::DoublesStrategy.score_guard_penalty(user, move, target, @battle)
      score += guard_penalty
    end
    
    return score
  end
end


### FILE: Pivot_Moves.rb ###
#===============================================================================
# Advanced AI System - Pivot Moves
# U-turn, Volt Switch, Flip Turn, Parting Shot, Teleport coordination
#===============================================================================

module AdvancedAI
  module PivotMoves
    #===========================================================================
    # Pivot Move Definitions
    #===========================================================================
    
    OFFENSIVE_PIVOTS = [:UTURN, :VOLTSWITCH, :FLIPTURN]
    DEFENSIVE_PIVOTS = [:PARTINGSHOT, :TELEPORT, :BATONPASS, :CHILLYRECEPTION]
    SLOW_PIVOTS = [:TELEPORT]  # Move last for safe switch
    
    ALL_PIVOTS = OFFENSIVE_PIVOTS + DEFENSIVE_PIVOTS
    
    #===========================================================================
    # Pivot Decision Making
    #===========================================================================
    
    # Should we pivot or stay in?
    def self.evaluate_pivot(battle, attacker, move, target, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless ALL_PIVOTS.include?(move.id)
      
      score = 0
      
      # Offensive pivot evaluation
      if OFFENSIVE_PIVOTS.include?(move.id)
        score += evaluate_offensive_pivot(battle, attacker, move, target, skill_level)
      end
      
      # Defensive pivot evaluation
      if DEFENSIVE_PIVOTS.include?(move.id)
        score += evaluate_defensive_pivot(battle, attacker, move, skill_level)
      end
      
      # Slow pivot bonus
      if SLOW_PIVOTS.include?(move.id)
        score += evaluate_slow_pivot(battle, attacker, skill_level)
      end
      
      score
    end
    
    #===========================================================================
    # Offensive Pivots (U-turn, Volt Switch, Flip Turn)
    #===========================================================================
    
    def self.evaluate_offensive_pivot(battle, attacker, move, target, skill_level)
      score = 0
      
      # Check type effectiveness
      if target
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        
        if Effectiveness.ineffective?(type_mod)
          return -50  # Volt Switch blocked by Ground
        elsif Effectiveness.super_effective?(type_mod)
          score += 20  # Good damage + switch
        elsif Effectiveness.not_very_effective?(type_mod)
          score -= 10
        end
      end
      
      # Do we have a better switch-in available?
      switch_in = find_best_switch_in(battle, attacker, target, skill_level)
      if switch_in
        score += 25
      else
        score -= 15  # No good switch target
      end
      
      # Are we at a disadvantage?
      if target && at_type_disadvantage?(attacker, target)
        score += 30  # Get out while dealing damage
      end
      
      # Do we have momentum?
      # Pivoting maintains offensive pressure
      if is_offensive_team?(battle, attacker)
        score += 15
      end
      
      # Hazards on their side = pivot is good
      opp_side = battle.sides[(attacker.index + 1) % 2]
      if opp_side.effects[PBEffects::StealthRock]
        score += 10  # They take rocks on switch
      end
      
      # Hazards on our side = pivot is risky
      our_side = battle.sides[attacker.index % 2]
      if our_side.effects[PBEffects::StealthRock]
        score -= 10  # Our switch takes rocks
      end
      
      # Check if opponent is locked into bad move
      if target && target.effects[PBEffects::ChoiceBand]
        if target.lastMoveUsed
          last_move = GameData::Move.try_get(target.lastMoveUsed)
          if last_move
            # They're locked - bring in a counter
            type_mod = Effectiveness.calculate(last_move.type, *attacker.pbTypes(true))
            if Effectiveness.not_very_effective?(type_mod)
              score += 20  # Pivot to something that resists better
            end
          end
        end
      end
      
      score
    end
    
    #===========================================================================
    # Defensive Pivots (Parting Shot, Teleport, Baton Pass)
    #===========================================================================
    
    def self.evaluate_defensive_pivot(battle, attacker, move, skill_level)
      score = 0
      
      case move.id
      when :PARTINGSHOT
        score += evaluate_parting_shot(battle, attacker, skill_level)
      when :TELEPORT
        score += evaluate_teleport(battle, attacker, skill_level)
      when :BATONPASS
        score += evaluate_baton_pass(battle, attacker, skill_level)
      when :CHILLYRECEPTION
        score += evaluate_chilly_reception(battle, attacker, skill_level)
      end
      
      score
    end
    
    # Parting Shot: Lower Attack + SpAtk, then switch
    def self.evaluate_parting_shot(battle, attacker, skill_level)
      score = 0
      
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      
      # Best against physical/special attackers
      high_offense = opponents.count { |o| o.attack >= 100 || o.spatk >= 100 }
      score += high_offense * 15
      
      # Check if stats can be lowered
      opponents.each do |opp|
        if opp.stages[:ATTACK] > -6 || opp.stages[:SPECIAL_ATTACK] > -6
          score += 20
        else
          score -= 30  # Already at -6
        end
        
        # Clear Body / White Smoke / etc. block
        if [:CLEARBODY, :WHITESMOKE, :FULLMETALBODY].include?(opp.ability_id)
          score -= 40
        end
      end
      
      # Need switch target
      switch_in = find_best_switch_in(battle, attacker, opponents.first, skill_level)
      if switch_in
        score += 20
      else
        score -= 25
      end
      
      score
    end
    
    # Teleport: Always moves last, safe switch
    def self.evaluate_teleport(battle, attacker, skill_level)
      score = 0
      
      # Teleport is -6 priority - we move last
      # Perfect for bringing in frail sweepers
      
      party = battle.pbParty(attacker.index)
      frail_sweepers = party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted? && pkmn != attacker.pokemon
        # Frail but strong
        (pkmn.attack >= 120 || pkmn.spatk >= 120) && 
        (pkmn.defense < 80 || pkmn.spdef < 80)
      end
      
      score += frail_sweepers * 20
      
      # Good if we're not doing much damage anyway
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      can_damage = opponents.any? do |opp|
        attacker.moves.any? do |m|
          next false unless m && m.damagingMove?
          type_mod = Effectiveness.calculate(m.type, *opp.pbTypes(true))
          Effectiveness.super_effective?(type_mod) || type_mod >= Effectiveness::NORMAL_EFFECTIVE
        end
      end
      
      unless can_damage
        score += 30  # We're not threatening anyway
      end
      
      # Wish + Teleport combo
      if attacker.effects[PBEffects::Wish] && attacker.effects[PBEffects::Wish] > 0
        # Wish will heal next turn - Teleport passes it
        score += 35
      end
      
      score
    end
    
    # Baton Pass: Pass stat boosts
    def self.evaluate_baton_pass(battle, attacker, skill_level)
      score = 0
      
      # Check if we have boosts to pass
      total_boosts = 0
      attacker.stages.each do |stat, stage|
        total_boosts += stage if stage > 0
      end
      
      score += total_boosts * 15
      
      # Substitute to pass?
      if attacker.effects[PBEffects::Substitute] && attacker.effects[PBEffects::Substitute] > 0
        score += 35
      end
      
      # Aqua Ring, Magnet Rise, etc.
      if attacker.effects[PBEffects::AquaRing]
        score += 20
      end
      if attacker.effects[PBEffects::MagnetRise] && attacker.effects[PBEffects::MagnetRise] > 0
        score += 25
      end
      if attacker.effects[PBEffects::Ingrain]
        score += 15
      end
      
      # Need recipient
      party = battle.pbParty(attacker.index)
      recipients = party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted? && pkmn != attacker.pokemon
        # Can make use of boosts
        pkmn.attack >= 100 || pkmn.spatk >= 100
      end
      
      if recipients > 0
        score += 20
      else
        score -= 30  # No one to pass to
      end
      
      score
    end
    
    # Chilly Reception: Sets Snow + switches
    def self.evaluate_chilly_reception(battle, attacker, skill_level)
      score = 0
      
      # Sets Snow weather
      if battle.field.weather == :Snow || battle.field.weather == :Hail
        score -= 30  # Already snowy
      end
      
      # Check if team benefits from Snow
      party = battle.pbParty(attacker.index)
      ice_types = party.count { |p| p && !p.fainted? && p.hasType?(:ICE) }
      score += ice_types * 15
      
      # Slush Rush users
      slush_rush = party.count { |p| p && !p.fainted? && p.ability_id == :SLUSHRUSH }
      score += slush_rush * 25
      
      # Aurora Veil enabler
      score += 20  # Snow allows Aurora Veil
      
      score
    end
    
    #===========================================================================
    # Slow Pivot Evaluation
    #===========================================================================
    
    def self.evaluate_slow_pivot(battle, attacker, skill_level)
      score = 0
      
      # Slow pivots are great for bringing in frail mons safely
      # The current mon takes the hit, then switches out
      
      # Good if we're bulky
      if attacker.defense >= 100 || attacker.spdef >= 100
        score += 20  # We can tank a hit
      end
      
      # Good if low HP (gonna faint anyway, might as well switch safely)
      hp_percent = attacker.hp.to_f / attacker.totalhp
      if hp_percent < 0.3
        score += 25
      end
      
      score
    end
    
    #===========================================================================
    # Pivot Target Selection
    #===========================================================================
    
    # Find the best Pokemon to pivot into
    def self.find_best_switch_in(battle, attacker, opponent, skill_level)
      return nil unless skill_level >= 60
      
      party = battle.pbParty(attacker.index)
      
      candidates = []
      party.each do |pkmn|
        next unless pkmn && !pkmn.fainted? && pkmn != attacker.pokemon
        
        candidate_score = 0
        
        if opponent
          # Type advantage (pkmn is party Pokemon, use .types)
          pkmn_types = pkmn.types.compact
          
          # Resists opponent's STAB
          opp_stab = opponent.pbTypes(true).compact
          opp_stab.each do |opp_type|
            pkmn_types.each do |our_type|
              type_mod = Effectiveness.calculate(opp_type, our_type, nil)
              if Effectiveness.not_very_effective?(type_mod)
                candidate_score += 20
              elsif Effectiveness.ineffective?(type_mod)
                candidate_score += 40
              end
            end
          end
          
          # Can threaten opponent
          pkmn.moves.each do |move|
            next unless move && move.is_a?(Pokemon::Move)
            move_data = GameData::Move.try_get(move.id)
            next unless move_data
            if move_data.category < 2  # Physical or Special (damaging)
              type_mod = Effectiveness.calculate(move.type, *opponent.pbTypes(true))
              if Effectiveness.super_effective?(type_mod)
                candidate_score += 25
              end
            end
          end
        end
        
        # HP remaining
        hp_percent = pkmn.hp.to_f / pkmn.totalhp
        candidate_score += (hp_percent * 30).to_i
        
        candidates << { pokemon: pkmn, score: candidate_score }
      end
      
      best = candidates.max_by { |c| c[:score] }
      best && best[:score] > 20 ? best[:pokemon] : nil
    end
    
    #===========================================================================
    # Pivot vs Attack Decision
    #===========================================================================
    
    # Should we pivot or just attack?
    def self.pivot_vs_attack(battle, attacker, pivot_move, attack_move, target, skill_level = 100)
      return :attack unless skill_level >= 65
      return :pivot unless attack_move
      return :attack unless pivot_move
      
      pivot_score = evaluate_pivot(battle, attacker, pivot_move, target, skill_level)
      
      # Calculate attack value
      attack_score = 0
      if attack_move.damagingMove? && target
        type_mod = Effectiveness.calculate(attack_move.type, *target.pbTypes(true))
        
        if Effectiveness.super_effective?(type_mod)
          attack_score += 40
        end
        
        if attack_move.power >= 100
          attack_score += 20
        end
        
        # Can we KO?
        estimated_damage = estimate_damage_percent(attacker, target, attack_move)
        if estimated_damage >= 100
          attack_score += 50  # KO is high value
        end
      end
      
      pivot_score > attack_score ? :pivot : :attack
    end
    
    #===========================================================================
    # Helper Methods
    #===========================================================================
    private
    
    def self.at_type_disadvantage?(user, target)
      return false unless target
      
      # Check if opponent's STAB is super effective
      target_stab = target.pbTypes(true).compact
      
      target_stab.any? do |type|
        type_mod = Effectiveness.calculate(type, *user.pbTypes(true))
        Effectiveness.super_effective?(type_mod)
      end
    end
    
    def self.is_offensive_team?(battle, attacker)
      # Heuristic: Check team composition
      party = battle.pbParty(attacker.index)
      
      offensive = party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted?
        pkmn.attack >= 100 || pkmn.spatk >= 100
      end
      
      offensive >= 3
    end
    
    def self.estimate_damage_percent(attacker, target, move)
      return 0 unless move && move.damagingMove?
      
      power = move.power
      return 0 if power == 0
      
      if move.physicalMove?
        atk = attacker.attack
        dfn = target.defense
      else
        atk = attacker.spatk
        dfn = target.spdef
      end
      
      damage = ((2 * attacker.level / 5 + 2) * power * atk / dfn / 50 + 2)
      
      # STAB
      if attacker.pbHasType?(move.type)
        damage *= 1.5
      end
      
      # Type effectiveness
      type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
      damage *= type_mod / Effectiveness::NORMAL_EFFECTIVE
      
      (damage / target.totalhp.to_f) * 100
    end
  end
end

# API Methods
module AdvancedAI
  def self.evaluate_pivot(battle, attacker, move, target, skill_level = 100)
    PivotMoves.evaluate_pivot(battle, attacker, move, target, skill_level)
  end
  
  def self.find_best_switch_in(battle, attacker, opponent, skill_level = 100)
    PivotMoves.find_best_switch_in(battle, attacker, opponent, skill_level)
  end
  
  def self.pivot_vs_attack(battle, attacker, pivot_move, attack_move, target, skill_level = 100)
    PivotMoves.pivot_vs_attack(battle, attacker, pivot_move, attack_move, target, skill_level)
  end
  
  def self.is_pivot_move?(move)
    return false unless move
    PivotMoves::ALL_PIVOTS.include?(move.id)
  end
end

AdvancedAI.log("Pivot Moves System loaded", "Pivot")
AdvancedAI.log("  - U-turn / Volt Switch / Flip Turn", "Pivot")
AdvancedAI.log("  - Parting Shot evaluation", "Pivot")
AdvancedAI.log("  - Teleport (slow pivot)", "Pivot")
AdvancedAI.log("  - Baton Pass optimization", "Pivot")
AdvancedAI.log("  - Chilly Reception (Snow + pivot)", "Pivot")
AdvancedAI.log("  - Switch-in target selection", "Pivot")
AdvancedAI.log("  - Pivot vs Attack decision making", "Pivot")

### FILE: Priority_Tiers.rb ###
#===============================================================================
# Advanced AI System - Priority Move Tier System
# Distinguishes between priority levels for optimal move selection
#===============================================================================

module AdvancedAI
  module PriorityTiers
    
    #===========================================================================
    # Priority Move Categories
    #===========================================================================
    
    # Priority +4
    PRIORITY_PLUS_4 = [:HELPINGHAND]
    
    # Priority +3
    PRIORITY_PLUS_3 = [:MAGICCOAT, :SNATCH, :BANEFULBUNKER, :OBSTRUCT,
                       :KINGSSHIELD, :SPIKYSHIELD, :CRAFTYSHIELD]
    
    # Priority +2
    PRIORITY_PLUS_2 = [:EXTREMESPEED, :FEINT, :FOLLOWME, :RAGEPOWDER,
                       :FIRSTIMPRESSION]
    
    # Priority +1 (Most common)
    PRIORITY_PLUS_1 = [
      :ACCELEROCK, :AQUAJET, :BULLETPUNCH, :ICESHARD, :MACHPUNCH,
      :QUICKATTACK, :SHADOWSNEAK, :SUCKERPUNCH, :VACUUMWAVE,
      :WATERSHURIKEN, :JETPUNCH, :ZIPZAP, :GRASSYGLIDE
    ]
    
    # Priority +0 (Normal moves)
    # ... all other moves
    
    # Priority -1 to -7 (Negative priority)
    NEGATIVE_PRIORITY = {
      :VITALTHROW => -1,
      :BEAKBLAST => -3,
      :FOCUSPUNCH => -3,
      :AVALANCHE => -4,
      :REVENGE => -4,
      :COUNTER => -5,
      :MIRRORCOAT => -5,
      :ROAR => -6,
      :WHIRLWIND => -6,
      :TRICKROOM => -7
    }
    
    #===========================================================================
    # Get Priority Level
    #===========================================================================
    
    def self.get_priority_tier(move)
      return 0 unless move
      
      # Check move's inherent priority
      base_priority = move.priority || 0
      
      # For conditional priority moves (e.g., Grassy Glide in Grassy Terrain)
      # This would need battle state context
      
      return base_priority
    end
    
    #===========================================================================
    # Priority Move Scoring
    #===========================================================================
    
    def self.score_priority_advantage(user, move, target, battle, skill_level = 100)
      return 0 unless skill_level >= 60
      return 0 unless move
      
      move_priority = get_priority_tier(move)
      return 0 if move_priority == 0  # Not a priority move
      
      score = 0
      
      # === POSITIVE PRIORITY ===
      if move_priority > 0
        # Check speed comparison
        user_speed = user.pbSpeed
        target_speed = target.pbSpeed
        
        # Priority is most valuable when we're slower
        if target_speed > user_speed
          score += 40 * move_priority  # Higher priority = more valuable
          
          # Extra bonus if we're MUCH slower
          speed_ratio = target_speed.to_f / [user_speed, 1].max
          if speed_ratio >= 2.0
            score += 30  # Completely outclassed in speed
          elsif speed_ratio >= 1.5
            score += 20
          end
          
          # Bonus if user is low HP (desperation)
          user_hp_percent = AdvancedAI::CombatUtilities.hp_percent(user)
          score += AdvancedAI::CombatUtilities.hp_threshold_score(
            user_hp_percent,
            { 0.33 => 50, 0.50 => 30 }
          )
          
          # Bonus if target is low HP (secure KO)
          target_hp_percent = AdvancedAI::CombatUtilities.hp_percent(target)
          if target_hp_percent < 0.33 && move.damagingMove?
            score += 60  # Guaranteed KO before they move
          elsif target_hp_percent < 0.50 && move.damagingMove?
            score += 40
          end
          
        else
          # We're already faster - priority is less valuable
          score += 10 * move_priority  # Small bonus
        end
        
        # === PRIORITY TIER BONUSES ===
        case move_priority
        when 4
          # Helping Hand: +50% damage to partner (doubles only)
          score += 40 if battle.pbSideSize(0) > 1
          
        when 3
          # Protection moves (King's Shield, Baneful Bunker, etc.)
          # High value if opponent is boosted or we're low HP
          if AdvancedAI::CombatUtilities.total_stat_boosts(target) > 2
            score += 50  # Protect vs boosted opponent
          end
          
          user_hp_percent = AdvancedAI::CombatUtilities.hp_percent(user)
          score += 60 if user_hp_percent < 0.33
          
        when 2
          # Extreme Speed, Feint, Follow Me
          if move.id == :EXTREMESPEED
            score += 30  # Very reliable priority damage
          elsif move.id == :FEINT
            # Bonus vs Protect users
            if target.effects[PBEffects::Protect]
              score += 80  # Bypass Protect!
            end
          elsif [:FOLLOWME, :RAGEPOWDER].include?(move.id)
            # Redirection in doubles
            score += 50 if battle.pbSideSize(0) > 1
          end
          
        when 1
          # Standard priority (Aqua Jet, Mach Punch, etc.)
          # Already scored above, but add type-specific bonuses
          
          # Sucker Punch: Only works if opponent attacks
          if move.id == :SUCKERPUNCH
            # Penalty if opponent is likely to use status move
            if target.lastMoveUsed
              last_move_data = GameData::Move.try_get(target.lastMoveUsed)
              if last_move_data && last_move_data.statusMove?
                score -= 100  # Likely to fail!
              end
            end
          end
          
          # Grassy Glide: Priority only in Grassy Terrain
          if move.id == :GRASSYGLIDE
            terrain = battle.field.terrain rescue nil
            if terrain != :Grassy
              score -= 40  # No priority boost
            end
          end
        end
      end
      
      # === NEGATIVE PRIORITY ===
      if move_priority < 0
        # Negative priority is usually BAD (move last)
        score -= 20 * move_priority.abs
        
        # EXCEPTIONS:
        
        # Trick Room: Intentionally move last to activate field
        if move.id == :TRICKROOM
          # Trick Room is valuable for slow teams
          if user_speed < 50
            score += 100  # Slow Pokemon loves Trick Room
          end
          
          # Check if already active (toggle off)
          if battle.field.effects[PBEffects::TrickRoom] > 0
            score -= 50  # Don't want to turn it off (usually)
          end
        end
        
        # Counter / Mirror Coat: Need to take hit first
        if [:COUNTER, :MIRRORCOAT].include?(move.id)
          # Bonus if we can survive and OHKO back
          user_hp_percent = AdvancedAI::CombatUtilities.hp_percent(user)
          if user_hp_percent > 0.70
            score += 60  # Healthy - can survive to counter
          else
            score -= 40  # Too risky if low HP
          end
        end
        
        # Avalanche / Revenge: Double power if hit first
        if [:AVALANCHE, :REVENGE].include?(move.id)
          # Bonus if we're bulky enough to survive
          if user.defense + user.spdef > 200
            score += 40  # Tanky - can take hit for 2x power
          end
        end
      end
      
      # === PRANKSTER ABILITY ===
      # Prankster gives status moves +1 priority
      if user.hasActiveAbility?(:PRANKSTER) && move.statusMove?
        # Treat as priority +1
        if target_speed > user_speed
          score += 50  # Status move goes first!
        else
          score += 20
        end
        
        # EXCEPTION: Dark-types are immune to Prankster
        if target.pbHasType?(:DARK)
          score -= 200  # Move will fail!
        end
      end
      
      # === GALE WINGS ABILITY ===
      # Gale Wings gives Flying moves priority at full HP
      if user.hasActiveAbility?(:GALEWINGS) && move.type == :FLYING
        user_hp_percent = AdvancedAI::CombatUtilities.hp_percent(user)
        if user_hp_percent >= 1.0
          # Treat as priority +1
          score += 40 if target_speed > user_speed
        end
      end
      
      # === TRIAGE ABILITY ===
      # Triage gives healing moves +3 priority
      if user.hasActiveAbility?(:TRIAGE) && move.healingMove?
        # Massive bonus - heal before getting hit
        user_hp_percent = AdvancedAI::CombatUtilities.hp_percent(user)
        if user_hp_percent < 0.50
          score += 80  # Critical healing
        else
          score += 40
        end
      end
      
      return score
    end
    
    #===========================================================================
    # Check for Priority Move Availability
    #===========================================================================
    
    def self.has_priority_move?(user)
      return false unless user
      
      user.moves.each do |move|
        return true if move && get_priority_tier(move) > 0
      end
      
      return false
    end
    
    def self.get_best_priority_move(user, target, battle)
      return nil unless user
      
      best_move = nil
      best_score = -999999
      
      user.moves.each do |move|
        next unless move
        next if get_priority_tier(move) <= 0  # Not a priority move
        
        score = score_priority_advantage(user, move, target, battle)
        if score > best_score
          best_score = score
          best_move = move
        end
      end
      
      return best_move
    end
    
  end
end


#===============================================================================
# Integration: Hook into pbRegisterMove
#===============================================================================

class Battle::AI
  alias priority_tiers_pbRegisterMove pbRegisterMove
  
  def pbRegisterMove(user, move)
    score = priority_tiers_pbRegisterMove(user, move)
    
    return score unless user && move
    
    skill_level = 100
    target = @battle.allOtherSideBattlers(user.index).find { |b| b && !b.fainted? }
    
    # Apply priority tier bonus/penalty
    if target
      priority_score = AdvancedAI::PriorityTiers.score_priority_advantage(user, move, target, @battle, skill_level)
      score += priority_score
    end
    
    return score
  end
end

### FILE: Speed_Tiers.rb ###
#===============================================================================
# Advanced AI System - Speed Tiers
# Speed tier awareness, Scarf detection, effective speed calculations
#===============================================================================

module AdvancedAI
  module SpeedTiers
    #===========================================================================
    # Speed Tier Definitions (VGC Meta)
    #===========================================================================
    SPEED_TIERS = {
      ultra_fast: { min: 130, name: "Ultra Fast (130+)" },      # Regieleki, Electrode
      very_fast: { min: 110, name: "Very Fast (110-129)" },     # Weavile, Gengar
      fast: { min: 95, name: "Fast (95-109)" },                 # Garchomp, Hydreigon
      medium_fast: { min: 80, name: "Medium-Fast (80-94)" },    # Gyarados, Dragonite
      medium: { min: 60, name: "Medium (60-79)" },              # Tyranitar, Gastrodon
      slow: { min: 40, name: "Slow (40-59)" },                  # Ferrothorn, Dondozo
      very_slow: { min: 0, name: "Very Slow (<40)" }            # Trick Room mons
    }
    
    # Common Scarf benchmarks (base speeds that commonly run Scarf)
    COMMON_SCARF_USERS = [
      :LANDORUS, :LANDORUSTHERIAN, :URSHIFU, :URSHIFURAPIDSTRIKE,
      :DARMANITAN, :DITTO, :EXCADRILL, :HYDREIGON, :KARTANA,
      :TYRANITAR, :MAGNEZONE, :ROTOMWASH, :ROTOMHEAT,
      :GARCHOMP, :SALAMENCE, :CHANDELURE, :GOTHITELLE
    ]
    
    #===========================================================================
    # Effective Speed Calculation
    #===========================================================================
    
    # Calculate actual speed including all modifiers
    def self.calculate_effective_speed(battle, battler)
      return 0 unless battler && !battler.fainted?
      
      # Base speed with stages
      speed = battler.speed
      
      # Stat stage modifier
      stage = battler.stages[:SPEED] || 0
      if stage >= 0
        speed = speed * (2 + stage) / 2
      else
        speed = speed * 2 / (2 - stage)
      end
      
      # Paralysis halves speed (Gen 7+: 50%)
      if battler.status == :PARALYSIS
        speed /= 2 unless battler.ability_id == :QUICKFEET
      end
      
      # Abilities
      case battler.ability_id
      when :SWIFTSWIM
        if battle.field.weather == :Rain
          speed *= 2
        end
      when :CHLOROPHYLL
        if battle.field.weather == :Sun
          speed *= 2
        end
      when :SANDRUSH
        if battle.field.weather == :Sandstorm
          speed *= 2
        end
      when :SLUSHRUSH
        if [:Hail, :Snow].include?(battle.field.weather)
          speed *= 2
        end
      when :UNBURDEN
        if battler.effects[PBEffects::Unburden] # Item consumed
          speed *= 2
        end
      when :QUICKFEET
        if battler.status != :NONE
          speed = speed * 1.5
        end
      when :SLOWSTART
        if battler.effects[PBEffects::SlowStart] && battler.effects[PBEffects::SlowStart] > 0
          speed /= 2
        end
      end
      
      # Items
      case battler.item_id
      when :CHOICESCARF
        speed = speed * 1.5
      when :IRONBALL
        speed /= 2
      when :MACHOBRACE, :POWERANKLET, :POWERBAND, :POWERBELT,
           :POWERBRACER, :POWERLENS, :POWERWEIGHT
        speed /= 2
      when :QUICKPOWDER
        if battler.species == :DITTO && !battler.effects[PBEffects::Transform]
          speed *= 2
        end
      end
      
      # Tailwind
      own_side = battle.sides[battler.index % 2]
      if own_side.effects[PBEffects::Tailwind] && own_side.effects[PBEffects::Tailwind] > 0
        speed *= 2
      end
      
      # Sticky Web
      # Note: Already applied as stage drop, no additional calc needed
      
      speed.to_i
    end
    
    # Compare speeds considering Trick Room
    def self.compare_speed(battle, battler1, battler2)
      speed1 = calculate_effective_speed(battle, battler1)
      speed2 = calculate_effective_speed(battle, battler2)
      
      trick_room = battle.field.effects[PBEffects::TrickRoom] &&
                   battle.field.effects[PBEffects::TrickRoom] > 0
      
      if trick_room
        # Slower moves first in Trick Room
        if speed1 < speed2
          return 1  # battler1 goes first
        elsif speed1 > speed2
          return -1  # battler2 goes first
        end
      else
        # Faster moves first normally
        if speed1 > speed2
          return 1
        elsif speed1 < speed2
          return -1
        end
      end
      
      0  # Speed tie
    end
    
    # Check if battler1 outspeeds battler2
    def self.outspeeds?(battle, battler1, battler2)
      compare_speed(battle, battler1, battler2) > 0
    end
    
    #===========================================================================
    # Speed Tier Analysis
    #===========================================================================
    
    def self.get_speed_tier(base_speed)
      SPEED_TIERS.each do |tier, data|
        if base_speed >= data[:min]
          return tier
        end
      end
      :very_slow
    end
    
    def self.in_same_speed_tier?(battler1, battler2)
      tier1 = get_speed_tier(battler1.speed)
      tier2 = get_speed_tier(battler2.speed)
      tier1 == tier2
    end
    
    #===========================================================================
    # Choice Scarf Detection
    #===========================================================================
    
    # Suspect opponent has Choice Scarf
    def self.suspect_choice_scarf?(battle, battler, skill_level = 100)
      return false unless skill_level >= 70
      return false unless battler
      
      # Already revealed item
      return battler.item_id == :CHOICESCARF if battler.item_id
      
      # Common Scarf users
      if COMMON_SCARF_USERS.include?(battler.species)
        return true
      end
      
      # Moved first when they shouldn't have?
      # This would require tracking turn order history
      # For now, use species heuristics
      
      # Check if they're Choice-locked (same move twice)
      if battler.effects[PBEffects::ChoiceBand]
        # They're Choice locked - could be Scarf
        return true if battler.speed >= 80 && battler.speed <= 100
      end
      
      false
    end
    
    # Calculate "what if they have Scarf" speed
    def self.scarf_adjusted_speed(battle, battler)
      base_speed = calculate_effective_speed(battle, battler)
      
      # If already has Scarf, return as-is
      return base_speed if battler.item_id == :CHOICESCARF
      
      # Calculate potential Scarf speed
      (base_speed * 1.5).to_i
    end
    
    # Would we still outspeed if they have Scarf?
    def self.outspeeds_with_scarf?(battle, user, target)
      our_speed = calculate_effective_speed(battle, user)
      their_scarf_speed = scarf_adjusted_speed(battle, target)
      
      trick_room = battle.field.effects[PBEffects::TrickRoom] &&
                   battle.field.effects[PBEffects::TrickRoom] > 0
      
      if trick_room
        our_speed < their_scarf_speed
      else
        our_speed > their_scarf_speed
      end
    end
    
    #===========================================================================
    # Speed Control Evaluation
    #===========================================================================
    
    # Evaluate speed control moves
    def self.evaluate_speed_control(battle, attacker, move, skill_level = 100)
      return 0 unless skill_level >= 60
      
      score = 0
      
      case move.id
      when :TAILWIND
        score += evaluate_tailwind_value(battle, attacker, skill_level)
      when :TRICKROOM
        score += evaluate_trick_room_value(battle, attacker, skill_level)
      when :ICYWIND, :ELECTROWEB, :BULLDOZE, :ROCKTOMB, :LOWSWEEP
        score += evaluate_speed_drop_attack(battle, attacker, move, skill_level)
      when :STICKYWEB
        score += evaluate_sticky_web(battle, attacker, skill_level)
      when :STRINGSHOT, :COTTONSPORE, :SCARYFACE
        score += evaluate_speed_drop_status(battle, attacker, move, skill_level)
      end
      
      score
    end
    
    # Tailwind value
    def self.evaluate_tailwind_value(battle, attacker, skill_level)
      return 0 if skill_level < 65
      
      score = 0
      own_side = battle.sides[attacker.index % 2]
      
      # Already have Tailwind?
      if own_side.effects[PBEffects::Tailwind] && own_side.effects[PBEffects::Tailwind] > 0
        return -80  # Already active
      end
      
      # Count speed matchups
      allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      
      currently_outspeed = 0
      would_outspeed = 0
      
      allies.each do |ally|
        opponents.each do |opp|
          ally_speed = calculate_effective_speed(battle, ally)
          opp_speed = calculate_effective_speed(battle, opp)
          
          currently_outspeed += 1 if ally_speed > opp_speed
          would_outspeed += 1 if (ally_speed * 2) > opp_speed
        end
      end
      
      # Value based on speed matchup improvement
      improvement = would_outspeed - currently_outspeed
      score += improvement * 20
      
      # Base value for Tailwind
      score += 25 if improvement > 0
      
      score
    end
    
    # Trick Room value
    def self.evaluate_trick_room_value(battle, attacker, skill_level)
      return 0 if skill_level < 70
      
      score = 0
      
      # Check if TR is active
      tr_active = battle.field.effects[PBEffects::TrickRoom] &&
                  battle.field.effects[PBEffects::TrickRoom] > 0
      
      if tr_active
        # We might want to reset TR (cancel it)
        # Only if TR is bad for us
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        our_slow = allies.count { |a| a.speed < 60 }
        their_slow = opponents.count { |o| o.speed < 60 }
        
        if their_slow > our_slow
          score += 40  # Cancel their TR
        else
          score -= 60  # Don't cancel our TR
        end
      else
        # Set TR
        allies = battle.allSameSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
        
        our_slow = allies.count { |a| a.speed < 60 }
        their_slow = opponents.count { |o| o.speed < 60 }
        
        if our_slow > their_slow
          score += 50 + (our_slow * 15)  # We benefit from TR
        else
          score -= 30  # TR helps them more
        end
      end
      
      score
    end
    
    # Speed-dropping attacks
    def self.evaluate_speed_drop_attack(battle, attacker, move, skill_level)
      return 0 if skill_level < 55
      
      score = 0
      
      opponents = battle.allOtherSideBattlers(attacker.index).select { |b| b && !b.fainted? }
      
      # How many opponents would we flip speed on?
      flips = 0
      opponents.each do |opp|
        our_speed = calculate_effective_speed(battle, attacker)
        their_speed = calculate_effective_speed(battle, opp)
        
        # If we're slower but would be faster after their speed drops
        if their_speed > our_speed
          # -1 speed stage = 2/3 speed
          new_their_speed = (their_speed * 2 / 3)
          if our_speed > new_their_speed
            flips += 1
          end
        end
      end
      
      score += flips * 20
      
      # Spread moves get bonus
      if [:ICYWIND, :ELECTROWEB, :BULLDOZE].include?(move.id)
        score += 10  # Hits multiple
      end
      
      score
    end
    
    # Sticky Web
    def self.evaluate_sticky_web(battle, attacker, skill_level)
      return 0 if skill_level < 65
      
      score = 0
      opp_side = battle.sides[(attacker.index + 1) % 2]
      
      # Already up?
      if opp_side.effects[PBEffects::StickyWeb]
        return -80
      end
      
      # Check opponent's back line speeds
      opp_party = battle.pbParty((attacker.index + 1) % 2)
      grounded_fast = opp_party.count do |pkmn|
        next false unless pkmn && !pkmn.fainted?
        # Fast and grounded (pkmn is party Pokemon, use hasType? and ability_id)
        pkmn.speed >= 80 && !pkmn.hasType?(:FLYING) && pkmn.ability_id != :LEVITATE
      end
      
      score += grounded_fast * 15
      score += 20 if grounded_fast >= 2
      
      score
    end
    
    # Pure speed drop status moves
    def self.evaluate_speed_drop_status(battle, attacker, move, skill_level)
      return 0 if skill_level < 60
      
      # Similar to speed drop attacks but single target
      10
    end
    
    #===========================================================================
    # Speed Tie Handling
    #===========================================================================
    
    def self.is_speed_tie?(battle, battler1, battler2)
      compare_speed(battle, battler1, battler2) == 0
    end
    
    # In speed ties, consider worst case
    def self.evaluate_speed_tie_risk(battle, user, target, skill_level = 100)
      return 0 unless skill_level >= 75
      return 0 unless is_speed_tie?(battle, user, target)
      
      # 50/50 speed tie - consider if losing is bad
      score = 0
      
      # Check if opponent could OHKO us
      target.moves.each do |move|
        next unless move && move.damagingMove?
        
        # Estimate if this could OHKO
        type_mod = Effectiveness.calculate(move.type, user.types[0], user.types[1])
        if Effectiveness.super_effective?(type_mod)
          # They have a SE move - speed tie is risky
          score -= 15
        end
      end
      
      score
    end
    
    private
    
    # Helper for tracking turn order (future enhancement)
    def self.record_turn_order(battle, first_battler, second_battler)
      # Could track to detect Scarf users
    end
  end
end

# API Methods
module AdvancedAI
  def self.calculate_effective_speed(battle, battler)
    SpeedTiers.calculate_effective_speed(battle, battler)
  end
  
  def self.outspeeds?(battle, battler1, battler2)
    SpeedTiers.outspeeds?(battle, battler1, battler2)
  end
  
  def self.get_speed_tier(battler)
    SpeedTiers.get_speed_tier(battler.speed)
  end
  
  def self.suspect_choice_scarf?(battle, battler, skill_level = 100)
    SpeedTiers.suspect_choice_scarf?(battle, battler, skill_level)
  end
  
  def self.outspeeds_with_scarf?(battle, user, target)
    SpeedTiers.outspeeds_with_scarf?(battle, user, target)
  end
  
  def self.evaluate_speed_control(battle, attacker, move, skill_level = 100)
    SpeedTiers.evaluate_speed_control(battle, attacker, move, skill_level)
  end
  
  def self.is_speed_tie?(battle, battler1, battler2)
    SpeedTiers.is_speed_tie?(battle, battler1, battler2)
  end
  
  def self.evaluate_speed_tie_risk(battle, user, target, skill_level = 100)
    SpeedTiers.evaluate_speed_tie_risk(battle, user, target, skill_level)
  end
end

AdvancedAI.log("Speed Tiers System loaded", "Speed")
AdvancedAI.log("  - Effective speed calculation", "Speed")
AdvancedAI.log("  - Weather ability speed boosts", "Speed")
AdvancedAI.log("  - Tailwind / Trick Room awareness", "Speed")
AdvancedAI.log("  - Choice Scarf detection", "Speed")
AdvancedAI.log("  - Speed tier classification", "Speed")
AdvancedAI.log("  - Speed control move evaluation", "Speed")
AdvancedAI.log("  - Speed tie risk assessment", "Speed")

### FILE: Battle_Personalities.rb ###
#===============================================================================
# [021] Battle Personalities - 4 AI Playstyles
#===============================================================================
# Defines 4 different Battle Personalities for diversified AI
#
# Personalities:
# 1. AGGRESSIVE - Max Damage, Risky Plays
# 2. DEFENSIVE - Stalling, Walls, Recovery
# 3. BALANCED - Mix of Offense/Defense
# 4. HYPER_OFFENSIVE - Setup Sweeps, All-or-Nothing
#===============================================================================

module AdvancedAI
  module BattlePersonalities
    
    #===========================================================================
    # Personality Definitions
    #===========================================================================
    
    PERSONALITIES = {
      :aggressive => {
        name: "Aggressive",
        description: "Prefers max damage and risky plays",
        modifiers: {
          damage_bonus: 25,          # +25 for Damage Moves
          setup_penalty: -20,        # -20 for Setup (too slow)
          healing_penalty: -30,      # -30 for Healing (defensive = bad)
          priority_bonus: 15,        # +15 for Priority Moves
          ohko_bonus: 40,            # +40 for OHKO Moves (risky but strong)
          coverage_bonus: 10,        # +10 for super-effective coverage moves
          switch_threshold: 55,      # Higher threshold = fewer Switches
        }
      },
      
      :defensive => {
        name: "Defensive",
        description: "Prefers Stalling, Walls and Recovery",
        modifiers: {
          damage_bonus: -10,         # -10 for Damage (not priority)
          setup_bonus: 20,           # +20 for Setup (play for time)
          healing_bonus: 40,         # +40 for Healing
          status_bonus: 30,          # +30 for Status Moves (Burn/Para)
          protect_bonus: 35,         # +35 for Protect (stalling)
          hazard_bonus: 25,          # +25 for Hazards
          stall_bonus: 45,           # +45 for Stall Moves (Toxic stall loop)
          switch_threshold: 35,      # Low threshold = more Switches
        }
      },
      
      :balanced => {
        name: "Balanced",
        description: "Balanced mix of Offense and Defense",
        modifiers: {
          damage_bonus: 10,          # +10 for Damage
          setup_bonus: 10,           # +10 for Setup
          healing_bonus: 15,         # +15 for Healing
          status_bonus: 15,          # +15 for Status
          pivot_bonus: 15,           # +15 for Pivot Moves (momentum control)
          switch_threshold: 45,      # Medium
        }
      },
      
      :hyper_offensive => {
        name: "Hyper Offensive",
        description: "Setup Sweeps, All-or-Nothing strategy",
        modifiers: {
          damage_bonus: 15,          # +15 for Damage
          setup_bonus: 50,           # +50 for Setup (extreme priority)
          healing_penalty: -40,      # -40 for Healing (waste of time)
          protect_bonus: 30,         # +30 for Protect (secure Setup)
          spread_bonus: 20,          # +20 for Spread Moves (Doubles sweep)
          ohko_penalty: -20,         # -20 for OHKO (Setup better)
          switch_threshold: 60,      # Very high = almost never switch
        }
      }
    }
    
    #===========================================================================
    # Personality Detection (based on Pokemon Team)
    #===========================================================================
    
    # Detects best Personality for Trainer
    def self.detect_personality(battle, trainer_index)
      return :balanced if !battle
      
      party = battle.pbParty(trainer_index)
      return :balanced if !party || party.empty?
      
      # Count Pokemon Roles
      sweeper_count = 0
      wall_count = 0
      stall_count = 0
      tank_count = 0
      support_count = 0
      pivot_count = 0
      wallbreaker_count = 0
      lead_count = 0
      
      party.each do |pokemon|
        next if !pokemon || pokemon.egg?
        
        roles = AdvancedAI.detect_roles(pokemon)
        next if !roles
        
        sweeper_count += 1 if roles.include?(:sweeper)
        wall_count += 1 if roles.include?(:wall) || roles.include?(:stall)
        stall_count += 1 if roles.include?(:stall)
        tank_count += 1 if roles.include?(:tank)
        support_count += 1 if roles.include?(:support)
        pivot_count += 1 if roles.include?(:pivot)
        wallbreaker_count += 1 if roles.include?(:wallbreaker)
        lead_count += 1 if roles.include?(:lead)
      end
      
      total = party.count { |p| p && !p.egg? }
      
      # Hyper Offensive: Many Sweepers + Setup OR many Wallbreakers
      if sweeper_count >= total * 0.6
        setup_count = 0
        party.each do |pokemon|
          next if !pokemon
          pokemon.moves.each do |move|
            setup_count += 1 if AdvancedAI.setup_move?(move.id)
          end
        end
        return :hyper_offensive if setup_count >= 4
      end
      
      # Defensive/Stall: Many Walls/Stall mons OR 2+ stall mons
      # Stall teams are a sub-type of defensive but with stronger stall identity
      if wall_count >= total * 0.5 || stall_count >= 2
        return :defensive
      end
      
      # Aggressive: Sweepers + Wallbreakers focused on raw damage
      # Also aggressive if heavy on wallbreakers (Trick Room-style)
      offensive_count = sweeper_count + wallbreaker_count
      if offensive_count >= total * 0.5 && wall_count <= 1
        return :aggressive
      end
      
      # Balanced: Mix of roles, pivots encourage balanced play
      # Teams with lots of pivots and tanks tend to play balanced/bulky offense
      if pivot_count >= 2 || (tank_count >= 2 && support_count >= 1)
        return :balanced
      end
      
      # Default: Balanced
      return :balanced
    end
    
    #===========================================================================
    # Apply Personality Modifiers
    #===========================================================================
    
    #===========================================================================
    # Apply Personality Modifiers
    #===========================================================================
    
    # Applies Personality to Move Score
    def self.apply_personality(score, move, personality)
      return score if !move || !personality
      return score if !PERSONALITIES.key?(personality)
      
      modifiers = PERSONALITIES[personality][:modifiers]
      return score if !modifiers
      
      # Damage Moves
      if move.category == :Physical || move.category == :Special
        score += modifiers[:damage_bonus] if modifiers[:damage_bonus]
      end
      
      # Setup Moves
      if AdvancedAI.setup_move?(move.id)
        score += modifiers[:setup_bonus] if modifiers[:setup_bonus]
        score += modifiers[:setup_penalty] if modifiers[:setup_penalty]
      end
      
      # Healing Moves
      if AdvancedAI.healing_move?(move.id)
        score += modifiers[:healing_bonus] if modifiers[:healing_bonus]
        score += modifiers[:healing_penalty] if modifiers[:healing_penalty]
      end
      
      # Status Moves
      if move.category == :Status && !AdvancedAI.setup_move?(move.id) && !AdvancedAI.healing_move?(move.id)
        score += modifiers[:status_bonus] if modifiers[:status_bonus]
      end
      
      # Priority Moves
      if move.priority > 0
        score += modifiers[:priority_bonus] if modifiers[:priority_bonus]
      end
      
      # OHKO Moves
      if AdvancedAI.ohko_move?(move.id)
        score += modifiers[:ohko_bonus] if modifiers[:ohko_bonus]
        score += modifiers[:ohko_penalty] if modifiers[:ohko_penalty]
      end
      
      # Protect Moves
      if AdvancedAI.protect_move?(move.id)
        score += modifiers[:protect_bonus] if modifiers[:protect_bonus]
      end
      
      # Hazard Moves
      if AdvancedAI.hazard_move?(move.id)
        score += modifiers[:hazard_bonus] if modifiers[:hazard_bonus]
      end
      
      # Spread Moves
      if AdvancedAI.spread_move?(move.id)
        score += modifiers[:spread_bonus] if modifiers[:spread_bonus]
      end
      
      # Stall Moves (Toxic stall, Protect stall, recovery in stall context)
      if AdvancedAI.stall_move?(move.id)
        score += modifiers[:stall_bonus] if modifiers[:stall_bonus]
      end
      
      # Pivot Moves (U-turn, Volt Switch, Flip Turn)
      if AdvancedAI.pivot_move?(move.id)
        score += modifiers[:pivot_bonus] if modifiers[:pivot_bonus]
      end
      
      return score
    end
    
    # Returns Switch Threshold for Personality
    def self.get_switch_threshold(personality)
      return 45 if !personality || !PERSONALITIES.key?(personality)
      
      modifiers = PERSONALITIES[personality][:modifiers]
      return modifiers[:switch_threshold] || 45
    end
    
    #===========================================================================
    # Personality Descriptions
    #===========================================================================
    
    # Returns Personality Name
    def self.get_name(personality)
      return "Balanced" if !personality || !PERSONALITIES.key?(personality)
      return PERSONALITIES[personality][:name]
    end
    
    # Returns Personality Description
    def self.get_description(personality)
      return "" if !personality || !PERSONALITIES.key?(personality)
      return PERSONALITIES[personality][:description]
    end
    
    #===========================================================================
    # Personality Override (for Event Battles)
    #===========================================================================
    
    # Manual Personality Assignment
    @personality_overrides = {}
    
    def self.set_personality(trainer_name, personality)
      return if !trainer_name || !personality
      return if !PERSONALITIES.key?(personality)
      
      @personality_overrides[trainer_name] = personality
      AdvancedAI.log("[Personality] Set #{trainer_name} to #{get_name(personality)}", :personality)
    end
    
    def self.get_personality(battle, trainer_index)
      return :balanced if !battle
      
      # Check override
      trainer = battle.pbGetOwnerFromBattlerIndex(trainer_index)
      if trainer && @personality_overrides[trainer.name]
        return @personality_overrides[trainer.name]
      end
      
      # Auto-detect
      return detect_personality(battle, trainer_index)
    end
    
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.detect_personality(battle, trainer_index)
    BattlePersonalities.detect_personality(battle, trainer_index)
  end
  
  def self.apply_personality(score, move, personality)
    BattlePersonalities.apply_personality(score, move, personality)
  end
  
  def self.get_personality(battle, trainer_index)
    BattlePersonalities.get_personality(battle, trainer_index)
  end
  
  def self.set_personality(trainer_name, personality)
    BattlePersonalities.set_personality(trainer_name, personality)
  end
  
  def self.get_personality_switch_threshold(personality)
    BattlePersonalities.get_switch_threshold(personality)
  end
end

#===============================================================================
# Integration in Battle::AI - Wires personality modifiers into scoring pipeline
#===============================================================================
class Battle::AI
  def apply_personality_modifiers(score, move, user, target)
    return score unless move
    skill = @trainer&.skill || 100
    
    # Determine trainer personality
    trainer_index = user.respond_to?(:index) ? user.index : 1
    personality = AdvancedAI.get_personality(@battle, trainer_index)
    return score unless personality
    
    # Apply personality-driven score modifiers
    score = AdvancedAI.apply_personality(score, move, personality)
    
    return score
  end
end

### FILE: Dynamax_Intelligence.rb ###
#===============================================================================
# Advanced AI System - Dynamax Intelligence (DBK_005 Integration)
# Strategic Dynamax Timing and G-Max Optimization
#===============================================================================

class Battle::AI
  # Checks if Dynamax should be used
  def should_dynamax?(user, skill)
    AdvancedAI.log("should_dynamax? called for #{user.name} (skill #{skill})", "Dynamax")
    
    if skill < 95
      AdvancedAI.log("  ❌ Skill too low (#{skill} < 95)", "Dynamax")
      return false
    end
    
    unless AdvancedAI.dbk_enabled?(:dynamax)
      AdvancedAI.log("  ❌ DBK Dynamax not enabled", "Dynamax")
      return false
    end
    
    # Check if Dynamax is available for this battler
    # Note: user is an AIBattler, so we use the battle's method with the index
    unless @battle.pbCanDynamax?(user.index)
      AdvancedAI.log("  ❌ @battle.pbCanDynamax? returned false", "Dynamax")
      return false
    end
    
    if user.dynamax?
      AdvancedAI.log("  ❌ Already Dynamaxed", "Dynamax")
      return false
    end
    
    AdvancedAI.log("  ✅ All checks passed - calculating score", "Dynamax")
    score = calculate_dynamax_score(user, skill)
    
    # Wild Pokemon bonus (for testing/balance)
    if @battle.wildBattle?
      score += 10
      AdvancedAI.log("  Wild Pokemon bonus: +10", "Dynamax")
    end
    
    AdvancedAI.log("Dynamax score for #{user.pbThis}: #{score}", "Dynamax")
    
    # Thresholds
    return true if score >= 100  # Excellent
    return true if score >= 70   # Strong  
    return true if score >= 50 && remaining_pokemon_count(user) <= 2  # Good + few remaining
    
    return false
  end
  
  private
  
  def calculate_dynamax_score(user, skill)
    score = 0
    
    # 1. TIMING CONTEXT (0-35)
    score += evaluate_dynamax_timing(user, skill)
    
    # 2. OFFENSIVE VALUE (0-40)
    score += evaluate_dynamax_offensive(user, skill)
    
    # 3. SWEEP POTENTIAL (0-35)
    score += evaluate_dynamax_sweep(user, skill)
    
    # 4. SURVIVAL VALUE (0-45)
    score += evaluate_dynamax_survival(user, skill)
    
    # 5. PARTY COMPARISON (0 bis -25)
    score += evaluate_dynamax_party(user, skill)
    
    # 6. BATTLE MOMENTUM (0-30)
    score += evaluate_dynamax_momentum(user, skill)
    
    return score
  end
  
  # 1. Timing Context
  def evaluate_dynamax_timing(user, skill)
    score = 0
    turn = @battle.turnCount
    
    if turn <= 3
      # Early Game: Only for G-Max Steelsurge or Threat
      if user.gmax_move?(:STEELSURGE)
        score += 25
      elsif user.hp < user.totalhp * 0.4
        score += 20
      else
        score -= 10
      end
    elsif turn <= 8
      # Mid Game: Optimal
      score += 20
    else
      # Late Game: Cleanup or Desperation
      enemy_count = alive_enemies_count(user)
      if enemy_count == 1
        score += 15  # Cleanup
      elsif user.hp < user.totalhp * 0.5
        score += 25  # Comeback attempt
      end
    end
    
    # Team State Penalties
    alive = remaining_pokemon_count(user)
    score -= 10 if alive >= 5  # Too early
    
    return score
  end
  
  # 2. Offensive Value
  def evaluate_dynamax_offensive(user, skill)
    score = 0
    
    # Multiple Damage Types
    move_types = user.moves.select { |m| m && m.damagingMove? }.map { |m| m.type }.uniq
    score += move_types.count * 5
    
    # Strong Moves (80+ BP)
    strong_moves = user.moves.count { |m| m && m.damagingMove? && m.power >= 80 }
    score += strong_moves * 3
    
    # Coverage against Enemies
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      user.moves.each do |move|
        next unless move && move.damagingMove?
        # Calculate type effectiveness: move type vs target's types
        type_mod = Effectiveness.calculate(move.type, *target.pbTypes(true))
        score += 5 if Effectiveness.super_effective?(type_mod)
      end
    end
    
    # G-Max Moves Bonus
    score += 10 if user.gmax?
    
    # Choice Item Escape
    if user.item && [:CHOICEBAND, :CHOICESCARF, :CHOICESPECS].include?(user.item_id)
      score += 15
    end
    
    return [score, 40].min
  end
  
  # 3. Sweep Potential
  def evaluate_dynamax_sweep(user, skill)
    score = 0
    
    # Existing Stat Boosts
    positive_boosts = user.stages.values.count { |stage| stage > 0 }
    if positive_boosts >= 3
      score += 15
    elsif positive_boosts >= 1
      score += 8
    end
    
    # Max Move Boost Potential
    max_moves_with_boosts = user.moves.count do |move|
      next false unless move
      # Max Flare, Max Darkness, etc. give Boosts
      true  # Simplified
    end
    score += max_moves_with_boosts * 6
    
    # Speed Advantage
    faster_than_all = @battle.allOtherSideBattlers(user.index).all? do |target|
      next true unless target && !target.fainted?
      user.pbSpeed > target.pbSpeed
    end
    score += 10 if faster_than_all
    
    # Weak Enemies
    weak_enemies = @battle.allOtherSideBattlers(user.index).count do |target|
      next false unless target && !target.fainted?
      target.hp < target.totalhp * 0.4
    end
    score += weak_enemies * 4
    
    return [score, 35].min
  end
  
  # 4. Survival Value
  def evaluate_dynamax_survival(user, skill)
    score = 0
    hp_percent = user.hp.to_f / user.totalhp
    
    # Emergency HP Boost
    if hp_percent < 0.3
      score += 25
    elsif hp_percent < 0.5
      score += 15
    end
    
    # Prevent OHKO
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      target.moves.each do |move|
        next unless move && move.damagingMove?
        
        rough_damage = calculate_rough_damage(move, target, user)
        if rough_damage >= user.hp
          score += 20  # Would be KO without Dynamax
          break
        end
      end
    end
    
    # Dynamax Immunities
    # OHKO Immunity
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      has_ohko = target.moves.any? { |m| m && [:GUILLOTINE, :FISSURE, :SHEERCOLD, :HORNDRILL].include?(m.id) }
      score += 15 if has_ohko
    end
    
    # Remove Restrictions
    score += 10 if user.effects[PBEffects::Taunt] > 0
    score += 10 if user.effects[PBEffects::Torment]
    score += 10 if user.effects[PBEffects::NoRetreat]
    
    # Penalties
    score -= 30 if user.effects[PBEffects::PerishSong] > 0  # Waste
    
    return [score, 45].min
  end
  
  # 5. Party Comparison
  def evaluate_dynamax_party(user, skill)
    score = 0
    party = @battle.pbParty(user.index)
    
    # Better Dynamax Candidates?
    better_candidates = party.count do |pkmn|
      next false if !pkmn || pkmn.fainted? || pkmn.egg?
      # Skip if this Pokemon is currently in battle
      next false if pkmn == user.pokemon
      
      # Higher Attack or Special Attack
      pkmn.attack > user.attack || pkmn.spatk > user.spatk
    end
    
    if better_candidates > 0
      score -= [better_candidates * 10, 20].min
    end
    
    # Last Pokemon Bonus
    alive = remaining_pokemon_count(user)
    score += 15 if alive == 1
    
    return score
  end
  
  # 6. Battle Momentum
  def evaluate_dynamax_momentum(user, skill)
    score = 0
    
    # Current Momentum
    if user_has_momentum?(user)
      score += 10
    end
    
    # Opponent Setup Pressure
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      positive_boosts = target.stages.values.count { |stage| stage > 0 }
      if positive_boosts >= 3
        score += 15
      elsif positive_boosts >= 1
        score += 8
      end
    end
    
    # G-Max Steelsurge Timing (if not yet set)
    if user.gmax_move?(:STEELSURGE)
      side = @battle.pbOwnedByPlayer?(user.index) ? @battle.sides[1] : @battle.sides[0]
      score += 10 unless side.effects[PBEffects::Gmaxsteelsurge]
    end
    
    # Field Effect Control
    if @battle.field.terrain != :None
      score += 5
    end
    
    return [score, 30].min
  end
  
  # === HELPER METHODS ===
  
  def remaining_pokemon_count(user)
    @battle.pbParty(user.index).count { |p| p && !p.fainted? }
  end
  
  def alive_enemies_count(user)
    @battle.allOtherSideBattlers(user.index).count { |b| b && !b.fainted? }
  end
  
  def user_has_momentum?(user)
    # Simplified Momentum Check
    hp_advantage = user.hp.to_f / user.totalhp > 0.6
    stat_advantage = user.stages.values.sum > 0
    
    return hp_advantage && stat_advantage
  end
end

# Extended Battler Methods for Dynamax
class Battle::Battler
  def can_dynamax?
    return false unless defined?(Battle::Scene::USE_DYNAMAX_GRAPHICS)
    # Check if battle allows Dynamax OR if this Pokemon has dynamax_lvl (wild Pokemon)
    return true if @battle.pbCanDynamax?(@index)
    return true if @pokemon &&  @pokemon.dynamax_lvl && @pokemon.dynamax_lvl > 0
    return false
  end
  
  def dynamax?
    return false unless defined?(Battle::Scene::USE_DYNAMAX_GRAPHICS)
    return dynamax_able?
  end
  
  def gmax?
    return false unless defined?(Battle::Scene::USE_DYNAMAX_GRAPHICS)
    return gmax_factor? && dynamax_able?
  end
  
  def gmax_move?(move_type)
    return false unless gmax?
    # Simplified G-Max Move Check
    return true
  end
end

# Extended AIBattler Methods for Dynamax
class Battle::AI::AIBattler
  def dynamax?
    return @battler.dynamax? if @battler.respond_to?(:dynamax?)
    return false
  end
  
  def gmax?
    return @battler.gmax? if @battler.respond_to?(:gmax?)
    return false
  end
  
  def gmax_move?(type_symbol)
    return @battler.gmax_move?(type_symbol) if @battler.respond_to?(:gmax_move?)
    return false
  end
  
  # Delegate common battler methods used in scoring
  def hp
    return @battler.hp if @battler
    return 0
  end
  
  def totalhp
    return @battler.totalhp if @battler
    return 1
  end
  
  def item
    return @battler.item if @battler.respond_to?(:item)
    return nil
  end
  
  def item_id
    return @battler.item_id if @battler.respond_to?(:item_id)
    return nil
  end
  
  def moves
    return @battler.moves if @battler
    return []
  end
  
  def stages
    return @battler.stages if @battler.respond_to?(:stages)
    return {}
  end
  
  def pbSpeed
    return @battler.pbSpeed if @battler.respond_to?(:pbSpeed)
    return 0
  end
  
  def attack
    return @battler.attack if @battler.respond_to?(:attack)
    return 0
  end
  
  def defense
    return @battler.defense if @battler.respond_to?(:defense)
    return 0
  end
  
  def spatk
    return @battler.spatk if @battler.respond_to?(:spatk)
    return 0
  end
  
  def spdef
    return @battler.spdef if @battler.respond_to?(:spdef)
    return 0
  end
  
  def pbThis(lowercase = false)
    return @battler.pbThis(lowercase) if @battler.respond_to?(:pbThis)
    return "Pokemon"
  end
  
  def name
    return @battler.name if @battler.respond_to?(:name)
    return "Pokemon"
  end
end

AdvancedAI.log("Dynamax Intelligence loaded (DBK_005)", "Dynamax")

### FILE: Endgame_Scenarios.rb ###
#===============================================================================
# [020] Endgame Scenarios - 1v1/2v2 Logic
#===============================================================================
# Special Strategies for Endgame Situations
#
# Features:
# - 1v1 Optimize (only 1 Pokemon per side left)
# - 2v2 Optimize (2v2 Situation)
# - Winning Move Detection (guaranteed KO)
# - Stall Detection (Play for time)
# - Desperation Moves (Last attempt)
#===============================================================================

module AdvancedAI
  module EndgameScenarios
    
    #===========================================================================
    # Endgame Detection
    #===========================================================================
    
    # Checks if Endgame (≤2 Pokemon per side)
    def self.is_endgame?(battle)
      return false if !battle
      
      # Count remaining Pokemon
      side0_count = battle.pbAbleNonActiveCount(0) + battle.pbParty(0).count { |p| p && !p.fainted? && p.hp > 0 }
      side1_count = battle.pbAbleNonActiveCount(1) + battle.pbParty(1).count { |p| p && !p.fainted? && p.hp > 0 }
      
      return side0_count <= 2 || side1_count <= 2
    end
    
    # Checks if 1v1 (only 1 Pokemon per side active)
    def self.is_1v1?(battle)
      return false if !battle
      
      side0_count = battle.pbAbleCount(0)
      side1_count = battle.pbAbleCount(1)
      
      return side0_count == 1 && side1_count == 1
    end
    
    # Checks if 2v2 (2 Pokemon per side)
    def self.is_2v2?(battle)
      return false if !battle
      
      side0_count = battle.pbAbleCount(0)
      side1_count = battle.pbAbleCount(1)
      
      return side0_count == 2 && side1_count == 2
    end
    
    #===========================================================================
    # 1v1 Optimization
    #===========================================================================
    
    # Evaluates Move for 1v1
    def self.score_1v1_move(battle, user, target, move, base_score)
      return base_score if !battle || !user || !target || !move
      return base_score if !is_1v1?(battle)
      
      score = base_score
      
      # 1. KO Priority (Winning Move = +100)
      if can_ko?(user, target, move)
        AdvancedAI.log("  [Endgame] 1v1: Move can KO! +100", :endgame)
        score += 100
      end
      
      # 2. 2HKO Priority (+50)
      if can_2hko?(user, target, move)
        AdvancedAI.log("  [Endgame] 1v1: Move can 2HKO! +50", :endgame)
        score += 50
      end
      
      # 3. Speed Control
      if user.pbSpeed < target.pbSpeed
        # Slower = Priority Moves very valuable
        if move.priority > 0
          AdvancedAI.log("  [Endgame] 1v1: Priority move (slower) +60", :endgame)
          score += 60
        end
        
        # Slower = Setup risky
        if AdvancedAI.setup_move?(move.id)
          AdvancedAI.log("  [Endgame] 1v1: Setup risky (slower) -40", :endgame)
          score -= 40
        end
      else
        # Faster = Setup safer
        if AdvancedAI.setup_move?(move.id)
          AdvancedAI.log("  [Endgame] 1v1: Setup safe (faster) +20", :endgame)
          score += 20
        end
      end
      
      # 4. Survival Moves
      if user.hp < user.totalhp * 0.3
        # Protect valuable if weak
        if AdvancedAI.protect_move?(move.id)
          score += 40
        end
        
        # Healing critical
        if AdvancedAI.healing_move?(move.id)
          score += 60
        end
      end
      
      # 5. Status Moves in 1v1
      if move.category == :Status
        # Will-O-Wisp/Thunder Wave very strong
        if [:WILLOWISP, :THUNDERWAVE, :TOXIC].include?(move.id)
          # But only if target doesn't have status yet
          if !target.status
            score += 40
          end
        end
        
        # Setup = risky but can win
        if AdvancedAI.setup_move?(move.id)
          # +20 if user can survive
          if user.hp > user.totalhp * 0.7
            score += 20
          end
        end
      end
      
      # 6. OHKO Moves (desperate)
      if AdvancedAI.ohko_move?(move.id)
        # 30% Chance = better than losing
        score += 80
      end
      
      return score
    end
    
    #===========================================================================
    # 2v2 Optimization
    #===========================================================================
    
    # Evaluates Move for 2v2
    def self.score_2v2_move(battle, user, target, move, base_score)
      return base_score if !battle || !user || !target || !move
      return base_score if !is_2v2?(battle)
      
      score = base_score
      
      # 1. Focus Fire (both on weakest target)
      weakest = find_weakest_opponent(battle, user)
      if weakest && target.index == weakest.index
        AdvancedAI.log("  [Endgame] 2v2: Targeting weakest +40", :endgame)
        score += 40
      end
      
      # 2. Protect Stalling (wait for Partner KO)
      if AdvancedAI.protect_move?(move.id)
        partner = get_partner(battle, user)
        if partner
          # Check if Partner can KO
          partner.moves.each do |partner_move|
            next if !partner_move
            if can_ko?(partner, target, partner_move)
              AdvancedAI.log("  [Endgame] 2v2: Protect for partner KO +50", :endgame)
              score += 50
              break
            end
          end
        end
      end
      
      # 3. Spread Moves less valuable (only 2 targets)
      if AdvancedAI.spread_move?(move.id)
        AdvancedAI.log("  [Endgame] 2v2: Spread move limited -20", :endgame)
        score -= 20
      end
      
      # 4. Priority for secure KOs
      if can_ko?(user, target, move)
        AdvancedAI.log("  [Endgame] 2v2: Secure KO +80", :endgame)
        score += 80
      end
      
      return score
    end
    
    #===========================================================================
    # Winning Move Detection
    #===========================================================================
    
    # Checks if Move ensures guaranteed Victory
    def self.winning_move?(battle, user, move)
      return false if !battle || !user || !move
      
      # All Opponent Pokemon KO-able?
      opponents = battle.allOtherSideBattlers(user.index)
      return false if opponents.empty?
      
      ko_count = 0
      opponents.each do |opp|
        next if !opp || opp.fainted?
        ko_count += 1 if can_ko?(user, opp, move)
      end
      
      # Winning if all active opponents KO-able
      active_opponents = opponents.count { |opp| opp && !opp.fainted? }
      return ko_count >= active_opponents
    end
    
    # Finds Winning Move (if exists)
    def self.find_winning_move(battle, user)
      return nil if !battle || !user
      
      user.moves.each do |move|
        next if !move || move.pp <= 0
        return move.id if winning_move?(battle, user, move)
      end
      
      return nil
    end
    
    #===========================================================================
    # Stall Detection
    #===========================================================================
    
    # Checks if Stalling makes sense
    def self.should_stall?(battle, user)
      return false if !battle || !user
      
      # Stalling only useful in Endgame
      return false if !is_endgame?(battle)
      
      # Requirements for Stalling:
      # 1. User has Recovery
      # 2. User has defensive Stats
      # 3. Opponent cannot OHKO
      
      has_recovery = false
      user.moves.each do |move|
        next if !move
        has_recovery = true if AdvancedAI.healing_move?(move.id)
      end
      
      return false if !has_recovery
      
      # Check defensive stats
      roles = AdvancedAI.detect_roles(user)
      return false if !roles.include?(:wall) && !roles.include?(:tank)
      
      # Check if opponent can OHKO
      opponents = battle.allOtherSideBattlers(user.index)
      opponents.each do |opp|
        next if !opp || opp.fainted?
        
        # If opponent very strong = no Stalling
        if opp.attack >= 140 || opp.spatk >= 140
          return false
        end
      end
      
      return true
    end
    
    #===========================================================================
    # Desperation Moves
    #===========================================================================
    
    # Bonus for desperate Moves
    def self.desperation_bonus(battle, user, move)
      return 0 if !battle || !user || !move
      
      # Only if close to losing
      remaining = battle.pbAbleCount(user.index)
      return 0 if remaining > 1
      
      # Only if user weak
      return 0 if user.hp > user.totalhp * 0.3
      
      bonus = 0
      
      # OHKO Moves (+80)
      bonus += 80 if AdvancedAI.ohko_move?(move.id)
      
      # Explosion/Self-Destruct (+60)
      bonus += 60 if [:EXPLOSION, :SELFDESTRUCT].include?(move.id)
      
      # Final Gambit (+50)
      bonus += 50 if move.id == :FINALGAMBIT
      
      # Reversal / Flail (strong at low HP) (+40)
      bonus += 40 if [:REVERSAL, :FLAIL].include?(move.id)
      
      return bonus
    end
    
    #===========================================================================
    # Helper Methods
    #===========================================================================
    
    # Checks if Move can KO
    def self.can_ko?(user, target, move)
      return false if !user || !target || !move
      
      # Rough damage calculation - use standardized (move, attacker, defender) order
      damage = calculate_rough_damage(move, user, target)
      return damage >= target.hp
    end
    
    # Checks if Move can 2HKO
    def self.can_2hko?(user, target, move)
      return false if !user || !target || !move
      
      damage = calculate_rough_damage(move, user, target)
      return damage * 2 >= target.hp
    end
    
    # Rough Damage Calculation
    # NOTE: Signature matches Move_Scorer: (move, attacker, defender)
    def self.calculate_rough_damage(move, user, target)
      return 0 if !user || !target || !move
      return 0 if move.category == :Status
      
      # Very simplified (enough for AI)
      attack = (move.physicalMove? ? user.attack : user.spatk)
      defense = (move.physicalMove? ? target.defense : target.spdef)
      defense = [defense, 1].max  # Prevent division by zero
      
      # Type effectiveness
      effectiveness = Effectiveness.calculate(move.type, target.type1, target.type2)
      # Convert effectiveness to multiplier (divide by normal effective value)
      multiplier = effectiveness.to_f / Effectiveness::NORMAL_EFFECTIVE
      
      # Rough formula
      damage = ((2 * user.level / 5 + 2) * move.power * attack / defense / 50 + 2) * multiplier
      
      return damage.to_i
    end
    
    # Finds weakest Opponent
    def self.find_weakest_opponent(battle, user)
      return nil if !battle || !user
      
      opponents = battle.allOtherSideBattlers(user.index)
      return nil if opponents.empty?
      
      weakest = nil
      lowest_hp_percent = 999
      
      opponents.each do |opp|
        next if !opp || opp.fainted?
        
        hp_percent = (opp.hp * 100.0 / opp.totalhp)
        if hp_percent < lowest_hp_percent
          lowest_hp_percent = hp_percent
          weakest = opp
        end
      end
      
      return weakest
    end
    
    # Returns Partner (Doubles)
    def self.get_partner(battle, user)
      return nil if !battle || !user
      return nil unless battle.pbSideSize(0) > 1  # Not doubles
      
      partner_index = (user.index % 2 == 0) ? user.index + 1 : user.index - 1
      partner = battle.battlers[partner_index]
      
      return partner if partner && !partner.fainted?
      return nil
    end
    
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.is_endgame?(battle)
    EndgameScenarios.is_endgame?(battle)
  end
  
  def self.is_1v1?(battle)
    EndgameScenarios.is_1v1?(battle)
  end
  
  def self.is_2v2?(battle)
    EndgameScenarios.is_2v2?(battle)
  end
  
  def self.score_endgame_move(battle, user, target, move, base_score)
    score = base_score
    score = EndgameScenarios.score_1v1_move(battle, user, target, move, score) if EndgameScenarios.is_1v1?(battle)
    score = EndgameScenarios.score_2v2_move(battle, user, target, move, score) if EndgameScenarios.is_2v2?(battle)
    return score
  end
  
  def self.find_winning_move(battle, user)
    EndgameScenarios.find_winning_move(battle, user)
  end
  
  def self.should_stall?(battle, user)
    EndgameScenarios.should_stall?(battle, user)
  end
  
  def self.desperation_bonus(battle, user, move)
    EndgameScenarios.desperation_bonus(battle, user, move)
  end
end

#===============================================================================
# Integration in Battle::AI - Wires endgame logic into scoring pipeline
#===============================================================================
class Battle::AI
  def apply_endgame_logic(score, move, user, target)
    return score unless move
    skill = @trainer&.skill || 100
    
    # Apply endgame scenario scoring (1v1, 2v2 adjustments)
    if AdvancedAI.is_endgame?(@battle)
      score = AdvancedAI.score_endgame_move(@battle, user, target, move, score)
      
      # Add desperation bonus when losing badly
      desp = AdvancedAI.desperation_bonus(@battle, user, move)
      score += desp if desp && desp > 0
    end
    
    # Apply win condition bonus (works at any point, not just endgame)
    if skill >= 70
      win_bonus = AdvancedAI.apply_win_condition_bonus(@battle, user, move, target, skill)
      score += win_bonus if win_bonus && win_bonus > 0
    end
    
    return score
  end
end

### FILE: Mega_Intelligence.rb ###
#===============================================================================
# Advanced AI System - Mega Intelligence
# Logic for optimal Mega Evolution timing
#===============================================================================

class Battle::AI
  # Main entry point for checking Mega Evolution
  def should_mega_evolve?(user, skill)
    return false unless user.can_mega_evolve?
    return false if user.mega?
    
    # Base score
    score = 0
    
    # 1. Stat Increase Value
    score += evaluate_mega_stats(user)
    
    # 2. Ability Change Value
    score += evaluate_mega_ability(user)
    
    # 3. Type Change Value
    score += evaluate_mega_type(user)
    
    # 4. Turn Context
    score += evaluate_mega_context(user, skill)
    
    AdvancedAI.log("Mega Eval for #{user.pbThis}: Score #{score}", "Mega")
    
    # Thresholds
    return true if score >= 20  # Good value
    return true if user.hp <= user.totalhp * 0.5 && score > 0 # Desperation
    
    return false
  end
  
  private
  
  def evaluate_mega_stats(user)
    score = 0
    # Retrieve Mega Form data (assumed to be form + 1 or linked via item)
    # Since we can't easily peek at the specific Mega stats without transforming,
    # we assume Mega Evolution is generally beneficial stats-wise (approx +100 BST).
    score += 15 
    return score
  end
  
  def evaluate_mega_ability(user)
    score = 0
    current_ability = user.ability_id
    
    # Predict Mega Ability (Simplified: We know specific powerful Megas)
    # Ideally we'd look up the species form data, but for now we apply heuristics
    
    # Examples of abilities YOU WANT immediately
    # Drizzle, Drought, Snow Warning, Sand Stream (Weather wars)
    # Intimidate (Attack drop)
    # Speed Boost
    
    # This requires looking up the form's ability if possible.
    # In Essentials, we can try to find the standard Mega form.
    mega_form_id = user.pokemon.getMegaForm
    if mega_form_id > 0
      mega_species = GameData::Species.get_species_form(user.species, mega_form_id)
      mega_abil = mega_species.abilities.first
      
      if mega_abil != current_ability
        # Weather setting abilities are high priority on turn 1
        if [:DRIZZLE, :DROUGHT, :SNOWWARNING, :SANDSTREAM].include?(mega_abil)
          score += 25
          # Don't override if we already have the weather we want
          if (@battle.pbWeather == :Sun && mega_abil == :DROUGHT) ||
             (@battle.pbWeather == :Rain && mega_abil == :DRIZZLE)
             score -= 20
          end
        end
        
        # Power boosts
        if [:HUGEPOWER, :PUREPOWER, :ADAPTABILITY, :TOUGHCLAWS].include?(mega_abil)
          score += 20
        end
        
        # Defensive
        if [:MAGICBOUNCE, :INTIMIDATE].include?(mega_abil)
          score += 15
        end
      end
    end
    
    return score
  end
  
  def evaluate_mega_type(user)
    score = 0
    # Check if type changes and if that's good against current targets
    return score
  end
  
  def evaluate_mega_context(user, skill)
    score = 0
    # Almost always good to Mega Evolve immediately to get the stat boosts
    # unless we specifically want to hold off (e.g. keeping a specific resistance)
    
    # Default aggressive: Mega Evolve early
    score += 10
    
    return score
  end
end

class Battle::AI::AIBattler
  def can_mega_evolve?
    return @battler.can_mega_evolve? if @battler.respond_to?(:can_mega_evolve?)
    # Fallback: check via battle reference
    return false unless @battler && @battler.battle
    return @battler.battle.pbCanMegaEvolve?(@battler.index) rescue false
  end
  
  def mega?
    return @battler.mega? if @battler.respond_to?(:mega?)
    return false
  end
end

### FILE: Terastallization_Intelligence.rb ###
#===============================================================================
# Advanced AI System - Terastallization Intelligence (DBK_006 Integration)
# Strategic Tera Timing and Type Advantage Analysis
#===============================================================================

class Battle::AI
  # Checks if Terastallize should be used
  def should_terastallize?(user, skill)
    AdvancedAI.log("should_terastallize? called for #{user.battler.name} (skill #{skill})", "Tera")
    
    unless skill >= 100
      AdvancedAI.log("  ❌ Skill too low (#{skill} < 100)", "Tera")
      return false
    end
    
    unless AdvancedAI.dbk_enabled?(:terastallization)
      AdvancedAI.log("  ❌ Terastallization not enabled", "Tera")
      return false
    end
    
    # Note: user is an AIBattler, so we use the battle's method with the index
    unless @battle.pbCanTerastallize?(user.index)
      AdvancedAI.log("  ❌ @battle.pbCanTerastallize? returned false", "Tera")
      return false
    end
    
    if user.tera?
      AdvancedAI.log("  ❌ Already Terastallized", "Tera")
      return false
    end
    
    score = calculate_tera_score(user, skill)
    
    # Wild Pokemon bonus (for testing/balance)
    if @battle.wildBattle?
      score += 10
      AdvancedAI.log("  Wild Pokemon Tera bonus: +10", "Tera")
    end
    
    AdvancedAI.log("Tera score for #{user.pbThis}: #{score}", "Tera")
    
    # Thresholds
    return true if score >= 80   # Emergency/Guaranteed value
    return true if score >= 60   # Strong Situation
    return true if score >= 40 && remaining_pokemon_count(user) <= 2  # Good + few remaining
    
    return false
  end
  
  private
  
  def calculate_tera_score(user, skill)
    score = 0
    
    # 1. TIMING CONTEXT (0-30)
    score += evaluate_tera_timing(user, skill)
    
    # 2. TYPE ADVANTAGE (0-40)
    score += evaluate_tera_type_advantage(user, skill)
    
    # 3. SWEEP POTENTIAL (0-35)
    score += evaluate_tera_sweep(user, skill)
    
    # 4. SURVIVAL NECESSITY (0-45)
    score += evaluate_tera_survival(user, skill)
    
    # 5. PARTY COMPARISON (0 bis -25)
    score += evaluate_tera_party(user, skill)
    
    # 6. BATTLE MOMENTUM (0-25)
    score += evaluate_tera_momentum(user, skill)
    
    return score
  end
  
  # 1. Timing Context
  def evaluate_tera_timing(user, skill)
    score = 0
    turn = @battle.turnCount
    
    if turn <= 2
      # Early Game: Only with strong advantage
      score += 10
    elsif turn <= 6
      # Mid Game: Optimal for Sweep Setup
      score += 20
    else
      # Late Game: Cleanup or Emergency
      score += 15
    end
    
    # Team State
    alive = remaining_pokemon_count(user)
    score -= 10 if alive >= 5  # Too early
    score += 10 if alive <= 2  # Critical
    
    return score
  end
  
  # 2. Type Advantage
  def evaluate_tera_type_advantage(user, skill)
    score = 0
    tera_type = user.tera_type
    
    return 0 unless tera_type
    
    # Offensive Synergy
    user.moves.each do |move|
      next unless move && move.damagingMove?
      
      if move.type == tera_type
        # STAB Bonus after Tera
        score += 15
        
        # Coverage against active opponents
        @battle.allOtherSideBattlers(user.index).each do |target|
          next unless target && !target.fainted?
          
          type_mod = Effectiveness.calculate(tera_type, *target.pbTypes(true))
          score += 10 if Effectiveness.super_effective?(type_mod)
        end
      end
    end
    
    # Defensive Coverage
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      target.moves.each do |move|
        next unless move && move.damagingMove?
        
        # Resistance after Tera
        current_mod = Effectiveness.calculate(move.type, *user.pbTypes(true))
        tera_mod = Effectiveness.calculate(move.type, tera_type)
        
        if Effectiveness.super_effective?(current_mod) && Effectiveness.not_very_effective?(tera_mod)
          score += 25  # Turns Weakness into Resistance
        elsif Effectiveness.super_effective?(current_mod) && tera_mod == Effectiveness::NORMAL_EFFECTIVE
          score += 15  # Neutralizes Weakness
        end
      end
    end
    
    return [score, 40].min
  end
  
  # 3. Sweep Potential
  def evaluate_tera_sweep(user, skill)
    score = 0
    
    # Setup Boosts
    positive_boosts = user.stages.values.count { |stage| stage > 0 }
    if positive_boosts >= 3
      score += 20
    elsif positive_boosts >= 1
      score += 10
    end
    
    # HP for Sweep
    hp_percent = user.hp.to_f / user.totalhp
    score += 15 if hp_percent > 0.7
    score += 10 if hp_percent > 0.5
    
    # Opponent Team Analysis
    weak_to_tera = @battle.allOtherSideBattlers(user.index).count do |target|
      next false unless target && !target.fainted?
      
      tera_type = user.tera_type
      next false unless tera_type
      
      type_mod = Effectiveness.calculate(tera_type, *target.pbTypes(true))
      Effectiveness.super_effective?(type_mod)
    end
    score += weak_to_tera * 8
    
    # Win Condition
    alive_enemies = alive_enemies_count(user)
    if alive_enemies <= 2 && positive_boosts >= 2
      score += 15  # Can end game
    end
    
    return [score, 35].min
  end
  
  # 4. Survival Necessity
  def evaluate_tera_survival(user, skill)
    score = 0
    hp_percent = user.hp.to_f / user.totalhp
    tera_type = user.tera_type
    
    return 0 unless tera_type
    
    # Emergency Situation
    if hp_percent < 0.3
      score += 30
    elsif hp_percent < 0.5
      score += 15
    end
    
    # Type Coverage Need
    imminent_ko = false
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      target.moves.each do |move|
        next unless move && move.damagingMove?
        
        # Note: target is attacking user here, so target=attacker, user=defender
        current_damage = calculate_rough_damage(move, target, user)
        if current_damage >= user.hp
          # Would be KO without Tera
          tera_mod = Effectiveness.calculate(move.type, tera_type, nil)
          if Effectiveness.not_very_effective?(tera_mod) || Effectiveness.ineffective?(tera_mod)
            score += 45  # Tera saves
            imminent_ko = true
            break
          end
        end
      end
      break if imminent_ko
    end
    
    # Survival Priority
    if remaining_pokemon_count(user) == 1
      score += 20  # Last Pokemon
    end
    
    return [score, 45].min
  end
  
  # 5. Party Comparison
  def evaluate_tera_party(user, skill)
    score = 0
    party = @battle.pbParty(user.index)
    
    # Better Tera Candidates?
    better_candidates = party.count do |pkmn|
      next false if !pkmn || pkmn.fainted? || pkmn.egg?
      next false unless pkmn.tera_type
      
      # Higher Offense or better Tera Synergy
      pkmn.attack > user.attack || pkmn.spatk > user.spatk
    end
    
    if better_candidates > 0
      score -= [better_candidates * 10, 25].min
    end
    
    # Last Pokemon Bonus
    alive = remaining_pokemon_count(user)
    score += 15 if alive == 1
    
    return score
  end
  
  # 6. Battle Momentum
  def evaluate_tera_momentum(user, skill)
    score = 0
    
    # Current Advantage
    if user_has_momentum?(user)
      score += 10
    end
    
    # Maintain Pressure
    @battle.allOtherSideBattlers(user.index).each do |target|
      next unless target && !target.fainted?
      
      if target.hp < target.totalhp * 0.4
        score += 8  # Finishing blow
      end
    end
    
    # Comeback Potential
    hp_disadvantage = user.hp.to_f / user.totalhp < 0.5
    enemy_advantage = @battle.allOtherSideBattlers(user.index).all? { |b| 
      b && !b.fainted? && b.hp > b.totalhp * 0.6 
    }
    
    score += 15 if hp_disadvantage && enemy_advantage
    
    return [score, 25].min
  end
end

# Extended Battler Methods for Terastallization
class Battle::Battler
  def can_terastallize?
    return false unless defined?(Settings::TERASTALLIZE_TRIGGER_KEY)
    return false unless @battle.pbCanTerastallize?(@index)
    return true
  end
  
  def tera?
    return false unless defined?(Settings::TERASTALLIZE_TRIGGER_KEY)
    # Check the pokemon's tera status, not self (would cause infinite recursion)
    return @pokemon&.tera? || false
  end
  
  def tera_type
    return nil unless defined?(Settings::TERASTALLIZE_TRIGGER_KEY)
    return @pokemon.tera_type if @pokemon
    return nil
  end
end

# Extended AIBattler Methods for Terastallization
class Battle::AI::AIBattler
  def tera?
    return @battler.tera? if @battler.respond_to?(:tera?)
    return false
  end
  
  def tera_type
    return @battler.tera_type if @battler.respond_to?(:tera_type)
    return nil
  end
end

AdvancedAI.log("Terastallization Intelligence loaded (DBK_006)", "Tera")

### FILE: Win_Conditions.rb ###
#===============================================================================
# Advanced AI System - Win Condition Identification
# Tracks and identifies how the AI can win the battle
#===============================================================================

module AdvancedAI
  module WinConditions
    #===========================================================================
    # Win Condition Types
    #===========================================================================
    WIN_CONDITIONS = {
      sweep: {
        description: "A single Pokemon can KO all remaining opponents",
        priority: 10
      },
      attrition: {
        description: "Chip damage + hazards will secure victory",
        priority: 7
      },
      stall: {
        description: "PP stall or Toxic stall will win",
        priority: 5
      },
      trade: {
        description: "Trading 1-for-1 leads to numerical advantage",
        priority: 6
      },
      setup: {
        description: "One safe setup turn wins the game",
        priority: 9
      },
      revenge: {
        description: "Revenge killing with priority/faster mon wins",
        priority: 8
      },
      speed_control: {
        description: "Speed advantage + faster attackers win",
        priority: 7
      }
    }
    
    #===========================================================================
    # Main Win Condition Analyzer
    #===========================================================================
    def self.identify_win_condition(battle, user, skill_level = 100)
      return nil unless skill_level >= 70
      
      conditions = []
      
      # Gather battle state info
      our_side = get_side_pokemon(battle, user, own_side: true)
      opp_side = get_side_pokemon(battle, user, own_side: false)
      
      return nil if our_side.empty? || opp_side.empty?
      
      # Check each win condition type
      conditions << check_sweep_condition(battle, our_side, opp_side, skill_level)
      conditions << check_attrition_condition(battle, our_side, opp_side, skill_level)
      conditions << check_stall_condition(battle, our_side, opp_side, skill_level)
      conditions << check_trade_condition(battle, our_side, opp_side, skill_level)
      conditions << check_setup_condition(battle, our_side, opp_side, skill_level)
      conditions << check_revenge_condition(battle, our_side, opp_side, skill_level)
      conditions << check_speed_control_condition(battle, our_side, opp_side, skill_level)
      
      # Return highest priority valid condition
      conditions.compact.max_by { |c| c[:score] }
    end
    
    #===========================================================================
    # Individual Win Condition Checks
    #===========================================================================
    
    # Sweep: One Pokemon can OHKO or 2HKO all remaining opponents
    def self.check_sweep_condition(battle, our_side, opp_side, skill_level)
      our_side.each do |mon|
        next unless mon && !mon.fainted?
        
        can_sweep = true
        sweep_score = 0
        
        opp_side.each do |opp|
          next unless opp && !opp.fainted?
          
          # Check if we can KO this opponent
          best_move = find_best_attacking_move(mon, opp)
          if best_move
            damage_percent = estimate_damage_percent(mon, opp, best_move)
            if damage_percent >= 100
              sweep_score += 30  # OHKO
            elsif damage_percent >= 50
              sweep_score += 15  # 2HKO
            else
              can_sweep = false
              break
            end
          else
            can_sweep = false
            break
          end
          
          # Check if we outspeed or have priority
          unless outspeeds?(mon, opp) || has_priority_ko?(mon, opp)
            # Can we survive a hit?
            opp_damage = estimate_max_damage_from(opp, mon)
            if opp_damage >= mon.hp
              can_sweep = false
              break
            end
          end
        end
        
        if can_sweep && sweep_score > 0
          return {
            type: :sweep,
            pokemon: mon,
            score: sweep_score + 50,
            description: "#{mon.name} can sweep remaining opponents"
          }
        end
      end
      
      nil
    end
    
    # Attrition: Hazards + Chip will win over time
    def self.check_attrition_condition(battle, our_side, opp_side, skill_level)
      return nil unless skill_level >= 75
      
      score = 0
      
      # Check hazards on opponent's side
      opp_effects = battle.sides[1].effects
      
      if opp_effects[PBEffects::StealthRock]
        opp_side.each do |opp|
          next unless opp
          effectiveness = Effectiveness.calculate(:ROCK, opp.types[0], opp.types[1])
          if Effectiveness.super_effective?(effectiveness)
            score += 20  # SR hurts them
          end
        end
      end
      
      spikes = opp_effects[PBEffects::Spikes] || 0
      score += spikes * 10
      
      toxic_spikes = opp_effects[PBEffects::ToxicSpikes] || 0
      score += toxic_spikes * 8
      
      # Check if we have hazard setters
      our_side.each do |mon|
        next unless mon && !mon.fainted?
        if mon.moves.any? { |m| m && [:STEALTHROCK, :SPIKES, :TOXICSPIKES].include?(m.id) }
          score += 15
        end
      end
      
      # Check if we have recovery
      our_side.each do |mon|
        next unless mon && !mon.fainted?
        if mon.moves.any? { |m| m && [:RECOVER, :ROOST, :SOFTBOILED, :MOONLIGHT, :SYNTHESIS, :MORNINGSUN].include?(m.id) }
          score += 20
        end
      end
      
      return nil if score < 30
      
      {
        type: :attrition,
        pokemon: nil,
        score: score,
        description: "Hazard chip damage will win over time"
      }
    end
    
    # Stall: PP stall or Toxic stall
    def self.check_stall_condition(battle, our_side, opp_side, skill_level)
      return nil unless skill_level >= 80
      
      score = 0
      stall_mon = nil
      
      our_side.each do |mon|
        next unless mon && !mon.fainted?
        
        mon_score = 0
        
        # High defenses
        if mon.defense >= 120 || mon.spdef >= 120
          mon_score += 20
        end
        
        # Recovery moves
        if mon.moves.any? { |m| m && [:RECOVER, :ROOST, :SOFTBOILED, :SLACKOFF, :MOONLIGHT, :SYNTHESIS].include?(m.id) }
          mon_score += 30
        end
        
        # Toxic for stall
        if mon.moves.any? { |m| m && m.id == :TOXIC }
          mon_score += 25
        end
        
        # Protect for Toxic stall
        if mon.moves.any? { |m| m && [:PROTECT, :DETECT, :BANEFULBUNKER, :SPIKYSHIELD].include?(m.id) }
          mon_score += 15
        end
        
        # Wish + Protect
        if mon.moves.any? { |m| m && m.id == :WISH }
          mon_score += 20
        end
        
        if mon_score > score
          score = mon_score
          stall_mon = mon
        end
      end
      
      return nil if score < 40
      
      {
        type: :stall,
        pokemon: stall_mon,
        score: score,
        description: "#{stall_mon&.name || 'Team'} can stall out opponents"
      }
    end
    
    # Trade: Numerical advantage from 1-for-1 trades
    def self.check_trade_condition(battle, our_side, opp_side, skill_level)
      our_count = our_side.count { |p| p && !p.fainted? }
      opp_count = opp_side.count { |p| p && !p.fainted? }
      
      if our_count > opp_count
        advantage = our_count - opp_count
        {
          type: :trade,
          pokemon: nil,
          score: advantage * 25 + 20,
          description: "#{advantage} Pokemon advantage - trading wins"
        }
      else
        nil
      end
    end
    
    # Setup: One setup turn wins
    def self.check_setup_condition(battle, our_side, opp_side, skill_level)
      return nil unless skill_level >= 70
      
      our_side.each do |mon|
        next unless mon && !mon.fainted?
        
        # Check for setup moves
        setup_moves = mon.moves.select do |m|
          m && [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :QUIVERDANCE, :CALMMIND,
                :BULKUP, :IRONDEFENSE, :SHELLSMASH, :SHIFTGEAR, :COIL,
                :VICTORYDANCE, :FILLETAWAY, :BELLYDRUM, :AGILITY].include?(m.id)
        end
        
        next if setup_moves.empty?
        
        # Check if setup would enable sweep
        current_stages = mon.stages[:ATTACK] + mon.stages[:SPECIAL_ATTACK]
        
        if current_stages >= 2
          # Already set up - can we sweep?
          can_clean = opp_side.all? do |opp|
            next true unless opp && !opp.fainted?
            best = find_best_attacking_move(mon, opp)
            best && estimate_damage_percent(mon, opp, best) >= 50
          end
          
          if can_clean
            return {
              type: :setup,
              pokemon: mon,
              score: 70 + (current_stages * 10),
              description: "#{mon.name} is set up and can clean"
            }
          end
        else
          # Need to set up - is there opportunity?
          return {
            type: :setup,
            pokemon: mon,
            score: 50,
            description: "#{mon.name} needs setup opportunity"
          }
        end
      end
      
      nil
    end
    
    # Revenge: Priority or faster revenge kills
    def self.check_revenge_condition(battle, our_side, opp_side, skill_level)
      return nil unless skill_level >= 65
      
      score = 0
      revenge_mons = []
      
      our_side.each do |mon|
        next unless mon && !mon.fainted?
        
        priority_moves = mon.moves.select do |m|
          m && m.priority > 0 && m.damagingMove?
        end
        
        next if priority_moves.empty?
        
        # Check if priority can KO weakened opponents
        opp_side.each do |opp|
          next unless opp && !opp.fainted?
          next unless opp.hp < opp.totalhp * 0.5  # Weakened
          
          priority_moves.each do |pm|
            damage = estimate_damage_percent(mon, opp, pm)
            if damage >= (opp.hp.to_f / opp.totalhp * 100)
              score += 20
              revenge_mons << mon unless revenge_mons.include?(mon)
            end
          end
        end
      end
      
      return nil if score < 20
      
      {
        type: :revenge,
        pokemon: revenge_mons.first,
        score: score + 30,
        description: "Priority moves can secure KOs"
      }
    end
    
    # Speed Control: Win via speed advantage
    def self.check_speed_control_condition(battle, our_side, opp_side, skill_level)
      return nil unless skill_level >= 70
      
      # Check speed control active
      our_effects = battle.sides[0].effects
      
      score = 0
      
      if our_effects[PBEffects::Tailwind] && our_effects[PBEffects::Tailwind] > 0
        score += 40
      end
      
      if battle.field.effects[PBEffects::TrickRoom] && battle.field.effects[PBEffects::TrickRoom] > 0
        # Check if we benefit from TR
        our_slow = our_side.count { |m| m && !m.fainted? && m.speed < 80 }
        opp_slow = opp_side.count { |m| m && !m.fainted? && m.speed < 80 }
        
        if our_slow > opp_slow
          score += 35
        else
          score -= 20
        end
      end
      
      # Natural speed advantage
      our_fast = our_side.count { |m| m && !m.fainted? && m.speed >= 100 }
      opp_fast = opp_side.count { |m| m && !m.fainted? && m.speed >= 100 }
      
      if our_fast > opp_fast
        score += (our_fast - opp_fast) * 15
      end
      
      return nil if score < 25
      
      {
        type: :speed_control,
        pokemon: nil,
        score: score,
        description: "Speed advantage enables favorable trades"
      }
    end
    
    #===========================================================================
    # Score Modification Based on Win Condition
    #===========================================================================
    def self.apply_win_condition_bonus(battle, user, move, target, skill_level = 100)
      return 0 unless skill_level >= 70
      
      win_con = identify_win_condition(battle, user, skill_level)
      return 0 unless win_con
      
      score = 0
      
      case win_con[:type]
      when :sweep
        # Protect the sweeper, boost its moves
        if win_con[:pokemon] == user
          score += 30 if move.damagingMove?  # Attack with sweeper
        elsif win_con[:pokemon]
          # Support the sweeper
          if move.id == :HELPINGHAND
            score += 25
          end
          # Redirect attacks away from sweeper
          if [:FOLLOWME, :RAGEPOWDER].include?(move.id)
            score += 20
          end
        end
        
      when :attrition
        # Prioritize hazards
        if [:STEALTHROCK, :SPIKES, :TOXICSPIKES, :STICKYWEB].include?(move.id)
          score += 25
        end
        # Value recovery
        if [:RECOVER, :ROOST, :SOFTBOILED, :SYNTHESIS].include?(move.id)
          score += 20 if user.hp < user.totalhp * 0.6
        end
        
      when :stall
        # Prioritize status
        if move.id == :TOXIC
          score += 30 if target && !target.poisoned?
        end
        # Protect for stall
        if [:PROTECT, :DETECT].include?(move.id)
          score += 15 if user.effects[PBEffects::Toxic] && user.effects[PBEffects::Toxic] > 0
        end
        # Recovery high priority
        if [:RECOVER, :ROOST, :SOFTBOILED].include?(move.id)
          score += 25 if user.hp < user.totalhp * 0.7
        end
        
      when :trade
        # Aggressive plays
        if move.damagingMove?
          score += 15
        end
        # Don't overvalue setup when ahead
        if [:SWORDSDANCE, :NASTYPLOT, :CALMMIND].include?(move.id)
          score -= 10
        end
        
      when :setup
        # Boost setup moves for the setup mon
        if win_con[:pokemon] == user
          if [:SWORDSDANCE, :NASTYPLOT, :DRAGONDANCE, :QUIVERDANCE, :CALMMIND,
              :SHELLSMASH, :AGILITY].include?(move.id)
            score += 35 if user.stages[:ATTACK] < 2 && user.stages[:SPECIAL_ATTACK] < 2
          end
        end
        
      when :revenge
        # Priority moves valuable
        if move.priority > 0 && move.damagingMove?
          if target && target.hp < target.totalhp * 0.5
            score += 25
          end
        end
        
      when :speed_control
        # Maintain speed advantage
        if [:TAILWIND, :TRICKROOM].include?(move.id)
          score += 20
        end
        # Speed control attacks
        if [:ICYWIND, :ELECTROWEB, :BULLDOZE, :ROCKTOMB].include?(move.id)
          score += 15
        end
      end
      
      score
    end
    
    #===========================================================================
    # Helper Methods
    #===========================================================================
    private
    
    def self.get_side_pokemon(battle, user, own_side: true)
      if own_side
        battle.pbParty(user.index).select { |p| p && !p.fainted? }
      else
        # Get opponent's party
        opp_index = (user.index + 1) % 2
        battle.pbParty(opp_index).select { |p| p && !p.fainted? }
      end
    end
    
    def self.find_best_attacking_move(user, target)
      return nil unless user.moves
      
      best_move = nil
      best_damage = 0
      
      user.moves.each do |move|
        next unless move && move.damagingMove?
        
        damage = estimate_damage_percent(user, target, move)
        if damage > best_damage
          best_damage = damage
          best_move = move
        end
      end
      
      best_move
    end
    
    def self.estimate_damage_percent(user, target, move)
      return 0 unless move && move.damagingMove?
      
      # Get attacking stat - handle both Battler and Pokemon objects
      user_stages = user.respond_to?(:stages) ? user.stages : {}
      target_stages = target.respond_to?(:stages) ? target.stages : {}
      
      if move.physicalMove?
        atk = user.attack * stage_multiplier(user_stages[:ATTACK] || 0)
        dfn = target.defense * stage_multiplier(target_stages[:DEFENSE] || 0)
      else  # Special
        atk = user.spatk * stage_multiplier(user_stages[:SPECIAL_ATTACK] || 0)
        dfn = target.spdef * stage_multiplier(target_stages[:SPECIAL_DEFENSE] || 0)
      end
      
      dfn = [dfn, 1].max  # Prevent division by zero
      
      # Base damage calculation
      power = move.power
      return 0 if power == 0
      
      damage = ((2 * user.level / 5 + 2) * power * atk / dfn / 50 + 2)
      
      # STAB - handle both Battler (pbHasType?) and Pokemon (hasType?)
      has_stab = user.respond_to?(:pbHasType?) ? user.pbHasType?(move.type) : user.hasType?(move.type)
      if has_stab
        damage *= 1.5
      end
      
      # Type effectiveness - handle both Battler (types) and Pokemon (type1/type2)
      t1 = target.respond_to?(:types) ? target.types[0] : target.type1
      t2 = target.respond_to?(:types) ? target.types[1] : target.type2
      type_mod = Effectiveness.calculate(move.type, t1, t2)
      damage *= type_mod / Effectiveness::NORMAL_EFFECTIVE
      
      # Convert to percentage
      (damage / target.totalhp.to_f) * 100
    end
    
    def self.estimate_max_damage_from(attacker, defender)
      max_damage = 0
      
      return 0 unless attacker.moves
      
      attacker.moves.each do |move|
        next unless move && move.damagingMove?
        damage = estimate_damage_percent(attacker, defender, move)
        damage_hp = (damage / 100.0) * defender.totalhp
        max_damage = damage_hp if damage_hp > max_damage
      end
      
      max_damage
    end
    
    def self.outspeeds?(user, target)
      user_speed = user.speed * stage_multiplier(user.stages[:SPEED] || 0)
      target_speed = target.speed * stage_multiplier(target.stages[:SPEED] || 0)
      
      user_speed > target_speed
    end
    
    def self.has_priority_ko?(user, target)
      return false unless user.moves
      
      user.moves.any? do |move|
        next false unless move && move.priority > 0 && move.damagingMove?
        estimate_damage_percent(user, target, move) >= (target.hp.to_f / target.totalhp * 100)
      end
    end
    
    def self.stage_multiplier(stage)
      stage = stage.clamp(-6, 6)
      if stage >= 0
        (2 + stage) / 2.0
      else
        2.0 / (2 - stage)
      end
    end
  end
end

# API Methods
module AdvancedAI
  def self.identify_win_condition(battle, user, skill_level = 100)
    WinConditions.identify_win_condition(battle, user, skill_level)
  end
  
  def self.apply_win_condition_bonus(battle, user, move, target, skill_level = 100)
    WinConditions.apply_win_condition_bonus(battle, user, move, target, skill_level)
  end
end

AdvancedAI.log("Win Condition Identification System loaded", "WinCon")
AdvancedAI.log("  - Sweep detection", "WinCon")
AdvancedAI.log("  - Attrition/Hazard win paths", "WinCon")
AdvancedAI.log("  - Stall condition tracking", "WinCon")
AdvancedAI.log("  - Trade advantage awareness", "WinCon")
AdvancedAI.log("  - Setup sweeper protection", "WinCon")
AdvancedAI.log("  - Revenge kill opportunities", "WinCon")
AdvancedAI.log("  - Speed control advantage", "WinCon")

### FILE: ZMove_Intelligence.rb ###
#===============================================================================
# Advanced AI System - Z-Move Intelligence (DBK_004 Integration)
# Logic for optimal Z-Move usage
#===============================================================================

class Battle::AI
  # Main entry point for checking Z-Moves usage
  def should_z_move?(user, skill)
    return false unless AdvancedAI.dbk_enabled?(:z_moves)
    # Check if user can use Z-Moves (uses fixed helper method)
    return false unless user.can_z_move?
    
    score = 0
    
    # 1. Damage Potential (OHKO check)
    score += evaluate_z_move_damage(user, skill)
    
    # 2. Status Z-Move Value
    score += evaluate_z_move_status(user)
    
    AdvancedAI.log("Z-Move Eval for #{user.pbThis}: Score #{score}", "Z-Move")
    
    # Thresholds
    return true if score >= 40   # Excellent opportunity (OHKO)
    return true if score >= 20 && user.hp <= user.totalhp * 0.3 # Desperation
    
    return false
  end
  
  private
  
  def evaluate_z_move_damage(user, skill)
    score = 0
    best_move = nil
    max_damage = 0
    
    # Find best offensive Z-Move
    user.moves.each_with_index do |move, i|
      next unless move.damagingMove?
      # Assuming logic exists to get Z-Move equivalent or calculating roughly based on power
      # DBK_004 handles the actual conversion, but for AI we approximate:
      # Z-Moves are usually high power (100-200 BP).
      
      # Simplified: Assume the Z-Move is available and super-strong
      # Check coverage against targets
      @battle.allOtherSideBattlers(user.index).each do |target|
        next unless target && !target.fainted?
        
        # Calculate rough damage with a "Z-Boost" (approx 1.5x - 2.0x normal max power)
        rough_dmg = calculate_rough_damage(move, user, target) * 1.8
        
        if rough_dmg >= target.hp
          score = 50 # Guaranteed KO found!
          AdvancedAI.log("Z-Move KO predicted vs #{target.name}", "Z-Move")
          return score # Return immediately if we found a kill
        end
        
        if rough_dmg > max_damage
          max_damage = rough_dmg 
        end
      end
    end
    
    # If no KO, but high damage
    if max_damage > 0
      score += 15
    end
    
    return score
  end
  
  def evaluate_z_move_status(user)
    score = 0
    user.moves.each do |move|
      next unless move.statusMove?
      # Check for specific high-value Status Z-Moves
      # Z-Splash (Attack +3)
      if move.id == :SPLASH
        score += 30 
      end
      
      # Z-Belly Drum (Full Heal + Max Attack)
      if move.id == :BELLYDRUM
        score += 30
      end
      
      # Omniboosting Z-Moves (Z-Celebrate, Z-Happy Hour, etc.)
      if [:CELEBRATE, :HAPPYHOUR, :CONVERSION, :GEOMANCY].include?(move.id)
        score += 25
      end
    end
    return score
  end
end

class Battle::Battler
  def can_z_move?
    # Check if we have a Z-Crystal held and appropriate move
    # Use the DBK method directly
    return @battle.pbCanZMove?(@index) if @battle.respond_to?(:pbCanZMove?)
    return false
  end
end

class Battle::AI::AIBattler
  def can_z_move?
    return @battler.can_z_move? if @battler.respond_to?(:can_z_move?)
    # Fallback: check via battle reference
    return false unless @battler && @battler.battle
    return @battler.battle.pbCanZMove?(@battler.index) rescue false
  end
end

### FILE: Console_Fix.rb ###
#===============================================================================
# Advanced AI System - Console Output Fix
# Fixes Windows beep issue when using echoln in debug mode
#===============================================================================

# Store the original echoln method if it exists
if !defined?(ORIGINAL_ECHOLN_ALIASED)
  ORIGINAL_ECHOLN_ALIASED = true
  
  # Define a quieter version of echoln that won't trigger Windows beeps
  module Kernel
    # Save the original echoln if it exists
    if respond_to?(:echoln)
      alias original_echoln_aai echoln
    end
    
    def echoln(msg = "")
      # Only output in debug mode
      return unless $DEBUG
      
      begin
        # Try to write directly to STDOUT without triggering beeps
        # Remove any bell characters (\a or \x07) that might cause beeps
        clean_msg = msg.to_s.gsub(/[\a\x07]/, '')
        
        # Use puts instead of the original echoln to avoid beep-triggering behavior
        puts clean_msg
        
        # Force flush to ensure immediate output
        STDOUT.flush
      rescue
        # Fallback: if anything fails, just be silent
        # Better than crashing or beeping
      end
    end
  end
end
                 
### FILE: Custom_Content.rb ###
#===============================================================================
# [013] Custom Content - Gen 1-9 Abilities & Type Recognition
#===============================================================================
# Recognizes and evaluates 267+ Abilities from Gen 1-9
# Supports Custom Abilities from Plugins (DBK, Reborn, etc.)
#
# Categories:
# - Offensive Abilities (Huge Power, Adaptability, Technician, etc.)
# - Defensive Abilities (Multiscale, Fur Coat, Filter, etc.)
# - Speed Abilities (Speed Boost, Quick Feet, Unburden, etc.)
# - Support Abilities (Prankster, Magic Bounce, Regenerator, etc.)
# - Weather/Terrain Abilities (Drought, Drizzle, Electric Surge, etc.)
# - Ability Nullification (Mold Breaker, Teravolt, Turboblaze, etc.)
#===============================================================================

module AdvancedAI
  module CustomContent
    
    #===========================================================================
    # Offensive Abilities (increase Threat significantly)
    #===========================================================================
    OFFENSIVE_ABILITIES = {
      # Power-Boost (Threat +3.0)
      :HUGEPOWER          => 3.0,  # 2x Atk
      :PUREPOWER          => 3.0,  # 2x Atk
      :ADAPTABILITY       => 2.5,  # 2x STAB
      :SHEERFORCE         => 2.0,  # 1.3x Power (no secondary)
      :IRONFIST           => 1.5,  # 1.2x Punching moves
      :TOUGHCLAWS         => 1.8,  # 1.3x Contact moves
      :STRONGJAW          => 1.5,  # 1.5x Bite moves
      :MEGALAUNCHER       => 1.5,  # 1.5x Pulse/Aura moves
      
      # Type-Boost (Threat +1.5-2.0)
      :TECHNICIAN         => 2.0,  # 1.5x moves ≤60 BP
      :ANALYTIC           => 1.5,  # 1.3x if moving last
      :SNIPER             => 1.5,  # 1.5x on crit
      :TINTEDLENS         => 2.0,  # NVE → Neutral damage
      :SCRAPPY            => 1.5,  # Hit Ghost with Normal/Fighting
      
      # Crit-Boost (Threat +1.5)
      :SUPERLUCK          => 1.5,  # +1 Crit stage
      :MERCILESS          => 2.0,  # Auto-crit on poisoned targets
      
      # Multi-Hit (Threat +1.5)
      :SKILLLINK          => 2.0,  # Multi-hit = max hits
      :PARENTALBOND       => 2.5,  # 2 hits (1.0 + 0.25)
      
      # Stat-Based (Threat +1.0-2.0)
      :DOWNLOAD           => 1.5,  # +1 Atk or SpAtk
      :INTREPIDSWORD      => 2.0,  # +1 Atk on entry
      :DAUNTLESSSHIELD    => 1.0,  # +1 Def on entry (defensive)
      :BEASTBOOST         => 1.8,  # +1 highest stat on KO
      :MOXIE              => 1.8,  # +1 Atk on KO
      :SOULHEART          => 1.5,  # +1 SpAtk on any KO
      
      # Ability-Negation (Threat +1.5)
      :MOLDBREAKER        => 1.8,  # Ignore opponent abilities
      :TERAVOLT           => 1.8,  # Same as Mold Breaker
      :TURBOBLAZE         => 1.8,  # Same as Mold Breaker
      :NEUTRALIZINGGAS    => 2.0,  # Suppress all abilities
      
      # Gen 9 Abilities
      :ORICHALCUMPULSE    => 2.5,  # Sun + 1.3x Atk
      :HADRONENGINE       => 2.5,  # Electric Terrain + 1.3x SpAtk
      :SUPREMEOVERLORD    => 2.0,  # +10% per fainted ally
      :PROTOSYNTHESIS     => 1.8,  # Highest stat x1.3 in Sun
      :QUARKDRIVE         => 1.8,  # Highest stat x1.3 in Electric Terrain
      :TOXICDEBRIS        => 1.5,  # Sets Toxic Spikes on hit
    }
    
    #===========================================================================
    # Defensive Abilities (reduce Threat / increase Survival)
    #===========================================================================
    DEFENSIVE_ABILITIES = {
      # Damage Reduction (Threat -2.0)
      :MULTISCALE         => -2.5, # 50% damage at full HP
      :SHADOWSHIELD       => -2.5, # Same as Multiscale
      :FILTER             => -1.5, # 0.75x SE damage
      :SOLIDROCK          => -1.5, # Same as Filter
      :PRISMARMOR         => -1.8, # 0.75x SE damage (better)
      :FURCOAT            => -3.0, # 2x Defense (physical)
      :FLUFFY             => -2.0, # 50% contact damage (but 2x Fire)
      
      # Immunities (Threat -1.5)
      :WONDERGUARD        => -5.0, # Only SE damage (extreme)
      :LEVITATE           => -1.5, # Ground immunity
      :VOLTABSORB         => -1.5, # Electric immunity + heal
      :WATERABSORB        => -1.5, # Water immunity + heal
      :FLASHFIRE          => -1.5, # Fire immunity + boost
      :SAPSIPPER          => -1.5, # Grass immunity + Atk boost
      :STORMDRAIN         => -2.0, # Water immunity + SpAtk boost
      :LIGHTNINGROD       => -2.0, # Electric immunity + SpAtk boost
      :MOTORDRIVE         => -1.8, # Electric immunity + Speed boost
      :DRYSKIN            => -1.5, # Water heal, Fire weak
      :THICKFAT           => -1.5, # 50% Fire/Ice damage
      
      # Recovery (Threat -1.5)
      :REGENERATOR        => -2.0, # 33% HP on switch
      :POISONHEAL         => -2.0, # Heal from poison
      :ICEBODY            => -1.0, # Heal in Hail
      :RAINDISH           => -1.0, # Heal in Rain
      
      # Stat-Boost (Threat -1.0)
      :CONTRARY           => -1.5, # Reverse stat changes
      :UNAWARE            => -2.0, # Ignore opponent stat changes
      :CLEARBODY          => -1.0, # Prevent stat drops
      :WHITESMOKE         => -1.0, # Same as Clear Body
      :FULLMETALBODY      => -1.0, # Same as Clear Body
      :HYPERCUTTER        => -0.5, # Prevent Atk drops
      :KEENEYE            => -0.5, # Prevent Acc drops
      :BIGPECKS           => -0.5, # Prevent Def drops
      
      # Status Immunity (Threat -1.0)
      :IMMUNITY           => -1.0, # Poison immunity
      :WATERVEIL          => -0.8, # Burn immunity
      :MAGMAARMOR         => -0.8, # Freeze immunity
      :LIMBER             => -0.8, # Paralysis immunity
      :INSOMNIA           => -0.8, # Sleep immunity
      :VITALSPIRIT        => -0.8, # Sleep immunity
      :OBLIVIOUS          => -1.0, # Attract/Taunt immunity
      :INNERFOCUS         => -0.8, # Flinch immunity
      
      # Gen 9 Defensive
      :WELLBAKEDBODY      => -2.0, # Fire immunity + Def boost
      :EARTHEATER         => -2.0, # Ground immunity + heal
      :WINDRIDER          => -1.8, # Wind immunity + Atk boost
      :GUARDDOG           => -1.0, # Intimidate immunity + Atk boost
      :PURIFYINGSALT      => -2.0, # Ghost resist + status immunity
    }
    
    #===========================================================================
    # Speed Abilities (increase Speed Threat)
    #===========================================================================
    SPEED_ABILITIES = {
      # Speed-Boost (Threat +1.5)
      :SPEEDBOOST         => 2.0,  # +1 Speed per turn
      :MOTORDRIVE         => 1.5,  # +1 Speed on Electric hit
      :QUICKFEET          => 1.5,  # 1.5x Speed with status
      :UNBURDEN           => 2.5,  # 2x Speed after item use
      :CHLOROPHYLL        => 2.0,  # 2x Speed in Sun
      :SWIFTSWIM          => 2.0,  # 2x Speed in Rain
      :SANDRUSH           => 2.0,  # 2x Speed in Sandstorm
      :SLUSHRUSH          => 2.0,  # 2x Speed in Hail
      :SURGESURFER        => 2.0,  # 2x Speed in Electric Terrain
      
      # Priority (Threat +1.5)
      :PRANKSTER          => 2.5,  # +1 priority on status moves
      :GALEWINGS          => 2.0,  # +1 priority on Flying moves (full HP)
      :TANGLINGHAIR       => 1.0,  # Lower Speed on contact
      :GORILLATACTICS     => 2.0,  # 1.5x Atk but locked (like Choice)
      
      # Gen 9 Speed
      :GOODASGOLD         => -2.5, # Status move immunity (defensive)
    }
    
    #===========================================================================
    # Support Abilities (increase Team Utility)
    #===========================================================================
    SUPPORT_ABILITIES = {
      # Disruption (Threat +1.0)
      :INTIMIDATE         => 1.5,  # -1 Atk to opponents
      :DROUGHT            => 1.5,  # Sets Sun
      :DRIZZLE            => 1.5,  # Sets Rain
      :SANDSTREAM         => 1.5,  # Sets Sandstorm
      :SNOWWARNING        => 1.5,  # Sets Hail
      :ELECTRICSURGE      => 1.5,  # Sets Electric Terrain
      :GRASSYSURGE        => 1.5,  # Sets Grassy Terrain
      :MISTYSURGE         => 1.5,  # Sets Misty Terrain
      :PSYCHICSURGE       => 1.5,  # Sets Psychic Terrain
      
      # Redirect (Threat +1.0)
      :LIGHTNINGROD       => 1.5,  # Redirect Electric
      :STORMDRAIN         => 1.5,  # Redirect Water
      
      # Reflection (Threat +1.5)
      :MAGICBOUNCE        => 2.0,  # Reflect status moves
      :MAGICGUARD         => 1.5,  # No indirect damage
      
      # Entry Hazards (Threat +1.0)
      :ROUGHSKIN          => 1.0,  # Damage on contact
      :IRONBARBS          => 1.0,  # Damage on contact
      :POISONPOINT        => 0.8,  # 30% Poison on contact
      :STATIC             => 0.8,  # 30% Paralyze on contact
      :FLAMEBODY          => 0.8,  # 30% Burn on contact
      
      # Gen 9 Support
      :COSTAR             => 1.5,  # Copy ally stat changes
      :OPPORTUNIST        => 1.8,  # Copy opponent stat boosts
      :COMMANDER          => 2.0,  # Dondozo synergy (Hidden)
    }
    
    #===========================================================================
    # Ability Recognition
    #===========================================================================
    
    # Returns Threat Modifier for Ability
    def self.get_ability_threat(ability_id)
      return 0.0 if !ability_id
      
      ability_id = ability_id.to_sym if ability_id.is_a?(String)
      
      # Offensive Check
      return OFFENSIVE_ABILITIES[ability_id] if OFFENSIVE_ABILITIES.key?(ability_id)
      
      # Defensive Check
      return DEFENSIVE_ABILITIES[ability_id] if DEFENSIVE_ABILITIES.key?(ability_id)
      
      # Speed Check
      return SPEED_ABILITIES[ability_id] if SPEED_ABILITIES.key?(ability_id)
      
      # Support Check
      return SUPPORT_ABILITIES[ability_id] if SUPPORT_ABILITIES.key?(ability_id)
      
      return 0.0  # Unknown ability
    end
    
    # Checks if Ability is defensive
    def self.defensive_ability?(ability_id)
      return false if !ability_id
      ability_id = ability_id.to_sym if ability_id.is_a?(String)
      return DEFENSIVE_ABILITIES.key?(ability_id)
    end
    
    # Checks if Ability is offensive
    def self.offensive_ability?(ability_id)
      return false if !ability_id
      ability_id = ability_id.to_sym if ability_id.is_a?(String)
      return OFFENSIVE_ABILITIES.key?(ability_id)
    end
    
    # Checks if Ability boosts Speed
    def self.speed_ability?(ability_id)
      return false if !ability_id
      ability_id = ability_id.to_sym if ability_id.is_a?(String)
      return SPEED_ABILITIES.key?(ability_id)
    end
    
    # Checks if Ability has Support function
    def self.support_ability?(ability_id)
      return false if !ability_id
      ability_id = ability_id.to_sym if ability_id.is_a?(String)
      return SUPPORT_ABILITIES.key?(ability_id)
    end
    
    # Categorizes Ability
    def self.categorize_ability(ability_id)
      return :unknown if !ability_id
      ability_id = ability_id.to_sym if ability_id.is_a?(String)
      
      return :offensive if OFFENSIVE_ABILITIES.key?(ability_id)
      return :defensive if DEFENSIVE_ABILITIES.key?(ability_id)
      return :speed if SPEED_ABILITIES.key?(ability_id)
      return :support if SUPPORT_ABILITIES.key?(ability_id)
      
      return :unknown
    end
    
    #===========================================================================
    # Weather/Terrain Synergy Detection
    #===========================================================================
    
    # Checks if Ability benefits from current Weather
    def self.benefits_from_weather?(battler, weather)
      return false if !battler || !weather
      ability = battler.ability_id
      return false if !ability
      
      case weather
      when :Sun, :HarshSun
        return [:CHLOROPHYLL, :SOLARPOWER, :FLOWERGIFT, :LEAFGUARD, 
                :PROTOSYNTHESIS, :ORICHALCUMPULSE].include?(ability)
      when :Rain, :HeavyRain
        return [:SWIFTSWIM, :RAINDISH, :DRYSKIN, :HYDRATION].include?(ability)
      when :Sandstorm
        return [:SANDRUSH, :SANDVEIL, :SANDFORCE, :OVERCOAT].include?(ability)
      when :Hail
        return [:SLUSHRUSH, :SNOWCLOAK, :ICEBODY, :OVERCOAT].include?(ability)
      end
      
      return false
    end
    
    # Checks if Ability benefits from active Terrain
    def self.benefits_from_terrain?(battler, terrain)
      return false if !battler || !terrain
      ability = battler.ability_id
      return false if !ability
      
      case terrain
      when :Electric
        return [:SURGESURFER, :QUARKDRIVE, :HADRONENGINE].include?(ability)
      when :Grassy
        return [:GRASSPELT].include?(ability)
      when :Psychic
        return false  # No direct Ability synergies
      when :Misty
        return false  # No direct Ability synergies
      end
      
      return false
    end
    
    #===========================================================================
    # Ability Nullification Check
    #===========================================================================
    
    # Checks if Attacker ignores Abilities
    def self.ignores_abilities?(attacker)
      return false if !attacker
      ability = attacker.ability_id
      return false if !ability
      
      return [:MOLDBREAKER, :TERAVOLT, :TURBOBLAZE, 
              :NEUTRALIZINGGAS].include?(ability)
    end
    
    # Checks if Target Ability is suppressed by Attacker
    def self.ability_suppressed?(attacker, target)
      return false if !attacker || !target
      return true if ignores_abilities?(attacker)
      return true if target.effects[PBEffects::GastroAcid]  # Gastro Acid
      return false
    end
    
    #===========================================================================
    # Complex Ability Interactions
    #===========================================================================
    
    # Calculates final Damage Modifier from Abilities
    def self.calculate_ability_damage_modifier(attacker, target, move, battle)
      modifier = 1.0
      return modifier if !attacker || !target || !move
      
      attacker_ability = attacker.ability_id
      target_ability = target.ability_id
      
      # Attacker Abilities
      if attacker_ability && !ability_suppressed?(target, attacker)
        case attacker_ability
        when :HUGEPOWER, :PUREPOWER
          modifier *= 2.0 if move.physicalMove?
        when :ADAPTABILITY
          modifier *= 2.0 if move.type == attacker.type1 || move.type == attacker.type2
        when :TOUGHCLAWS
          modifier *= 1.3 if move.contactMove?
        when :SHEERFORCE
          modifier *= 1.3 if move.additional_effect_chance > 0
        when :TECHNICIAN
          modifier *= 1.5 if move.power <= 60
        when :IRONFIST
          modifier *= 1.2 if move.punching_move?
        when :STRONGJAW
          modifier *= 1.5 if move.biting_move?
        when :TINTEDLENS
          effectiveness = Effectiveness.calculate(move.type, target.type1, target.type2)
          modifier *= 2.0 if Effectiveness.not_very_effective?(effectiveness)
        end
      end
      
      # Target Abilities (Defensive)
      if target_ability && !ability_suppressed?(attacker, target)
        case target_ability
        when :MULTISCALE, :SHADOWSHIELD
          modifier *= 0.5 if target.hp == target.totalhp
        when :FILTER, :SOLIDROCK, :PRISMARMOR
          effectiveness = Effectiveness.calculate(move.type, target.type1, target.type2)
          modifier *= 0.75 if Effectiveness.super_effective?(effectiveness)
        when :FURCOAT
          modifier *= 0.5 if move.physicalMove?
        when :FLUFFY
          modifier *= 0.5 if move.contactMove?
          modifier *= 2.0 if move.type == :FIRE
        when :THICKFAT
          modifier *= 0.5 if [:FIRE, :ICE].include?(move.type)
        end
      end
      
      return modifier
    end
    
  end
end

#===============================================================================
# API Wrapper
#===============================================================================
module AdvancedAI
  def self.get_ability_threat(ability_id)
    CustomContent.get_ability_threat(ability_id)
  end
  
  def self.defensive_ability?(ability_id)
    CustomContent.defensive_ability?(ability_id)
  end
  
  def self.offensive_ability?(ability_id)
    CustomContent.offensive_ability?(ability_id)
  end
  
  def self.categorize_ability(ability_id)
    CustomContent.categorize_ability(ability_id)
  end
  
  def self.benefits_from_weather?(battler, weather)
    CustomContent.benefits_from_weather?(battler, weather)
  end
  
  def self.benefits_from_terrain?(battler, terrain)
    CustomContent.benefits_from_terrain?(battler, terrain)
  end
  
  def self.ignores_abilities?(attacker)
    CustomContent.ignores_abilities?(attacker)
  end
  
  def self.ability_suppressed?(attacker, target)
    CustomContent.ability_suppressed?(attacker, target)
  end
  
  def self.calculate_ability_damage_modifier(attacker, target, move, battle)
    CustomContent.calculate_ability_damage_modifier(attacker, target, move, battle)
  end
end

### FILE: DBK_Compatibility.rb ###
#===============================================================================
# Advanced AI System - DBK Compatibility Patches
# Makes DBK gimmicks work for wild Pokemon with attributes set (as documented)
#===============================================================================
# [DBK] Deluxe Battle Kit Compatibility Patches
#===============================================================================
# Fixes DBK AI trying to access statDown/statUp on Unimplemented moves
class Battle::Move
  def statDown
    return []
  end unless method_defined?(:statDown)

  def statUp
    return []
  end unless method_defined?(:statUp)
end

#===============================================================================

#===============================================================================
# Dynamax Compatibility
# Allows wild Pokemon with dynamax_lvl > 0 to Dynamax (as per DBK docs)
#===============================================================================
# Only apply patch if the FULL Dynamax plugin is installed (not just placeholder)
# DBK_000 defines a parameterless placeholder: def hasDynamax?; return false; end
# DBK_005 defines the real method: def hasDynamax?(check_available = true)
# We check arity to distinguish: arity == 0 means placeholder, arity == -1 means real
if defined?(Battle::Battler) && Battle::Battler.method_defined?(:hasDynamax?) &&
   Battle::Battler.instance_method(:hasDynamax?).arity != 0
  class Battle::Battler
    alias aai_compat_hasDynamax? hasDynamax?
    def hasDynamax?(check_available = true)
      # Wild Pokemon with dynamax_lvl set should be eligible
      # Check if method exists to prevent crash if simple DBK is installed without Dynamax
      if wild? && @pokemon&.respond_to?(:dynamax_lvl) && @pokemon.dynamax_lvl && @pokemon.dynamax_lvl > 0
        AdvancedAI.log("  ✅ Wild Pokemon hasDynamax? override - has dynamax_lvl!", "Compatibility")
        return true
      end
      
      # Otherwise use original logic
      aai_compat_hasDynamax?(check_available)
    end
  end
  
  AdvancedAI.log("DBK hasDynamax? compatibility patch applied", "Compatibility")
end

if defined?(Battle) && Battle.method_defined?(:pbCanDynamax?)
  class Battle
    alias aai_compat_pbCanDynamax? pbCanDynamax?
    def pbCanDynamax?(idxBattler)
      battler = @battlers[idxBattler]
      
      # Special case: Wild Pokemon with dynamax_lvl set can Dynamax
      # This makes DBK work as documented in its tutorial
      if battler.wild? && battler.pokemon&.respond_to?(:dynamax_lvl) && battler.pokemon.dynamax_lvl && battler.pokemon.dynamax_lvl > 0
        AdvancedAI.log("  ✅ Wild Pokemon has dynamax_lvl, allowing Dynamax!", "Compatibility")
        # Still need to pass other checks (not in Sky Drop, etc.)
        if !battler.hasDynamax?
          AdvancedAI.log("  ❌ FAILED: battler.hasDynamax? returned false", "Compatibility")
          return false
        end
        AdvancedAI.log("  ✅ Passed hasDynamax check", "Compatibility")
        
        if battler.effects[PBEffects::SkyDrop] >= 0
          AdvancedAI.log("  ❌ FAILED: In Sky Drop", "Compatibility")
          return false
        end
        AdvancedAI.log("  ✅ Passed Sky Drop check", "Compatibility")
        
        # Check dyna slots if they exist
        if @dynamax
          side  = battler.idxOwnSide
          owner = pbGetOwnerIndexFromBattlerIndex(idxBattler)
          result = @dynamax[side][owner] == -1
          AdvancedAI.log("  Dynamax slot check: @dynamax[#{side}][#{owner}] == -1 ? #{result}", "Compatibility")
          return result
        end
        return true
      end
      
      # Otherwise use original logic
      aai_compat_pbCanDynamax?(idxBattler)
    end
  end
  
  AdvancedAI.log("DBK Dynamax compatibility patch applied", "Compatibility")
end

#===============================================================================
# Terastallization Compatibility
# Allows wild Pokemon with tera_type set to Terastallize (similar to Dynamax)
#===============================================================================

# Patch Pokemon#tera_type to return the set value for wild Pokemon
if defined?(Pokemon) && Pokemon.method_defined?(:tera_type)
  class Pokemon
    alias aai_compat_tera_type tera_type
    def tera_type
      # If @tera_type is explicitly set (e.g., via editWildPokemon), return it
      # This allows wild Pokemon to have their tera_type even if !terastal_able?
      if @tera_type && !@tera_type.nil?
        return @tera_type
      end
      # Otherwise use original logic
      aai_compat_tera_type
    end
    
    # Only alias/override if method exists
    if method_defined?(:terastallized=)
      alias aai_compat_terastallized= terastallized=
      def terastallized=(value)
        # If we have an explicit tera type (wild pokemon case), bypass the terastal_able check
        # ensuring the state persists (form change, icon, etc.)
        if @tera_type && !@tera_type.nil?
          @terastallized = value
          if @terastallized
            self.makeTerastalForm if respond_to?(:makeTerastalForm)
          else
            self.makeUnterastal if respond_to?(:makeUnterastal)
          end
          return
        end
        
        self.aai_compat_terastallized = value
      end
    end
    
    # FIX: Ensure tera? returns state, overriding any DBK placeholders
    def tera?
      return @terastallized
    end

    # FIX: Ensure dynamax? returns state, overriding any DBK placeholders
    def dynamax?
      return @dynamax
    end
    
    # FIX: Track if tera type was explicitly set (e.g. by battle rule)
    attr_accessor :explicit_tera_type
    
    if method_defined?(:tera_type=)
      alias aai_compat_tera_type= tera_type=
      def tera_type=(value)
        self.aai_compat_tera_type = value
        @explicit_tera_type = true
      end
    else
      # Define it if missing (DBK Tera not installed)
      def tera_type=(value)
        @tera_type = value
        @explicit_tera_type = true
      end
    end
  end
  
  AdvancedAI.log("DBK Pokemon#tera_type compatibility patch applied", "Compatibility")
end

if defined?(Battle::Battler) && Battle::Battler.method_defined?(:tera_type)
  class Battle::Battler
    alias aai_compat_battler_tera_type tera_type
    def tera_type
      # For wild Pokemon with explicitly set tera_type, return it directly
      if wild? && @pokemon&.instance_variable_get(:@tera_type)
        return @pokemon.instance_variable_get(:@tera_type)
      end
      # Otherwise use original logic
      aai_compat_battler_tera_type
    end
    
    # Debug logging for unTera - ONLY check if unTera exists
    if method_defined?(:unTera)
      alias aai_compat_unTera unTera
      def unTera(teraBreak = false)
        aai_compat_unTera(teraBreak)
      end
    end
  end
  
  AdvancedAI.log("DBK Battle::Battler#tera_type compatibility patch applied", "Compatibility")
end

if defined?(Battle::Battler) && Battle::Battler.method_defined?(:hasTera?)
  class Battle::Battler
    alias aai_compat_hasTera? hasTera?
    def hasTera?(check_available = true)
      # If this is a wild Pokemon with tera_type set, allow it
      # This makes the documented editWildPokemon behavior work
      if wild? && @pokemon&.respond_to?(:tera_type) && @pokemon.tera_type && !@pokemon.tera_type.nil?
        # Still check other restrictions
        return false if shadowPokemon?
        return false if @battle.raidBattle? && @battle.raidRules[:style] != :Tera
        return false if @pokemon.respond_to?(:hasTerastalForm?) && @pokemon.hasTerastalForm? && @effects[PBEffects::Transform]
        return false if @effects[PBEffects::TransformPokemon]&.respond_to?(:hasTerastalForm?) && @effects[PBEffects::TransformPokemon]&.hasTerastalForm?
        return false if !getActiveState.nil?
        
        # Check if hasEligibleAction exists and use it safely
        if respond_to?(:hasEligibleAction?)
           return false if hasEligibleAction?(:mega, :primal, :zmove, :ultra, :dynamax, :style, :zodiac)
        end

        side  = self.idxOwnSide
        owner = @battle.pbGetOwnerIndexFromBattlerIndex(@index)
        if @battle.respond_to?(:terastallize) && @battle.terastallize
           return false if check_available && @battle.terastallize[side][owner] == -2
        end
        return true
      end
      
      # Otherwise use original logic
      aai_compat_hasTera?(check_available)
    end

    # FIX: Ensure tera? delegates to pokemon, overriding placeholders
    def tera?
      return @pokemon&.tera?
    end

    # FIX: Ensure dynamax? delegates to pokemon, overriding placeholders
    def dynamax?
      return @pokemon&.dynamax?
    end
    
    # FIX: Override tera_type to bypass terastal_able? check
    # The issue: Pokemon#tera_type returns nil if terastal_able? is false,
    # but @tera_type is correctly set from PBS data. This causes hasTera? to fail.
    # Solution: Directly return the stored @tera_type value for trainer Pokemon.
    def tera_type
      return nil if !@pokemon
      # For trainer Pokemon, directly return the stored tera_type
      if !wild?
        stored_tera = @pokemon.instance_variable_get(:@tera_type)
        return stored_tera if stored_tera
      end
      # For wild Pokemon or if no stored value, use original logic
      return @pokemon.tera_type
    end
  end
  
  AdvancedAI.log("DBK Terastallization compatibility patch applied", "Compatibility")
end

# Also patch Battle#pbCanTerastallize? for wild Pokemon
if defined?(Battle) && Battle.method_defined?(:pbCanTerastallize?)
  class Battle
    alias aai_compat_pbCanTerastallize? pbCanTerastallize?
    def pbCanTerastallize?(idxBattler)
      battler = @battlers[idxBattler]
      
      # Special case: Wild Pokemon
      if battler.wild?
         # 1. Must have explicit tera type (set via editWildPokemon)
         return false unless battler.pokemon.respond_to?(:explicit_tera_type) && battler.pokemon.explicit_tera_type
         
         # 2. Must pass standard checks
         return false if !battler.hasTera?
         return false if battler.tera?
         
         # 3. Slot check (is someone else terastallized?)
         side  = battler.idxOwnSide
         owner = pbGetOwnerIndexFromBattlerIndex(idxBattler)
         # In DBK, -1 means available, 0+ means used/active index, -2 means disabled?
         if @terastallize
            return true if @terastallize[side][owner] == -1
         else
            return true
         end
         
         return false
      end
      
      # Otherwise use original logic (Trainer)
      return aai_compat_pbCanTerastallize?(idxBattler)
    end
  end
  
  #=============================================================================
  # Patch [DBK] Enhanced Battle UI to allow Wild Tera Icons
  #=============================================================================
  if defined?(Battle::Scene) && Battle::Scene.method_defined?(:pbAddTypesDisplay)
    class Battle::Scene
      # Override pbAddTypesDisplay to allow wild pokemon strict check bypass
      # We cannot alias because we need to change a specific line in the middle
      def pbAddTypesDisplay(xpos, ypos, battler, poke)
        return unless battler && poke
        
        #---------------------------------------------------------------------------
        # Gets display types (considers Illusion)
        illusion = battler.effects[PBEffects::Illusion] && !battler.pbOwnedByPlayer?
        
        is_tera = battler.respond_to?(:tera?) && battler.tera?
        
        if is_tera
          displayTypes = (illusion) ? poke.types.clone : battler.pbPreTeraTypes
        elsif illusion
          displayTypes = poke.types.clone
          displayTypes.push(battler.effects[PBEffects::ExtraType]) if battler.effects[PBEffects::ExtraType]
        else
          displayTypes = battler.pbTypes(true)
        end
        #---------------------------------------------------------------------------
        # Displays the "???" type on newly encountered species, or battlers with no typing.
        if Settings::SHOW_TYPE_EFFECTIVENESS_FOR_NEW_SPECIES
          unknown_species = false
        else
          unknown_species = !(
            !@battle.internalBattle ||
            battler.pbOwnedByPlayer? ||
            $player.pokedex.owned?(poke.species) ||
            $player.pokedex.battled_count(poke.species) > 0
          )
        end
        displayTypes = [:QMARKS] if unknown_species || displayTypes.empty?
        #---------------------------------------------------------------------------
        # Draws each display type. Maximum of 3 types.
        typeY = (displayTypes.length >= 3) ? ypos + 6 : ypos + 34
        
        # FIX: Re-applied correct path and rescue - User's file was missing
        begin
          path = "Graphics/Battle/icon_types" 
          # Check if existing path provided by user exists, else fallback
          if !pbResolveBitmap(path)
             path = "Graphics/UI/types"
          end
          typebitmap = AnimatedBitmap.new(_INTL(path))

          displayTypes.each_with_index do |type, i|
            break if i > 2
            type_number = GameData::Type.get(type).icon_position
            type_rect = Rect.new(0, type_number * 28, 64, 28)
            @enhancedUIOverlay.blt(xpos + 170, typeY + (i * 30), typebitmap.bitmap, type_rect)
          end
        rescue => e
          AdvancedAI.log("Error loading type icons (non-fatal): #{e.message}", "Compatibility")
        end

        #---------------------------------------------------------------------------
        # Draws Tera type.
        if is_tera
          showTera = true
        else
          # ORIGINAL: showTera = defined?(battler.tera_type) && battler.pokemon.terastal_able?
          # FIXED: Allow wild pokes with tera_type SAFE CHECK
          showTera = false
          if battler.respond_to?(:tera_type) && battler.pokemon
             has_tera_type = battler.pokemon.respond_to?(:tera_type) && !battler.pokemon.tera_type.nil?
             is_able = battler.pokemon.respond_to?(:terastal_able?) && battler.pokemon.terastal_able?
             
             if is_able || (battler.wild? && has_tera_type)
               showTera = true
             end
          end
          
          showTera = ((@battle.internalBattle) ? !battler.opposes? : true) if showTera
        end
        
        if showTera
          pkmn = (illusion) ? poke : battler
          begin
            pbDrawImagePositions(@enhancedUIOverlay, [[@path + "info_extra", xpos + 182, ypos + 95]])
            pbDisplayTeraType(pkmn, @enhancedUIOverlay, xpos + 186, ypos + 97, true)
          rescue => e
             AdvancedAI.log("Error displaying Tera Type: #{e.message}", "Compatibility")
          end
        end
      end
    end
    AdvancedAI.log("DBK Enhanced Battle UI pbAddTypesDisplay compatibility patch applied", "Compatibility")
  end
  
  AdvancedAI.log("DBK pbCanTerastallize? compatibility patch applied", "Compatibility")
end

AdvancedAI.log("DBK Compatibility patches loaded", "Compatibility")

### FILE: Debug_Replacement.rb ###
#===============================================================================
# DEBUG: Log AI replacement Pokemon selection
#===============================================================================

class Battle::AI
  alias debug_choose_best_replacement_pokemon choose_best_replacement_pokemon
  def choose_best_replacement_pokemon(idxBattler, terrible_moves = false)
    echoln "=" * 80
    echoln "=== AI REPLACEMENT POKEMON DEBUG ==="
    echoln "  Battler Index: #{idxBattler}"
    echoln "  Terrible Moves?: #{terrible_moves}"
    echoln "  Trainer Skill: #{@trainer&.skill || 'Unknown'}"
    echoln "  Has ReserveLastPokemon?: #{@trainer&.has_skill_flag?('ReserveLastPokemon')}"
    
    party = @battle.pbParty(idxBattler)
    idxPartyStart, idxPartyEnd = @battle.pbTeamIndexRangeFromBattlerIndex(idxBattler)
    
    echoln "  Party Size: #{party.compact.length} (Start: #{idxPartyStart}, End: #{idxPartyEnd})"
    echoln "  --- PARTY ANALYSIS ---"
    party.each_with_index do |pkmn, i|
      next unless pkmn
      
      can_switch = @battle.pbCanSwitchIn?(idxBattler, i)
      is_active = @battle.pbFindBattler(i, idxBattler)
      is_last = (i == idxPartyEnd - 1)
      
      status = []
      status << "FAINTED" if pkmn.fainted?
      status << "ACTIVE" if is_active
      status << "LAST_POKEMON" if is_last
      status << "CAN_SWITCH" if can_switch
      status << "BLOCKED_pbCanSwitchIn" if !can_switch && !is_active && !pkmn.fainted?
      
      echoln "    [#{i}] #{pkmn.name}: #{status.join(', ')}"
    end
    
    result = debug_choose_best_replacement_pokemon(idxBattler, terrible_moves)
    
    echoln "  ─────────────────────────────────────"
    echoln "  RESULT: #{result >= 0 ? "Party Index #{result} (#{party[result]&.name})" : "NO VALID POKEMON (-1)"}"
    echoln "=" * 80
    
    return result
  end
end

### FILE: Hotfixes.rb ###
#===============================================================================
# [000] Hotfixes - Compatibility Patches
#===============================================================================
# Fixes compatibility issues with DBK Plugins and Essentials Core
# This file is loaded BEFORE all other Advanced AI modules ([000])
#===============================================================================

#===============================================================================
# DBK Wonder Launcher Compatibility
#===============================================================================
# DBK Wonder Launcher checks if Battle is a "Launcher Battle"
# BOTH classes need the method: Battle AND Battle::AI
#===============================================================================

# Battle Class: Main Method (if not already defined)
class Battle
  def launcherBattle?
    # Check if Wonder Launcher is active
    return @launcherBattle if instance_variable_defined?(:@launcherBattle)
    return false
  end unless method_defined?(:launcherBattle?)
end

# Battle::AI Delegation - ALWAYS define (overrides if necessary)
class Battle::AI
  # This method is called by DBK Wonder Launcher in Line 11
  # BEFORE it converts to battle.battle in Line 27
  def launcherBattle?
    # @battle is the actual Battle object (from attr_reader :battle)
    return false unless @battle
    return @battle.launcherBattle? if @battle.respond_to?(:launcherBattle?)
    return false
  end
end

# Debug: Confirm method was defined
puts "[Advanced AI] Battle::AI.launcherBattle? defined: #{Battle::AI.method_defined?(:launcherBattle?)}"

#===============================================================================
# DBK Improved Item AI Hotfix
#===============================================================================
# Problem: NoMethodError 'battler' for nil:NilClass (AIMove)
# Solution: Nil-safe battler method
#===============================================================================

if defined?(Battle::AI::AIMove)
  class Battle::AI::AIMove
    attr_reader :move # Expose underlying move safely
    
    alias original_battler battler if method_defined?(:battler)
    
    def battler
      return original_battler if respond_to?(:original_battler)
      return @battler if instance_variable_defined?(:@battler)
      return nil
    end
    
    # Explicitly delegate common category checks to avoid method_missing weirdness
    # Use safe checks that work with all Battle::Move subclasses
    def physical?
      return @move.physicalMove? if @move && @move.respond_to?(:physicalMove?)
      return @move.physical? if @move && @move.respond_to?(:physical?)
      return false
    end
    
    def special?
      return @move.specialMove? if @move && @move.respond_to?(:specialMove?)
      return @move.special? if @move && @move.respond_to?(:special?)
      return false
    end
    
    def status?
      return @move.statusMove? if @move && @move.respond_to?(:statusMove?)
      return @move.status? if @move && @move.respond_to?(:status?)
      return false
    end
    
    def damagingMove?
      return @move.damagingMove? if @move && @move.respond_to?(:damagingMove?)
      return !status?
    end
    
    def statusMove?
      return @move.statusMove? if @move && @move.respond_to?(:statusMove?)
      return status?
    end

    # Delegate missing methods to the underlying @move object
    # This fixes NoMethodError for power, multiHitMove?, etc.
    def method_missing(method_name, *args, &block)
      if @move && @move.respond_to?(method_name)
        return @move.send(method_name, *args, &block)
      end
      super
    end

    def respond_to_missing?(method_name, include_private = false)
      (@move && @move.respond_to?(method_name, include_private)) || super
    end
  end
end

#===============================================================================
# AIBattler Compatibility
#===============================================================================
# Problem: AIBattler wrapper missing common battler methods
# Solution: Delegate to underlying @battler
#===============================================================================

if defined?(Battle::AI::AIBattler)
  class Battle::AI::AIBattler
    # Delegate ability/item checks to underlying battler
    def hasActiveAbility?(ability)
      return @battler.hasActiveAbility?(ability) if @battler
      return false
    end
    
    def hasActiveItem?(item)
      return @battler.hasActiveItem?(item) if @battler
      return false
    end
  end
end

#===============================================================================
# Essentials Core Effectiveness Hotfix
#===============================================================================
# Problem: SystemStackError in Type::calculate (Recursion)
# Solution: Recursion Guard (max depth 10)
#===============================================================================

module Effectiveness
  @recursion_depth = 0
  MAX_RECURSION_DEPTH = 10
  
  class << self
    alias original_calculate calculate if method_defined?(:calculate)
    
    def calculate(attack_type, *target_types)
      return NORMAL_EFFECTIVE_MULTIPLIER if !attack_type
      target_types = target_types.compact
      return NORMAL_EFFECTIVE_MULTIPLIER if target_types.empty?
      
      @recursion_depth ||= 0
      @recursion_depth += 1
      
      if @recursion_depth > MAX_RECURSION_DEPTH
        @recursion_depth = 0
        return NORMAL_EFFECTIVE_MULTIPLIER
      end
      
      result = original_calculate(attack_type, *target_types)
      @recursion_depth -= 1
      return result
    rescue StandardError => e
      @recursion_depth = 0
      echoln "[Advanced AI] Effectiveness calculation error: #{e.message}" if defined?(echoln)
      return NORMAL_EFFECTIVE_MULTIPLIER
    end
  end
end

# GameData::Type Recursion Guard
if defined?(GameData::Type)
  module GameData
    class Type
      @type_recursion_depth = 0
      MAX_TYPE_RECURSION = 10
      
      class << self
        alias original_type_calculate calculate if method_defined?(:calculate)
        
        def calculate(attack_type, *target_types)
          @type_recursion_depth ||= 0
          @type_recursion_depth += 1
          
          if @type_recursion_depth > MAX_TYPE_RECURSION
            @type_recursion_depth = 0
            return Effectiveness::NORMAL_EFFECTIVE_ONE
          end
          
          result = original_type_calculate(attack_type, *target_types)
          @type_recursion_depth -= 1
          return result
        rescue StandardError => e
          @type_recursion_depth = 0
          echoln "[Advanced AI] Type calculation error: #{e.message}" if defined?(echoln)
          return Effectiveness::NORMAL_EFFECTIVE_ONE
        end
      end
    end
  end
end

puts "[Advanced AI] Hotfixes loaded: Wonder Launcher, Item AI, Type Effectiveness"

#===============================================================================
# Nil-Safe Effects Array Wrapper
#===============================================================================
# AIBattler.effects delegates to battler.effects which returns a raw Array.
# Some PBEffects indices may not be initialized, returning nil. Comparisons
# like `effects[PBEffects::Wish] > 0` then crash with NoMethodError.
# This wrapper returns 0 for nil numeric effects.
#===============================================================================
class NilSafeEffects
  # PBEffects that are boolean (true/false) rather than numeric counters
  # These must return false (not 0) when nil, since 0 is truthy in Ruby
  BOOLEAN_EFFECTS = [
    PBEffects::AquaRing, PBEffects::Charge, PBEffects::CurseGhost,
    PBEffects::Endure, PBEffects::FocusEnergy, PBEffects::GastroAcid,
    PBEffects::Grudge, PBEffects::HelpingHand, PBEffects::Imprison,
    PBEffects::Ingrain, PBEffects::MagicCoat, PBEffects::MudSport,
    PBEffects::Powder, PBEffects::Snatch, PBEffects::WaterSport,
    PBEffects::SmackDown, PBEffects::Torment
  ].compact.freeze rescue [].freeze

  def initialize(arr)
    @arr = arr || []
  end

  def [](idx)
    val = @arr[idx]
    return val unless val.nil?
    # Return false for boolean effects, 0 for numeric effects
    return false if BOOLEAN_EFFECTS.include?(idx)
    0
  end

  def []=(idx, val)
    @arr[idx] = val
  end

  def length;  @arr.length;  end
  def size;    @arr.size;    end
  def each(&block); @arr.each(&block); end

  def respond_to_missing?(method, include_private = false)
    @arr.respond_to?(method, include_private) || super
  end

  def method_missing(method, *args, &block)
    if @arr.respond_to?(method)
      @arr.send(method, *args, &block)
    else
      super
    end
  end
end

#===============================================================================
# AIBattler: Nil-safe effects for battler effects array
#===============================================================================
class Battle::AI::AIBattler
  def effects
    NilSafeEffects.new(battler.effects)
  end
end

#===============================================================================
# ActiveSide / ActiveField: Nil-safe effects for side & field arrays
# This covers ALL access paths: @battle.sides[i].effects, user.pbOwnSide.effects,
# target.pbOpposingSide.effects, @battle.field.effects, etc.
#===============================================================================
class Battle::ActiveSide
  alias _aai_original_effects effects unless method_defined?(:_aai_original_effects)
  def effects
    NilSafeEffects.new(_aai_original_effects)
  end
end

class Battle::ActiveField
  alias _aai_original_effects effects unless method_defined?(:_aai_original_effects)
  def effects
    NilSafeEffects.new(_aai_original_effects)
  end
end

# Test echoln output
echoln "═══════════════════════════════════════════════════"
echoln "[AAI] Advanced AI System v3.0.0 - DEBUG MODE ACTIVE"
echoln "[AAI] Console output is working!"
echoln "[AAI] Switch Intelligence Handler will be registered by [002] Core.rb"
echoln "═══════════════════════════════════════════════════"


### FILE: Mechanics_Hooks.rb ###
#===============================================================================
# Advanced AI System - Mechanics Hooks
# Connects Intelligence Modules to Battle System
#===============================================================================

class Battle::AI
  #-----------------------------------------------------------------------------
  # Main Hook: Register Enemy Special Actions
  # This is where the AI decides to use gimmicks (Mega, Z-Move, Dynamax, Tera)
  #-----------------------------------------------------------------------------
  # Check if the method already exists (from DBK or other plugins)
  # Use respond_to? on the class itself to avoid evaluation-time errors
  if Battle::AI.instance_methods.include?(:pbRegisterEnemySpecialAction)
    alias aai_pbRegisterEnemySpecialAction pbRegisterEnemySpecialAction 
    def pbRegisterEnemySpecialAction(idxBattler)
      # Check if this is a wild Pokemon with gimmick attributes
      # If so, DON'T call the original (which would auto-register gimmicks),
      # let AAI handle the decision intelligently
      battler = @battle.battlers[idxBattler]
      is_wild_with_gimmick = battler.wild? && (
        (battler.pokemon.respond_to?(:dynamax_lvl) && battler.pokemon.dynamax_lvl && battler.pokemon.dynamax_lvl > 0) ||
        (battler.pokemon.respond_to?(:tera_type) && battler.pokemon.tera_type && !battler.pokemon.tera_type.nil?)
      )
      
      if is_wild_with_gimmick
        AdvancedAI.log("Wild Pokemon with gimmick detected - skipping original hook to prevent auto-registration", "Hooks")
        # Skip original - go straight to AAI logic
        run_advanced_ai_special_actions(idxBattler)
      else
        # Normal path: call original (handles vanilla or other plugin logic)
        aai_pbRegisterEnemySpecialAction(idxBattler)
        # Then run AAI logic
        run_advanced_ai_special_actions(idxBattler)
      end
    end
  else
    # If method doesn't exist (vanilla Essentials v21.1),
    # we define it as a new method.
    # Note: This will be called by our hook in pbChooseEnemyAction
    def pbRegisterEnemySpecialAction(idxBattler)
      run_advanced_ai_special_actions(idxBattler)
    end
  end

  def run_advanced_ai_special_actions(idxBattler)
    
    # Get skill level - check if this is a wild battle first
    if @battle.wildBattle?
      # Wild Pokemon - use configured skill level if AI is enabled
      AdvancedAI.log("Wild Pokemon battle detected", "Hooks")
      
      # Check if this is a special wild battle mode (e.g., wilddynamax, wildterastallize)
      # If so, skip AAI processing and let DBK handle it
      if @battle.respond_to?(:wildBattleMode) && @battle.wildBattleMode
        AdvancedAI.log("Special wild battle mode detected (#{@battle.wildBattleMode}) - skipping AAI gimmick processing", "Hooks")
        return
      end
      
      unless AdvancedAI::ENABLE_WILD_POKEMON_AI
        AdvancedAI.log("Wild Pokemon AI is DISABLED", "Hooks")
        return
      end
      skill = AdvancedAI::WILD_POKEMON_SKILL_LEVEL
      AdvancedAI.log("Wild Pokemon - Using skill: #{skill}", "Hooks")
    elsif @trainer
      # Trainer battle - use trainer's skill
      skill = @trainer.skill
      AdvancedAI.log("Trainer battle - Skill: #{skill}", "Hooks")
    else
      # Fallback: no trainer and not wild - shouldn't happen, but default to 100
      skill = 100
      AdvancedAI.log("Unknown battle type - defaulting to skill 100", "Hooks")
    end
    
    return unless AdvancedAI.qualifies_for_advanced_ai?(skill)
    
    battler = @battle.battlers[idxBattler]
    AdvancedAI.log("Qualified for Advanced AI - checking gimmicks for #{battler.name}", "Hooks")
    
    # 3. Decision Pipeline
    # Priority: Mega > Z-Move > Dynamax > Tera
    # (Triggers are mutually exclusive usually per turn)
    
    # --- MEGA EVOLUTION ---
    AdvancedAI.log("Checking Mega Evolution...", "Hooks")
    if AdvancedAI.feature_enabled?(:mega_evolution, skill) && should_mega_evolve?(@user, skill)
      @battle.pbRegisterMegaEvolution(idxBattler)
      AdvancedAI.log("#{@user.name} registered Mega Evolution", "Hooks")
      return # Use one gimmick per turn decision to avoid conflicts
    end
    
    # --- Z-MOVES ---
    AdvancedAI.log("Checking Z-Moves...", "Hooks")
    if AdvancedAI.feature_enabled?(:z_moves, skill) && should_z_move?(@user, skill)
      @battle.pbRegisterZMove(idxBattler)
      AdvancedAI.log("#{@user.name} registered Z-Move", "Hooks")
      return
    end
    
    # --- DYNAMAX ---
    AdvancedAI.log("Checking Dynamax...", "Hooks")
    if AdvancedAI.feature_enabled?(:dynamax, skill) && should_dynamax?(@user, skill)
      @battle.pbRegisterDynamax(idxBattler)
      AdvancedAI.log("#{@user.name} registered Dynamax", "Hooks")
      return
    end
    
    # --- TERASTALLIZATION ---
    AdvancedAI.log("Checking Terastallization...", "Hooks")
    if AdvancedAI.feature_enabled?(:terastallization, skill) && should_terastallize?(@user, skill)
      @battle.pbRegisterTerastallize(idxBattler)
      AdvancedAI.log("#{@user.name} registered Terastallization", "Hooks")
      return
    end
  end
  
  #-----------------------------------------------------------------------------
  # Hook into pbChooseEnemyAction to trigger special action registration
  # This ensures gimmicks are considered even in vanilla Essentials v21.1
  # Only add this hook if the method exists (e.g., from DBK or other plugins)
  #-----------------------------------------------------------------------------
  if Battle::AI.instance_methods.include?(:pbChooseEnemyAction)
    alias aai_pbChooseEnemyAction pbChooseEnemyAction
    def pbChooseEnemyAction(idxBattler)
      # Register special actions (Mega, Z-Move, Dynamax, Tera) before choosing moves
      pbRegisterEnemySpecialAction(idxBattler) if respond_to?(:pbRegisterEnemySpecialAction)
      
      # Call original action selection
      aai_pbChooseEnemyAction(idxBattler)
    end
  end
end

AdvancedAI.log("Advanced AI Mechanics Hooks registered", "Hooks")

